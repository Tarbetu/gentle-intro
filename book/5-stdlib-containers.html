<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Standart Kütüphane Konteynırları - Rust&#x27;a Yumuşak Bir Başlangıç</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust diline, standart sistemine ve ekosistemine bir giriş.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="1-basics.html"><strong aria-hidden="true">1.</strong> Merhaba Dünya</a></li><li class="chapter-item expanded "><a href="2-structs-enums-lifetimes.html"><strong aria-hidden="true">2.</strong> Yapılar, Numaralandırmalar ve Eşleştirmeler</a></li><li class="chapter-item expanded "><a href="3-filesystem.html"><strong aria-hidden="true">3.</strong> Dosya Sistemi ve Süreçler</a></li><li class="chapter-item expanded "><a href="4-modules.html"><strong aria-hidden="true">4.</strong> Modüller ve Kargo</a></li><li class="chapter-item expanded "><a href="5-stdlib-containers.html" class="active"><strong aria-hidden="true">5.</strong> Standart Kütüphane Konteynırları</a></li><li class="chapter-item expanded "><a href="6-error-handling.html"><strong aria-hidden="true">6.</strong> Hataları Yönetmek</a></li><li class="chapter-item expanded "><a href="7-shared-and-networking.html"><strong aria-hidden="true">7.</strong> Sistem Süreçleri, Ağlar ve Paylaşım</a></li><li class="chapter-item expanded "><a href="object-orientation.html"><strong aria-hidden="true">8.</strong> Nesne Yönelimli Programlama</a></li><li class="chapter-item expanded "><a href="nom-intro.html"><strong aria-hidden="true">9.</strong> Yazıları Nom ile Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="pain-points.html"><strong aria-hidden="true">10.</strong> Rust ve Çektirdiği Çile</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust&#x27;a Yumuşak Bir Başlangıç</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="standart-kütüphane-konteynırları"><a class="header" href="#standart-kütüphane-konteynırları">Standart Kütüphane Konteynırları</a></h1>
<h1 id="belgeleri-anlamak"><a class="header" href="#belgeleri-anlamak">Belgeleri Anlamak</a></h1>
<p>Bu kısımda kabaca size Rust'ın standart kütüphanesinin bilindik bazı kısımlarını tanıtacağım. Belgelendirme gayet iyi ancak bağlamı tanıtmak ve biraz örneğin kimseye zararı olmaz.</p>
<p>Hepsinden önce Rust belgelerini okumak biraz yorucu gelebilir, bundan dolayı bir örneği inceleyeceğiz ki bu örnek <code>Vec</code> olacak. Kullanışlı bir tavsiye verelim, &quot;[-]&quot; belgeleri açıp kapamaya yarar. (Eğer <code>rustup component add rust-src</code> ile belgeleri indirmişseniz yanında bir de &quot;[src]&quot; bağlantısını göreceksiniz. Metotların bir krokisine buradan ulaşabilirsiniz. </p>
<p>Dikkat etmeniz gereken ilk detay, bütün ilişkili metotların <code>Vec</code>'in kendisinde tanımlanmadığıdır. Bunlar (çoğunlukla) <code>push</code> gibi vektörü değiştiren metotlardır. Bazı metotlar ise sadece vektörlerin içinde tuttuğu tiplere göre değişkenlik gösterir. Mesela, <code>dedup</code>'ı (kopyaları kaldır) sadece eşitliği denetlenebilir tipler üzerinde çalışır. <code>Vec</code> tipinde kullanılan birden fazla <code>impl</code> bloğu vardır ki bunlar içinde bulunduğu tiplerin çeşitliliğine göre şekillenmiştir.</p>
<p><code>Vec&lt;T&gt;</code> ile <code>&amp;[T]</code> arasında da özel bir ilişki olduğunu biliyoruz. Dilimler üzerinde çlışan her bir metot vektörler üzerinde doğrudan çalışacaktır, fazladan <code>as_slice</code> gibi metotlar kullanmanıza hiç gerek yoktur. Bu ilişki <code>Deref&lt;Target=[T]&gt;</code> ile gösterilir. Ayrıca bir vektörü referans olarak göstermek onu bir dilime çevirir - tip dönüşümlerinin nadiren gerçekleştiği nadir yerlerden birisidir. İlk öğeyi geri dönen <code>first</code> gibi dilim metotları, ya da bunun tersini yapan <code>last</code>, vektörler için de kullanılabilir. Metotların pek ciddi bir kısmı karakter dizilerini çağrıştırabilir, mesela <code>split_at</code> dilimi belirli bir indekse göre ayırır, <code>starts_with</code> bir vektörün belirli bir veri silsilesi ile başlayıp başlamadığını belirtir, <code>contains</code> bir vektörün belirli bir veriyi içerip içermediğini belirtir.</p>
<p>Belirli bir verinin indeksini bulmak için Rust'ta <code>search</code> metotu yoktur. Şimdi size size esas olayı anlatayım; eğer konteynırda metotu bulamazsanız, döngüleyici metotlarına bakın:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = vec![10,20,30,40,50];
    assert_eq!(v.iter().position(|&amp;i| i == 30).unwrap(), 2);
<span class="boring">}</span></code></pre></pre>
<p>( <code>&amp;</code> kullanmamızın sebebi döngüleyicinin referanslar üzerinde çalışmasıdır - alternatif olarak kıyaslamak için <code>*i == 30</code> kullanabilirsiniz.)</p>
<p>Benzer şekilde vektörler üzerinde <code>map</code> metotu yoktur çünkü <code>iter().map(...).collect</code> ile aynı pekâlâ işi yapabilirsiniz. Rust, gerekmedikçe bellek tahsis etmeyi sevmez - çoğu zaman hâlihazırda bellekte yer tutan <code>map</code>'ın bütün sonuçlarına ihtiyacınız olmaz. </p>
<p>Döngüleyici (<code>iterator</code>) metotlarına aşina olmanızı tavsiye ederim çünkü iç içe girmiş döngülerle boğuşmadığınız iyi bir Rust kodu yazmak için elzemdirler. Her zaman olduğu gibi, büyük bir program yazarken bir anda onlarla güreşmek yerine döngüleyici metotlarını keşfetmek için minik programlar yazın.</p>
<p><code>Vec&lt;T&gt;</code> ve <code>&amp;[T]</code> metotları birbirleriyle ortak özellikleri (trait) paylaşırlar: vektörler kendi hata ayıklama bilgilerinin nasıl gösteirlebilirler. (Eğer bütün öğeler <code>Debug</code> özelliğine sahipse.) Aynı şekilde, eğer bütün öğeleri klonlanabilirlerse kendileri de klonlanabilirler. <code>Drop</code> özelliğine sahiptirler, bir vektör düşürüldüğü zaman bellekteki yerleri boşaltılır ve tek tek bütün öğeleri de düşürülür.</p>
<p><code>Extend</code> özelliği döngüleyicilerdeki değerlerin bir döngü içerisine herhangi bir döngü kurmadan eklenebileceğini ifade eder.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>v.extend([60,70,80].iter());
let mut strings = vec![&quot;hello&quot;.to_string(), &quot;dolly&quot;.to_string()];
strings.extend([&quot;you&quot;,&quot;are&quot;,&quot;fine&quot;].iter().map(|s| s.to_string()));
<span class="boring">}</span></code></pre></pre>
<p>Aynı zamanda <code>FromIterator</code> özelliği de vektörlerin döngüleyicilerden <em>inşa edilebileceğini</em> ifade eder. (Döngülerin <code>collect</code> metotu bunu kullanır.)</p>
<p>Her konteynır döngülenebilir olmalıdır. <a href="#">Üç tarz-ı döngüleyiciyi</a> hatırlayın.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for x in v {...} // returns T, consumes v
for x in &amp;v {...} // returns &amp;T
for x in &amp;mut v {...} // returns &amp;mut T
<span class="boring">}</span></code></pre></pre>
<p><code>for</code> deyimi <code>IntoIterator</code> üzerinde iş yapar ve buna bağlı olarak üç farklı kullanımı vardır.</p>
<p>Bir de <code>Index</code> (Bir vektörden okurken çalışan) bir de <code>IndexMut</code> (Bir vektörü düzenlerken çalışan) ile kontrol edilen indekslememiz vardır. Pek çok şey yapabiliriz çünkü <code>v[0..2]</code> gibi ifadelerle dilimlere indeksleyebilir ve dönebiliriz ya da sadece <code>v[0]</code> ile ilk elemana referans alabiliriz.</p>
<p><code>From</code> özelliğinin de birtakım kullanımları vardır. Mesela <code>Vec::from(&quot;hello&quot;.to_string())</code> size karakter dizelerinin özündeki <code>Vec&lt;u8&gt;</code> tipindeki vektörü verecektir. Ancak şunu düşünebilirsiniz, zaten <code>String</code> tipi için <code>into_bytes</code> diye bir vektör varken bunun ne özelliği var? Bir işi yapmanın birden çok yolu olması saçma değil mi? Ancak bu, özelliklerin (traits) genellenen metotlar oluşturması için gerekliliktir. </p>
<p>Bazen Rust'ın tip sisteminin kısıtlamalarından illallah edebilirsiniz. Mesela <code>PartialEq</code> boyutu 32'den az olan diziler için <em>ayrıca</em> tanımlanmıştır. (Bunu iyileştirecekler.) Bu vektörlerle dizileri doğrudan rahatça kıyaslamanızı sağlar ancak boyut sınırına dikkat etmelisiniz. </p>
<p>Belgelendirmenin diplerinde bazı <a href="https://www.youtube.com/watch?v=j6K5IblbBzE">gizli hazinelerle</a> karşılaşabilirsiniz. Tıpkı Karol Kuczmarski'nin dediği gibi; &quot;Kimse bu kadar arayıp taramaz.&quot;. Bir döngüleyicideki hataları nasıl yönetmelisiniz? Mesela bir döngüleyici üzerinde <code>map</code> kullandığınızda bazı öğeler sorun çıkarabilir ve size <code>Result</code> dönebilirler, böyle bir döngüleyici ile çalışacağınızı düşünün:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = [&quot;5&quot;,&quot;52&quot;,&quot;65&quot;];
    let iter = nums.iter().map(|s| s.parse::&lt;i32&gt;());
    let converted: Vec&lt;_&gt; = iter.collect();
    println!(&quot;{:?}&quot;,converted);
}
//[Ok(5), Ok(52), Ok(65)]</code></pre></pre>
<p>Yeterince iyi, ama tek tek bütün hataları kontrol etmeniz gerekiyor - dikkatlice! Ancak Rust bu işin doğrusunu yapar, eğer vektörün <code>Result</code> içerisinde barındırılmasını isterseniz - hepsi bu, eğer bir hata varsa bütün vektörü hatalı kabul edebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let converted: Result&lt;Vec&lt;_&gt;,_&gt; = iter.collect();
//Ok([5, 52, 65])
<span class="boring">}</span></code></pre></pre>
<p>Ya dönüşüm başarısız olursa? İlk hatada işi fazla uzatmadan hemen <code>Err</code> döner. <code>collect</code>'in nasıl da esnek olduğuna dair iyi bir örnek olduğunu düşünebiliriz. (Tip bildirimini tuhaf bulabilirsiniz. <code>Vec&lt;_&gt;</code> kabaca bu bir vektör, <code>Result&lt;Vec&lt;_&gt;,_&gt;</code> herhangi bir vektörün <code>Result</code> tipi demektir. Siz ne istediğini belirttikten sonra Rust sizin yerinize işi çözer.)</p>
<p>Belgelendirmede <em>epeyce</em> detay var ancak ne olursa olsun C++'ın <code>std::vector</code> hakkındaki bilgilendirmesinden çok daha anlaşılır ve net.</p>
<blockquote>
<p>Öğelerin gerektiği gereksinimler konteynırın üzerinde yapılan işlemlere dayanır. Çoğunlukla elemanın tipinin karşılanması ve düşürülebilir olması (drop) yeterlidir ancak bazı fonksiyonların katı gereksinimleri vardır.</p>
</blockquote>
<p>C++'da kendi başınızın çaresine bakmanız gerekir. Rust'ın ilk başta her şeyi aleni olarak beklemesi sizi ürkütebilir ancak kısıtlamaları anlarken herhangi bir <code>Vec</code> metotunun gereksinimlerini de anlayacaksınız. </p>
<p>Kaynak kodlarını <code>rustup component add rust-src</code> ile okumanızı tavsiye ederim, standart kütüphanenin kodları oldukça okunaklıdır ve metotların içeriği tanımlarından çok daha anlaşılırdır.</p>
<h1 id="sözlükler-maps"><a class="header" href="#sözlükler-maps">Sözlükler (Maps)</a></h1>
<p><em>Sözlükler (HashMap)</em> dilediğiniz veriye bir <em>anahtar</em> ile ulaşabilmenizi sağlar. Aman aman bir fikir değil ve dilerseniz aynı şeyi demet dizisi ile yapabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let entries = [(&quot;one&quot;,&quot;eins&quot;),(&quot;two&quot;,&quot;zwei&quot;),(&quot;three&quot;,&quot;drei&quot;)];

    if let Some(val) = entries.iter().find(|t| t.0 == &quot;two&quot;) {
        assert_eq!(val.1,&quot;zwei&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>Küçük sözlükler ve sadece anahtar denkliği gerektiren durumlar için üstteki örnek iş görür, ancak içerisinde bir şey aramanın süresi doğru orantıya tabidir - sözlüğün büyüklüğü ile doğru orantılı. </p>
<p>Pek çok <em>anahtar/veri çifti</em> gerektiği zaman bir <code>HashMap</code> ile çalışmak çok çok daha verimlidir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;one&quot;,&quot;eins&quot;);
map.insert(&quot;two&quot;,&quot;zwei&quot;);
map.insert(&quot;three&quot;,&quot;drei&quot;);

assert_eq! (map.contains_key(&quot;two&quot;), true);
assert_eq! (map.get(&quot;two&quot;), Some(&amp;&quot;zwei&quot;));
<span class="boring">}</span></code></pre></pre>
<p><code>&amp;&quot;zwei&quot;</code> mı? <code>get</code> ile verinin kendisini değil de <em>referansını</em> döndüğü için böyle bir şey görüyoruz. Eğer verinin tipi <code>&amp;str</code> ise pekâlâ <code>&amp;&amp;str</code> alabiliriz. Alacağımız verinin <em>referans</em> olması gerekir çünkü çoğu zaman sahipli tiplerin değerlerini <em>taşımak</em> istemeyiz.</p>
<p><code>get_mut</code> tıpkı <code>get</code> gibi çalışır ancak değişebilir bir referans döner. Şimdi karakter dizilerini sayılara çeviren bir sözlüğü inceleyelim ve &quot;two&quot; değerini güncellemeye çalışalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut map = HashMap::new();
map.insert(&quot;one&quot;,1);
map.insert(&quot;two&quot;,2);
map.insert(&quot;three&quot;,3);

println!(&quot;before {}&quot;, map.get(&quot;two&quot;).unwrap());

{
    let mut mref = map.get_mut(&quot;two&quot;).unwrap();
    *mref = 20;
}

println!(&quot;after {}&quot;, map.get(&quot;two&quot;).unwrap());
// before 2
// after 20
<span class="boring">}</span></code></pre></pre>
<p>Referansı farklı bir bloğa aldığımıza dikkat edin - aksi taktirde sonuna kadar değişebilir bir referansımız olurdu ve Rust <code>map</code>, <code>map.get(&quot;two&quot;)</code> ile hiçbir şeyi ödünç almamıza izin vermezdi; değişebilir bir referans varken değişmez referanslara izin verilmez. (Eğer izin verilseydi, değişmez referansların geçerliliği şaibeli olurdu.) Bundan dolayı değişebilir referansı erkenden aradan çıkararak işi çözmüş oluyoruz.</p>
<p>Elbette bunun çok zarif bir API olduğunu söyleyemeyiz ama hatalara karşı daha dikkatli davranırız. Python olsa ters bir durumda hemen ekrana hata mesajları dizer ve C++ ise bize varsayılan veri dönerdi. (Aslında güzel bir çözüm ancak bazı sorunları var. Mesela <code>a_map[&quot;two&quot;]</code> 0 döndüğü zaman &quot;bulunamadı&quot; mesajı ile gerçek sıfırın arasındaki farkı anlayamayız. <em>Üstüne de</em> fazladan bir girdi atanmış olur.)</p>
<p>Kimse <code>unwrap</code> kullanmaz, örneklerde öyle değil tabii. Gördüğünüz çoğu Rust kodu da bağımsız örneklerden oluştuğu için yaygın olarak kullanıldığı kanısına kapılabilirsiniz. Ancak çoğu zaman bir eşleşmenin kullanılması daha olasıdır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(v) = map.get(&quot;two&quot;) {
    let res = v + 1;
    assert_eq!(res, 3);
}
...
match map.get_mut(&quot;two&quot;) {
    Some(mref) =&gt; *mref = 20,
    None =&gt; panic!(&quot;_now_ we can panic!&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>Dilenirse anahtar/veri ikilileri üzerinde döngü kurabilirsiniz ancak belli bir sırası yoktur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (k,v) in map.iter() {
    println!(&quot;key {} value {}&quot;, k,v);
}
// key one value eins
// key three value drei
// key two value zwei
<span class="boring">}</span></code></pre></pre>
<p>Ek olarak <code>keys</code> ve <code>values</code>'un döngüleyici dönen metotları vardır ki bu değerlerden vektör kullanmayı epeyce kolaylaştırır.</p>
<h1 id="Örnek-kelimeleri-saymak"><a class="header" href="#Örnek-kelimeleri-saymak">Örnek: Kelimeleri saymak</a></h1>
<p>Metinleri anlamak için yapabileceğiniz keyifli işlerden birisi bir metinde kaç farklı kelime olduğunu sayabilmektir. Bir metni kelimelere bölmek <code>split_whitespace</code>  ile oldukça kolaydır ancak noktalama işaretlerine özen göstermemiz gerekir. Bundan dolayı kelimeler sadece alfabetik karakterden oluşacak şekilde bölünmelidir. Üstelik kelimeler işleme tamamen küçük harfli olarak alınmalıdır.</p>
<p>Bir sözlükte içeriği değiştirecek tarzdan bir şey aramak kolaydır ancak arama başarısız olduğu zaman ne yapacağını belirtmek biraz tuhaf kaçabilir. Neyse ki hata koşulunu kontrol etmek için gayet zarif bir çözümümüz var:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut map = HashMap::new();

for s in text.split(|c: char| !c.is_alphabetic()) {
    let word = s.to_lowercase();
    let mut count = map.entry(word).or_insert(0);
    *count += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>Eğer aradığımız kelime sözlükte yoksa sözlüğe sıfır içeren yeni bir girdi yaratıyoruz ve onu sözlüğe sokuyoruz (<em>insert</em>). C++'daki sözlükler de aynen böyle çalışır tek fark burada varsayılan veri kendiliğinden gelmez ve net bir şekilde belirtilir. </p>
<p>Bu kapamada (<em>closure</em>) net bir tip belirttik ve tip de <code>char</code> oluyor. Bunun nedeni <code>split</code> tarafından kullanılan karakter dizilerinin <code>Pattern</code> özelliğinin tuhaflığıdır. Ancak Rust burada sözlüğün anahtar tipinin <code>String</code>, sözlüğün veri tipinin de <code>i32</code> olduğunu çıkarabilir. </p>
<p>Gutenberg projesinden <a href="http://www.gutenberg.org/cache/epub/1661/pg1661.txt">Sherlock Holmes'un maceraları'nı (The Adventures of Sherlock Holmes)</a> kullanarak bunu güzelce test edebiliriz. (<code>map.len()</code> ile) Öğreniyoruz ki birbirinden farklı toplam 8071 kelime kullanılmış. </p>
<p>Peki ya en çok kullanılan yirmi kelimeyi nasıl öğrenebiliriz? Öncelikle sözlüğümüzü bir (anahtar, veri) formatında demetlerle dolu bir vektöre çevirebiliriz. (Bu <code>map</code>ı yok edecektir, çünkü <code>into_iter</code> kullandık)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut entries: Vec&lt;_&gt; = map.into_iter().collect();
<span class="boring">}</span></code></pre></pre>
<p>Sonra bunları azalacak şekilde dizelim. <code>sort_by</code>, <code>cmp</code> metotunun sonuçlarını bekleyecektir ki bu metot sayı tiplerinde bulunur. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    entries.sort_by(|a,b| b.1.cmp(&amp;a.1));
<span class="boring">}</span></code></pre></pre>
<p>Ve bu sayıları ilk yirmi çıktıyı ekrana yazdıralım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for e in entries.iter().take(20) {
        println!(&quot;{} {}&quot;, e.0, e.1);
    }
<span class="boring">}</span></code></pre></pre>
<p>(Sadece <code>0..20</code> üzerinde bir döngü <em>kurabilirdiniz</em> - bu kabul edilebilir ancak Rust'ın kendisine özgü tarzının dışına çıkmış olurduk - üstelik büyük döngüler için daha maliyetli olurdu.)</p>
<pre><code> 38765
the 5810
and 3088
i 3038
to 2823
of 2778
a 2701
in 1823
that 1767
it 1749
you 1572
he 1486
was 1411
his 1159
is 1150
my 1007
have 929
with 877
as 863
had 830
</code></pre>
<p>Listenin başında bir tuhaflık sezdiniz mi? O aslında boş bir kelime. <code>split</code> metotu tek karaktere göre parçaladığı için iki noktalama işaretinin arasındaki boşlukklar da kelimeden sayılmış oldu.</p>
<h1 id="kümeler-setshashsets"><a class="header" href="#kümeler-setshashsets">Kümeler (Sets/HashSets)</a></h1>
<p>Kümeleri sadece anahtarlarını umursadığınız sözlükler olarak düşünebilirsiniz, anahtarların karşılığı yoktur. Bundan dolayı <code>insert</code> sadece tek bir veri alır ve dilerseniz <code>contains</code> kullabilirsiniz. </p>
<p>Ç.N: Teknik olarak doğru olsa da buradaki tanımı karmaşık buldum. Kümeleri basitçe her verisi özgün olan, aynı veriyi ikinci kez almayan sırasız bir vektör gibi düşünebilirsiniz.</p>
<p>Diğer konteynırlar gibi bir döngüleyiciden <code>HashSet</code> oluşturabilirsiniz. <code>collect</code> ile bu işi yapabilirsiniz, tipi bildirdiğiniz sürece.</p>
<pre><pre class="playground"><code class="language-rust">// set1.rs
use std::collections::HashSet;

fn make_set(words: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    words.split_whitespace().collect()
}

fn main() {
    let fruit = make_set(&quot;apple orange pear orange&quot;);

    println!(&quot;{:?}&quot;, fruit);
}
// {&quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot;}</code></pre></pre>
<p>Aynı anahtarın tekrar girmiş olmanız (beklenildiği gibi) hiçbir etki oluşturmaz ve bir verideki sıralaması önemli değildir. </p>
<p>Matematikteki setlerle yaptığınız işlemleri pekâlâ Rust ile de yapabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fruit = make_set(&quot;apple orange pear&quot;);
let colours = make_set(&quot;brown purple orange yellow&quot;);

for c in fruit.intersection(&amp;colours) {
    println!(&quot;{:?}&quot;,c);
}
// &quot;orange&quot;
<span class="boring">}</span></code></pre></pre>
<p>Bütün işlemler döngüleyici döner ve <code>collect</code> kullanarak onları tekrardan sete çevirebilirsiniz.</p>
<p>İşte bir kısayol, vektörleri nasıl kullanıyorsak aynı şekilde kullanabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::Hash;

trait ToSet&lt;T&gt; {
    fn to_set(self) -&gt; HashSet&lt;T&gt;;
}

impl &lt;T,I&gt; ToSet&lt;T&gt; for I
where T: Eq + Hash, I: Iterator&lt;Item=T&gt; {

    fn to_set(self) -&gt; HashSet&lt;T&gt; {
       self.collect()
    }
}

...

let intersect = fruit.intersection(&amp;colours).to_set();
<span class="boring">}</span></code></pre></pre>
<p>Bütün Rust jeneriklerinde olduğu gibi burada da tipleri özelliklerle kısıtlamanız gereklidir - yukarıdaki kod sadece eşitliği (<code>Eq</code>) ve &quot;hash fonksiyonu&quot; (<code>Hash</code>) bulunan tipler için çalışır. <code>Iterator</code> diye bir tip bulunmadığını ve <code>I</code>'nın <code>Iterator</code> özelliğine sahip bir tip olması gerektiğini belirtiyoruz.</p>
<p>Standart kütüphane tiplerinine kendi metotlarımızı eklemek gözünüze biraz abartılı görünebilir ancak unutmayın ki kurallar var. Bunu sadece kendi özelliklerimize (<em>trait</em>) uygulayabiliriz. Eğer özelliğin ve yapının (<em>struct</em>) ikisi de aynı sandıktan geliyorsa (Mesela ki standart kütüphaneyi sunan &quot;stdlib&quot;) bu tarz bir kullanıma izin verilmeyecektir. Bu şekilde bir dikkat dağınıklığından kurtulabiliyoruz.</p>
<p>Kendimizi bu zekice ve uygun kısayolu bulduğumuz için övmeye başlamadan önce yaratabileceği sonuçlara dikkat etmelisiniz. Eğer <code>make_set</code> aşağıdaki gibi kullanılırsa, ki burada sahipli bir tip olan <code>String</code>'in kümesi vardır, <code>intersect</code>'in tipi sizi epeyce bir şaşırtabilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_set(words: &amp;str) -&gt; HashSet&lt;String&gt; {
    words.split_whitespace().map(|s| s.to_string()).collect()
}
...
// intersect is HashSet&lt;&amp;String&gt;!
let intersect = fruit.intersection(&amp;colours).to_set();
<span class="boring">}</span></code></pre></pre>
<p>Rust sahipli karakter dizilerinin kopyalarını oluşturmadığı için aksi olamaz. <code>intersect</code>'in içerisinde <code>fruit</code>ten ödünç alınmış tek bir <code>&amp;String</code> bulunmakta. Bunun daha sonra size zorluk çıkaracağına yemin edebilirim, mesela ki yaşam sürelerini belirtmeye başalrken. Daha iyi bir çözüm, döngüleyicinin <code>cloned</code> metotunu kullanarak kesişim için kendi sahipli tiplerinizi üretmenizdir. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// intersect is HashSet&lt;String&gt; - much better
let intersect = fruit.intersection(&amp;colours).cloned().to_set();
<span class="boring">}</span></code></pre></pre>
<p><code>to_set</code>'in daha iyi bir tanımı, <code>self.cloned().collect()</code> ile hazırlanabilir ki bir de bunu böyle denemenizi tavsiye ediyorum.</p>
<h1 id="Örnek-İnteraktif-olarak-komut-İşleme"><a class="header" href="#Örnek-İnteraktif-olarak-komut-İşleme">Örnek: İnteraktif Olarak Komut İşleme</a></h1>
<p>Bir programın interaktif bir oturumu olması oldukça kullanışlı olabilir. Her bir satır kendi başına işleme alınır ve içindeki kelimelere bölünür; komut ilk bölümde yer alır ve geri kalan kelimeler ise komutun argümanları olur.</p>
<p>Bunun en akla yatan çözümlerinden birisi komut isimlerinden kapamalara (closure) ulaşılabilen bir sözlük inşa etmek olur. Peki ya nasıl kapamaları bir yerde barındıracağız? Hepsinin farklı boyutları olduğunu düşününce kulağa daha zor geliyor. En uygun çözüm, onların kopyalarını <code>heap</code>'a kutulamaktır (box):</p>
<p>Hadi deneyelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v = Vec::new();
    v.push(Box::new(|x| x * x));
    v.push(Box::new(|x| x / 2.0));

    for f in v.iter() {
        let res = f(1.0);
        println!(&quot;res {}&quot;, res);
    }
<span class="boring">}</span></code></pre></pre>
<p>İkinci <code>push</code> kullanımında çok net bir hata alacağız:</p>
<pre><code>  = note: expected type `[closure@closure4.rs:4:21: 4:28]`
  = note:    found type `[closure@closure4.rs:5:21: 5:28]`
note: no two closures, even if identical, have the same type
</code></pre>
<p>Ç.N: Aynı görünseler bile iki kapama asla aynı tipte olmayacaktır. </p>
<p><code>rustc</code> gereğinden fazla spesifik bir tip çıkarımında bulundu, bundan dolayı vektörün içindeki tipi kendimiz <em>kutulanmış özellik tipi (boxed trait type)</em> olarak belirtmeliyiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v: Vec&lt;Box&lt;Fn(f64)-&gt;f64&gt;&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>Şimdi kutulanmış kapamaları <code>HashMap</code> (sözlük) tipi için de kullanabiliriz. Kapamalar bulundukları ortamlardan veri çekebildikleri için yaşam sürelerini takip etmeliyiz.</p>
<p><code>FnMut</code>u kullanmayı düşünebilirsiniz - çünkü yakaladıkları her türlü değişkenleri düzenleyebilirler. Ancak bir kapamaya tekabül eden birden fazla komutumuz bulunacağı için tekrar tekrar değişebilir referanslar alamazsınız.</p>
<p>Böylece kapamalar argümanlara <em>değişebilir referanslar</em> olarak erişir, karakter dizilerinin dilimleri de (<code>&amp;[&amp;str]</code>) satırdaki argümanları alır. Tasarladığımız yapıda geri dönüşü <code>Result</code> ile paketleyeceğiz - hata olarak en önce <code>String</code> kullanacağız.</p>
<p><code>D</code> boyutu belli olan herhangi bir tipi gösterir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type CliResult = Result&lt;String,String&gt;;

struct Cli&lt;'a,D&gt; {
    data: D,
    callbacks: HashMap&lt;String, Box&lt;Fn(&amp;mut D,&amp;[&amp;str])-&gt;CliResult + 'a&gt;&gt;
}

impl&lt;'a,D: Sized&gt; Cli&lt;'a,D&gt; {
    fn new(data: D) -&gt; Cli&lt;'a,D&gt; {
        Cli{data: data, callbacks: HashMap::new()}
    }

    fn cmd&lt;F&gt;(&amp;mut self, name: &amp;str, callback: F)
    where F: Fn(&amp;mut D, &amp;[&amp;str])-&gt;CliResult + 'a {
        self.callbacks.insert(name.to_string(),Box::new(callback));
    }
<span class="boring">}</span></code></pre></pre>
<p><code>cmd</code> imzaya göre bir isim ve bir kapama alır, kapama kutulanmış ve sözlüğe girmiş olmalıdır. <code>Fn</code> ise çevreden verileri ödünç alabilir ancak düzenleyemez demektir. Bu tarz genelleme metotları en kötüsüdür, imzasına bakarken kafanız karışık ancak içeriği pirüpak anlaşılırdır! Yaşam ömrünü belirtmeyi unutmak burada en sık yapılan hatalardandır - Rust, çevresine kısıtlanmış kapamaların yaşam ömürlerini unutmanızı hoş görmeyecektir!</p>
<p>Şimdi komutları inceleyelim ve çalıştıralım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn process(&amp;mut self,line: &amp;str) -&gt; CliResult {
        let parts: Vec&lt;_&gt; = line.split_whitespace().collect();
        if parts.len() == 0 {
            return Ok(&quot;&quot;.to_string());
        }
        match self.callbacks.get(parts[0]) {
            Some(callback) =&gt; callback(&amp;mut self.data,&amp;parts[1..]),
            None =&gt; Err(&quot;no such command&quot;.to_string())
        }
    }

    fn go(&amp;mut self) {
        let mut buff = String::new();
        while io::stdin().read_line(&amp;mut buff).expect(&quot;error&quot;) &gt; 0 {
            {
                let line = buff.trim_left();
                let res = self.process(line);
                println!(&quot;{:?}&quot;, res);

            }
            buff.clear();
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Gayet anlaşılır - satırları kelimelere ayırıp bir vektörde topluyoruz, ardından sözlükte ilk kelimeyi aratıyoruz ve sözlüğün döndüğü kapamayı değişebilir verilerimizle ve kelimenin geri kalanlarıyla çağırıyoruz. Boş satırlar görmezden gelinir ve hata olarak değerlendirilmez.</p>
<p>Şimdi kapamalarımızın olumlu ve olumsuz sonuçlar dönmesini kolaylaştırmak için yardımcı fonksiyonlar tanımlayalım. Burada zekice <em>ufak</em> bir detay var; 
tanımladığımız genellenen fonksiyonların çalıştığı tipleri &quot;<code>String</code>&quot;e çevirebilir. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ok&lt;T: ToString&gt;(s: T) -&gt; CliResult {
   Ok(s.to_string())
}

fn err&lt;T: ToString&gt;(s: T) -&gt; CliResult {
   Err(s.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>İşte karşımızda ana programımız var. &quot;<code>ok(answer)</code>&quot;ın nasıl çalıştığına dikkat edin - çünkü sayılar kendilerini nasıl karakter dizilerine çevrileceğini iyi bilirler!</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;

fn main() {
    println!(&quot;Welcome to the Interactive Prompt! &quot;);

    struct Data {
        answer: i32
    }

    let mut cli = Cli::new(Data{answer: 42});

    cli.cmd(&quot;go&quot;,|data,args| {
        if args.len() == 0 { return err(&quot;need 1 argument&quot;); }
        data.answer = match args[0].parse::&lt;i32&gt;() {
            Ok(n) =&gt; n,
            Err(e) =&gt; return err(e.description())
        };
        println!(&quot;got {:?}&quot;, args);
        ok(data.answer)
    });

    cli.cmd(&quot;show&quot;,|data,_| {
        ok(data.answer)
    });

    cli.go();
}</code></pre></pre>
<p>Hataları biraz uyduruk bir yoldan ele aldık ve bu tarz durumlarda soru işareti operatörünün nasıl çalıştığının inceleyeceğiz. Basitçe <code>std::num::ParseIntError</code> hatası <code>std::errror::Errır</code> özelliğini (<em>trait</em>) içeriyor ki bu bulunduğumuz bloğa <code>description</code> metotunu getiriyor - Rust özellikler erişilebilir olmadan üzerinde işlem yapmamıza izin vermez.</p>
<p>Ve çalıştıralım:</p>
<pre><code>Welcome to the Interactive Prompt!
go 32
got [&quot;32&quot;]
Ok(&quot;32&quot;)
show
Ok(&quot;32&quot;)
goop one two three
Err(&quot;no such command&quot;)
go 42 one two three
got [&quot;42&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
Ok(&quot;42&quot;)
go boo!
Err(&quot;invalid digit found in string&quot;)
</code></pre>
<p>Denemek isteyeceğiniz pek çok iyileştirme olabilir. Mesela <code>cmd</code> komutuna yardım satırını içeren üçüncü bir argüman ekleyebilir, <code>help</code> komutuna bu üçüncü argümanla cevap verebilirdik. Ya da Cargo ile <a href="https://crates.io/crates/rustyline">rustyline</a> sandığını kullanarak komut düzenleme ve geçmişe dönmek konularını daha akılcı bir yoldan halledebiliriz.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="4-modules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="6-error-handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="4-modules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="6-error-handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
