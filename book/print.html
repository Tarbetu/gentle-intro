<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust&#x27;a Yumuşak Bir Başlangıç</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust diline, standart sistemine ve ekosistemine bir giriş.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="1-basics.html"><strong aria-hidden="true">1.</strong> Merhaba Dünya</a></li><li class="chapter-item expanded "><a href="2-structs-enums-lifetimes.html"><strong aria-hidden="true">2.</strong> Yapılar, Numaralandırmalar ve Eşleştirmeler</a></li><li class="chapter-item expanded "><a href="3-filesystem.html"><strong aria-hidden="true">3.</strong> Dosya Sistemi ve Süreçler</a></li><li class="chapter-item expanded "><a href="4-modules.html"><strong aria-hidden="true">4.</strong> Modüller ve Kargo</a></li><li class="chapter-item expanded "><a href="5-stdlib-containers.html"><strong aria-hidden="true">5.</strong> Standart Kütüphane Konteynırları</a></li><li class="chapter-item expanded "><a href="6-error-handling.html"><strong aria-hidden="true">6.</strong> Hataları Yönetmek</a></li><li class="chapter-item expanded "><a href="7-shared-and-networking.html"><strong aria-hidden="true">7.</strong> Sistem Süreçleri, Ağlar ve Paylaşım</a></li><li class="chapter-item expanded "><a href="object-orientation.html"><strong aria-hidden="true">8.</strong> Nesne Yönelimli Programlama</a></li><li class="chapter-item expanded "><a href="nom-intro.html"><strong aria-hidden="true">9.</strong> Yazıları Nom ile Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="pain-points.html"><strong aria-hidden="true">10.</strong> Rust ve Çektirdiği Çile</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust&#x27;a Yumuşak Bir Başlangıç</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="neden-yeni-bir-programlama-dili-öğrenmelisiniz"><a class="header" href="#neden-yeni-bir-programlama-dili-öğrenmelisiniz">Neden yeni bir programlama dili öğrenmelisiniz?</a></h1>
<p><img src="https://stevedonovan.github.io/rust-gentle-intro/PPrustS.png" alt="Rust hakkında bir karikatür" /></p>
<p><a href="https://leftoversalad.com/c/015_programmingpeople/">David Marino'ya teşekkürlerle!</a></p>
<blockquote>
<p>Karikatürün çevirisi:
Rust: Bu gece şöförlük yapacağım.
Dış ses: Biliyoruz.
Rust: Konuşurken yemek yeme çünkü boğazına takılırsa ölürsün. Haha.</p>
</blockquote>
<p>Bu rehberin amacı <a href="https://doc.rust-lang.org/stable/book/">kutsal kitabımız gibi</a> İnternet'te bulabileceğiniz çeşitli kaynakları anlayacak kadar Rust okuryazarlığı aşılamaktır. Rehberi, bu programlama dilinin gücünü tonla şeyin arasına girmeden gücünü anlamak ve denemek için bir fırsat olarak düşünebilirsiniz.</p>
<p>Einstein'in dediği gibi, &quot;Her şeyi olabildiğince yumuşak yapın, ama yumuş yumuş olmasın.&quot; (Ç.N: Einstein'in &quot;Her şeyi daha sade yapın, ama basit değil&quot; sözüne gönderme.) Rust'a dair öğrenecek epey şey var ve pek çok şey iyice kafanızı iyice bulandırabilir. Burada kastedilen &quot;yumuşaklık&quot;, zorluğuna karşın Rust'ın çözümlerinin uygulamalı olarak sunulmasıdır. Sorunları anlamak, hemen çözümleri görmekten çok daha faydalıdır. Bunu kayaçların süreçlerini anlamak için coğrafya dersinden sonra hemen dağ bayır gezintiye çıkmak gibi düşünebilirsiniz. Bunun elbette zorluğu olacak ama neticesi oldukça hoş olacak. Katılanlar oldukça memnun olacak ve birbirlerine yardımcı olmaktan çekinmeyecekler. (Buna benzer olarak) <a href="https://users.rust-lang.org/">Rust kullanıcıları forumu (İngilizce)</a> ve oldukça aktif bir <a href="https://www.reddit.com/r/rust/">subreddit (Bu da İngilizce)</a> var. Aynı zamanda bazı sorularınız varsa <a href="https://www.rust-lang.org/en-US/faq.html">sıkça sorular sorular (Herhâlde İngilizce)</a>'a da bakabilirsiniz.</p>
<p>Ama hepsinden önce, neden durup dururken yeni bir dil öğrenelim ki? Bu öyle ya da böyle epey vakit ve enerji alan, durup dururken yapılmayacak bir iş. Bu iş size çok süper, über bir iş buldurmayacak olsa bile beyin kaslarınızı çalıştıracak ve sizi daha iyi bir programcı yapacaktır. İyi bir yatırım mı? Tartışılır. Yine de <em>gerçek anlamda</em> bir şey öğrenmezseniz zaman içerisinde durgunlaşacak ve on yılı aşkın aynı şeylere bakan birisi olacaksınız. </p>
<h1 id="rustın-parladığı-nokta"><a class="header" href="#rustın-parladığı-nokta">Rust'ın Parladığı Nokta</a></h1>
<p>Rust statik ve güçlü tiplenen bir sistem programlama dilidir. <em>Statik</em> bütün tiplerin derleme zamanında bilinmesi anlamına gelir, <em>güçlü</em> ise programın çalışma mantığının tip mantığının dışına çıkmaması demektir. Başarılı bir derleme aynı zamanda C gibi tekinsiz bir dile göre çok daha fazla şeyi garanti ettiğiniz anlamına gelir. <em>Sistem (Programlama)</em>'dan kasıt makine için en uygun kodun sıkı bir bellek denetimi ile oluşturulmasıdır. Kullanım alanları biraz ilginç: işletim sistemleri, donanım sürücüleri ve bir işletim sistemi bile olmayan gömülü sistemler. Ancak Rust normal uygulamaları programlamak için de gayet uygundur. </p>
<p>C ve C++ ile Rust arasındaki en büyük fark <em>doğal olarak emniyetli olmasıdır.</em> Bütün bellek erişimleri denetlendiğinden kazara belleği darmaduman etmeniz mümkün değildir.</p>
<p>Rust'ın ana prensipleri şunlardır:</p>
<ul>
<li>Verinin <em>emniyetli olarak ödünç alınmasını</em> zorlamak</li>
<li>Fonksiyon, metot ve kapamalar (closure) ile veriye müdahale etmek</li>
<li>Verileri çokuzlu (tuple), yapılar (struct) ve numaralandırmalar (enum) ile bir araya toplamak</li>
<li>Verileri örüntü eşleştirme (pattern matching) ile seçmek ve parçalarına ayırmak</li>
<li>Verilerin <em>görevini</em> özellikler (trait) aracılığı ile tanımlamak </li>
</ul>
<p>Cargo sayesinde oldukça hızlı büyüyen bir ekosistem olsa da biz çoğunlukla dilin temel özelliklerini anlamaya ve standart kütüphaneyi kullanmaya eğileceğiz. Tavsiyem <em>çok sayıda ufak programlar</em> yazmanızdır, bundan dolayı <code>rustc</code> kullanmayı öğrenmek en önemli beceri olacaktır hâliyle. Bu rehberde bulacağınız pek çok örneği çalıştırmak için derlemeyi programı yürüten <code>rrun</code> diye minik bir betik hazırladım:</p>
<pre><code>rustc $1.rs &amp;&amp; ./$1
</code></pre>
<h1 id="kurulum"><a class="header" href="#kurulum">Kurulum</a></h1>
<p>Bu rehber makinenize Rust'ı kurmayı gerektirir. Neyse ki bunu yapmak <a href="https://www.rust-lang.org/en-US/downloads.html">çok basit</a>.</p>
<pre><code>$ curl https://sh.rustup.rs -sSf | sh
$ rustup component add rust-docs
</code></pre>
<p>Kararlı sürümü kullanmanızı tavsiye ediyorum; sonradan kararsız sürümü kurup aralarında geçiş yapmak da kolaydır.</p>
<p>Bu komut derleyiciyi Cargo paket yöneticisini, API belgelendirmesini ve Rust kitabını indirir. Uzun yolculukların hepsi bir adımla başlar ve bu adımı atmak zahmetsizdir.</p>
<p><code>rustup</code> komutu Rust kurulumunuzu kontrol eden komuttur. Yeni bir kararlı sürüm yayınlandığında yalnızca  <code>rustup</code> yazarak güncelleyebilirsiniz. <code>rustup doc</code> ise resmi Rust belgelerini çevrimdışı olarak tarayıcınızda açar.</p>
<p>Muhtemelen beğendiğiniz bir editor vardır ve bu editörün <a href="https://areweideyet.com/">temel Rust desteği</a> varsa o editörü istediğiniz gibi kullanabilirsiniz. Öncelikle sözdiziminin renklendirilmesi ile yetinmenizi öneririm, programlarınız büyüdükçe daha ötesine geçersiniz.</p>
<p>Şahsen varsayılan olarak Rust desteği ile gelen nadir editörlerden birisi olan <a href="https://www.geany.org/download/releases/">Geany'i</a> beğeniyorum; paket yöneticisiyle kurulabildiği için Linux üzerinde kullanmak gayet kolaydır, diğer platformlarda da pekâlâ kullanılabilir.</p>
<p>Esas nokta Rust programlarını düzenleyebilmek, derleyebilmek ve çalıştırabilmektir. Programlamayı <em>parmaklarınızla</em> anlayın, kodu kendiniz yazın ve editörün kodu nasıl düzelteceğini öğrenin.</p>
<p>Zed Shaw'ın programlamayı Python ile öğrenme <a href="https://learnpythonthehardway.org/book/intro.html">tavsiyesi</a> geçen yıllara rağmen dil fark etmeksizin dikkate değerdir. Ona göre programlamayı öğrenmenin bir müzik enstürmanı öğrenmek gibidir - esas sır pratik ve sabırdır. Taiciçüen gibi yumuşak dövüş sanatlarının ve Yoga'nın bir güzel öğüdü vardır; gerilimi hissedin, ama aşırı gerilmeyin. Karanlık bir spor salonunda sert bir disiplini sadakatle zayıflamaya çalışmıyorsunuz; rahatlayın.</p>
<p>Kötü İngilizcemi veya yetersiz Rust bilgimi yakalayarak beni uyaran destekçilere teşekkürler etmek isterim, aynı zamanda David Marino'ya Rust'ı parlayan zırhı içerisinde sempatik fakat mantığına sıkı sıkıya bağlı bir şovalye olarak çizdiği için de teşekkürlerimi sunarım.</p>
<p>Steve Donovan © 2017-2018 MIT Lisans Versiyonu 0.4.0</p>
<p>Çeviri: Emrecan Şuşter</p>
<h2 id="bazı-Çeviri-notları"><a class="header" href="#bazı-Çeviri-notları">Bazı Çeviri Notları</a></h2>
<p>Bu çeviriyi motamot çevirmek yerine, kaldı ki bunu makineler de yapabiliyor, içeriğinde de kültüre özgü değişiklikler yaptım. Maksat rehberin ana dilinde yazılmış gibi bir akıcılıkla okunabilmesi idi. Çoğu yerin birebir çevrilmediğini, bazı şeylerin eklendiğini de göreceksiniz. Bu İngilizce ile Türkçe arasındaki hem kültürel hem de anlamsal farklardan dolayıdır.</p>
<p>Epey yerleşmiş, Türkçesi de (göreceli olarak) oldukça anlamsız gelen bazı kavramları doğrudan İngilizce hâliyle metin içinde kullandım. (Heap ve Stack gibi) Ancak bunun dışında çoğu yerde Türkçe karşılıkları kullanmaya özen gösterdim ve yanların parantez içinde veya &quot;/&quot; işareti ile İngilizce karşılıklarını bildirdim. Terimler için <a href="https://github.com/RustDili/dokuman/tree/master/sozluk">&quot;Rust Dili&quot; projesinin sözlüğünden</a> faydalandım.</p>
<p>Bunun dışında kod parçalarına dokunmadım, içindeki yorumları bile olduğu gibi bıraktım zira bu kod parçaları değiştiği zaman çıkacak ekstra iş gücünden çekindim.</p>
<p>Çeviriyi geliştirmek için her zaman <a href="https://github.com/Tarbetu/gentle-intro">çevirinin Github deposuna</a> uğrayabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merhaba-dünya"><a class="header" href="#merhaba-dünya">Merhaba Dünya</a></h1>
<p>&quot;Merhaba Dünya&quot;'nın esas amacı, C'nin ilk versiyonu yazıldığından beri, derleyiciyi test etmek ve gerçek bir program çalıştırmaktır.</p>
<pre><pre class="playground"><code class="language-rust">// hello.rs
fn main() {
    println!(&quot;Hello, World!&quot;);
}</code></pre></pre>
<pre><code class="language-bash">$ rustc hello.rs
$ ./hello
Hello, World!
</code></pre>
<p>Rust'ta süslü ayraçlar ve noktalı virgül vardır, C++ tarzı yorum satırları bulunur ve bir de <code>main</code> fonksiyonu bulunur. Şimdiye kadar bu kısmı tanıyorsunuz. Ünlem işareti, bunun bir <em>makro</em> çağrısı olduğunu gösterir. C++ programcıları için bu biraz caydırıcı olabilir, çünkü onların tek bildiği makrolar o abuk subuk C makrolarıdır - ama bu makroların çok daha yetenekli ve kabul edilebilir olduğunu rahatlıkla söyleyebilirim.</p>
<p>&quot;Güzel de bu ünlem işaretini nereye sıkıştıracağımı nereden bileyim&quot; diye aklından geçirenler olmuştur. Ancak derleyici beklemediğiniz kadar yardımsever; eğer ünlem işaretini unutursanız şunu görürsünüz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0425]: unresolved name `println`
 --&gt; hello2.rs:2:5
  |
2 |     println(&quot;Hello, World!&quot;);
  |     ^^^^^^^ did you mean the macro `println!`?
<span class="boring">}</span></code></pre></pre>
<p>Bir dili öğrenmek o dilin hatalarıyla barışık olmak demektir. Derleyiciyi sizi <em>azarlayan</em> bir bilgisayar olarak görmek yerine katı ama dostane davranan bir yardımcı olarak görmeye çalışın, çünkü başlangıçta epeyce kırmızı yazılar göreceksiniz. Derleyicinin sizin hatalarınızı yüzünüze vurması, insanların sizin yüzünüze vurmasından kat kat daha iyidir.</p>
<p>Bir sonraki aşama <em>değişken</em> atamaktır.</p>
<pre><pre class="playground"><code class="language-rust">// let1.rs
fn main() {
    let answer = 42;
    println!(&quot;Hello {}&quot;, answer);
}</code></pre></pre>
<p>Yazım hataları <em>derleme</em> zamanında anlaşılır, Python ya da JavaScript gibi çalışma zamanını beklemenize gerek yoktur. Bu, sizi daha sonra pek çok stresten kurtaracak! Eğer &quot;answer&quot; yerine &quot;answr&quot; yazarsam, derleyici bu konuda epey kibar davranır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>4 |     println!(&quot;Hello {}&quot;, answr);
  |                         ^^^^^ did you mean `answer`?
<span class="boring">}</span></code></pre></pre>
<p><code>println!</code> makrosu bir <a href="https://doc.rust-lang.org/std/fmt/index.html">format karakter dizesi</a> alır; Python3'te kullanılan formatlama stiline epey benzerdir.</p>
<p>Bir başka kullanışlı makro ise <code>assert_eq!</code>. Bu Rust testlerinin direğidir, iki şeyin birbirine eşit olduğu <em>varsayarsınız. (assert = varsaymak)</em> Eğer eşit değillerse, <em>panik</em>.</p>
<pre><pre class="playground"><code class="language-rust">// let2.rs
fn main() {
    let answer = 42;
    assert_eq!(answer,42);
}</code></pre></pre>
<p>Herhangi bir çıktı olmayacaktır. Ancak 42'yi 40 ile değiştirirseniz:</p>
<pre><code class="language-shell">thread 'main' panicked at
'assertion failed: `(left == right)` (left: `42`, right: `40`)',
let2.rs:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Ve bu bizim Rust'taki karşımıza çıkan ilk <em>çalışma zamanı hatası</em>.</p>
<h1 id="döngüler-ve-koşullamalar"><a class="header" href="#döngüler-ve-koşullamalar">Döngüler ve Koşullamalar</a></h1>
<p>Enteresan olan her şey tekrar tekrar yapılabilir:</p>
<pre><pre class="playground"><code class="language-rust">// for1.rs
fn main() {
    for i in 0..5 {
        println!(&quot;Hello {}&quot;, i);
    }
}</code></pre></pre>
<p><em>Aralık (Range)</em> kapsayıcı değildir, bundan dolayı <code>i</code>'nin değeri 0 ila 4 arasında değişir.  Dizilerin indekslerinin sıfırdan başladığı bir dilde pek de olağandışı değildir.</p>
<p>Enteresan şeyler de <em>koşula bağlı olarak</em> da gerçekleştirilebilir.</p>
<pre><pre class="playground"><code class="language-rust">// for2.rs
fn main() {
    for i in 0..5 {
        if i % 2 == 0 {
            println!(&quot;even {}&quot;, i);
        } else {
            println!(&quot;odd {}&quot;, i);
        }
    }
}</code></pre></pre>
<pre><code>even 0
odd 1
even 2
odd 3
even 4
</code></pre>
<p><code>i % 2</code> eğer i, 2'ye tam olarak bölünebiliyorsa sıfır olur; Rust C-tarzı operatörler kullanır. Koşulların etrafında parantez yoktur, tıpkı Go'daki gibi, ama blokların etrafında süslü parantezlerin kullanımı <em>zorunludur.</em></p>
<p>Aynı şey, daha da ilginç bir yoldan yapılabilir:</p>
<pre><pre class="playground"><code class="language-rust">// for3.rs
fn main() {
    for i in 0..5 {
        let even_odd = if i % 2 == 0 {&quot;even&quot;} else {&quot;odd&quot;};
        println!(&quot;{} {}&quot;, even_odd, i);
    }
}</code></pre></pre>
<p>Klasik olarak, programlama dillerinde <em>deyimler (statement)</em> (<code>If</code> gibi) ve <em>ifadeler (expression)</em> (<code>1+i</code> gibi) bulunur. Rust'ta, her şeyin değeri olabilir ve bunlar bir ifade olabilir. C'nin o garabet &quot;ternary/üçlü operatörüne&quot; burada ihtiyacımız yok.</p>
<p>Aynı zamanda bloklarda noktalı virgül olmadığına da dikkat edin!</p>
<h1 id="Şeyleri-Şeylere-eklemek"><a class="header" href="#Şeyleri-Şeylere-eklemek">Şeyleri Şeylere Eklemek</a></h1>
<p>Bilgisayarlar aritmatik konusunda epey iyidir. 0'dan 4'e kadar bütün sayıları toplamayı deneyelim.</p>
<pre><pre class="playground"><code class="language-rust">// add1.rs
fn main() {
    let sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>Ama derlenirken hata verecektir:</p>
<pre><code class="language-shell">error[E0384]: re-assignment of immutable variable `sum`
 --&gt; add1.rs:5:9
3 |     let sum = 0;
  |         --- first assignment to `sum`
4 |     for i in 0..5 {
5 |         sum += i;
  |         ^^^^^^^^ re-assignment of immutable variable

</code></pre>
<p>&quot;Immutable&quot;? Değişemeyen değişen mi? <code>let</code> değişkenlerinin değeri sadece atanırken belirtilebilir. <code>mut</code> ismindeki sihirli sözlük (<em>nolur</em> bu değişkeni değişebilir yap) işi halledecektir:</p>
<pre><pre class="playground"><code class="language-rust">// add2.rs
fn main() {
    let mut sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}</code></pre></pre>
<p>Değişkenlerin varsayılan olarak yeniden yazılabilir olduğu dillerden geçerken bu biraz kafa karıştırıcı olabilir. Bir şeyi <em>değişken</em> yapan şey onun değerinin çalışma zamanında atanmasıdır, sabitlerin (constant) aksine. Bu kavramlar matematikte de kullanılır, mesela &quot;let n be the largest number in set S (N'i S kümesi içerisindeki en büyük değer yap)&quot; derken.</p>
<p>Değişkenlerin varsayılan olarak <em>salt okunur</em> olmasının ardında bir neden vardır. Büyük bir programda, değerlerin nerede atandığını bulmak oldukça güçleşebilir. Bundan dolayı Rust, değişimlerin bildirilmesini ister. Dilde zekice epey şey var ancak dil hiçbir şeyin örtük kalmamasına ayrıca özen gösteriyor.</p>
<p>Rust hem statik hem de güçlü tiplenen bir dildir - bu kavramlar genelde karıştırılır, ama C (statik ama zayıf tiplenen) ve Python'u (dinamik ama güçlü tiplenen) göz önüne getirin. Statik tiplemede tip derleme zamanında bilinir, dinamik tiplemede ise çalışma zamanında.</p>
<p>Tam da bu anda, Rust'ın sizden tipleri gizlediğini sezebilirsiniz. Mesela <code>i</code>'nin tam değeri nedir? Derleyici için bu sorun değildir, 0'dan başlarken, tip çıkarımı ile (<em>type referance</em>) bu sayılar <code>i32</code> (Dört bitlik işaretli tam sayı) oluverir.</p>
<p>Hadi net bir değişim yapalım, 0'ı 0.0 ile değiştirip hataları görelim:</p>
<pre><code class="language-shell">error[E0277]: the trait bound `{float}: std::ops::AddAssign&lt;{integer}&gt;` is not satisfied
 --&gt; add3.rs:5:9
  |
5 |         sum += i;
  |         ^^^^^^^^ the trait `std::ops::AddAssign&lt;{integer}&gt;` is not implemented for `{float}`
  |

</code></pre>
<p>Pekâlâ, şimdi güldük eğlendik ama bu da nesi? Bütün operatörler (Mesela <code>+=</code>) bir özelliğe (trait) denk gelir ki özellik (trait) somut tiplere yeni özellikler ekleyen soyut arabirimlerdir. Özelliklerle daha sonra ilgileneceğiz, ama burada bilmeniz gereken bütün şey <code>AddAssign</code>, <code>+=</code> operatörünü sağlayan özelliğin adı olduğudur ve hata mesajının demek istediği şey bu özelliğin noktalı sayılara bu operatör tam sayılarla işlem yapmak için uygulanmadığıdır. (Operatör özelliklerinin tam listesi <a href="https://doc.rust-lang.org/std/ops/index.html">burada</a>.)</p>
<p>Rust'ta her şey bellidir - sırf sizin gönlünüz olsun diye tam sayıyı noktalı sayıya gizlice çevirmeyecektir.</p>
<pre><pre class="playground"><code class="language-rust">// add3.rs
fn main() {
    let mut sum = 0.0;
    for i in 0..5 {
        sum += i as f64;
    }
    println!(&quot;sum is {}&quot;, sum);
}</code></pre></pre>
<h1 id="fonksiyonların-tipleri-de-apaçık-ortadadır"><a class="header" href="#fonksiyonların-tipleri-de-apaçık-ortadadır">Fonksiyonların Tipleri de Apaçık Ortadadır</a></h1>
<p>Fonksiyonlar da derleyicinin sizin için tipleri tahmin etmekle uğraşmayacağı yerlerden birisidir. Aslında bu üzerinde düşünülerek alınmış bir karardır çünkü Haskell gibi güçlü tip çıkarımlarına sahip dillerde tip isimleri nadiren yazılır. Aslında Haskell için tipleri açıkça yazmak iyi yaklaşımdır. Rust ise her zaman bunu mecbur tutar.</p>
<p>İşte tanımladığımız basit bir fonksiyon:</p>
<pre><pre class="playground"><code class="language-rust">// fun1.rs

fn sqr(x: f64) -&gt; f64 {
    return x * x;
}

fn main() {
    let res = sqr(2.0);
    println!(&quot;square is {}&quot;, res);
}</code></pre></pre>
<p>Rust biraz eski bir argüman bildirimi tarzı kullanmakta, tip isimden sonra gelir. Bu, Pascal gibi Algol'dan türemiş dillerde kullanılan tarzdır.</p>
<p>Hatırlatalım, tam sayı noktalı sayıya dönüşmez - eğer <code>2.0</code>'ı <code>2</code> ile değiştirirseniz nurtopu gibi bir hatanız olmuş olur:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>8 |     let res = sqr(2);
  |                   ^ expected f64, found integral variable
  |
<span class="boring">}</span></code></pre></pre>
<p>Rust'da fonksiyonlarda çok az <code>return</code> deyiminin kullanıldığının görürsünüz. Daha çok, şuna benzer ifadeler vardır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sqr(x: f64) -&gt; f64 {
    x * x
}
<span class="boring">}</span></code></pre></pre>
<p>Fonksiyonun gövdesi (<code>{ }</code> içi) tıpkı &quot;ifade olarak kullanılan if&quot;teki gibi son ifadenin değerini alır.</p>
<p>Noktalı virgülleri refleks olarak kazara ekleyebilirsiniz ve o zaman şöyle bir hata alırsınız:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  |
3 | fn sqr(x: f64) -&gt; f64 {
  |                       ^ expected f64, found ()
  |
  = note: expected type `f64`
  = note:    found type `()`
help: consider removing this semicolon:
 --&gt; fun2.rs:4:8
  |
4 |     x * x;
  |       ^

<span class="boring">}</span></code></pre></pre>
<p><code>()</code> tipi boş tiptir, yokluktur, <code>void</code>dir, &quot;nothing&quot;dir, tasavvuftaki fakrdır. Rust'ta her şeyin değeri vardır, ama bazen sadece yoktur. Derleyici bunun sıkça karşılaşılan bir durum olduğunu bilir, ve size aslında <em>yardım</em> eder. (C++ derleyicileriyle vakit harcamış zavallı ruhlar bunun ne kadar faydalı olduğunun farkındadır.)</p>
<p><code>Return</code> kullanılmayan ifadelere biraz daha örnek verelim: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// absolute value of a floating-point number
fn abs(x: f64) -&gt; f64 {
    if x &gt; 0.0 {
        x
    } else {
        -x
    }
}

// ensure the number always falls in the given range
fn clamp(x: f64, x1: f64, x2: f64) -&gt; f64 {
    if x &lt; x1 {
        x1
    } else if x &gt; x2 {
        x2
    } else {
        x
    }
<span class="boring">}</span></code></pre></pre>
<p><code>Return</code> kullanmak yanlış değil, ama kod onsuz daha temiz. Yine de, bir fonksiyondan <em>erken dönmek</em> için <code>return</code> kullanabilirsiniz. </p>
<p>Bazı işlemler zarif bir yoldan özyinelemeli olarak yazılabilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u64) -&gt; u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n-1)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Başta tuhaf görünebilir ve en iyisi kağıt kalemle örnekler üzerinde düşünmektir. Ancak, bir işlemi yapmanın en etkili yolu değildir.</p>
<p>Değerler aynı zamanda <em>referans</em> olarak da iletilebilir. <code>&amp;</code> ile yaratılmış bir referans <code>*</code> <em>dereferans</em> edilebilir. (Ç.N: De- olumsuzlaştırma öneki)</p>
<pre><pre class="playground"><code class="language-rust">fn by_ref(x: &amp;i32) -&gt; i32{
    *x + 1
}

fn main() {
    let i = 10;
    let res1 = by_ref(&amp;i);
    let res2 = by_ref(&amp;41);
    println!(&quot;{} {}&quot;, res1,res2);
}
// 11 42</code></pre></pre>
<p>Bir fonksiyonun argümanlarını değiştirebilmesini mi istiyorsunuz? <em>Değişebilir referans (Mutable referance)</em> kullanın:</p>
<pre><pre class="playground"><code class="language-rust">// fun4.rs

fn modifies(x: &amp;mut f64) {
    *x = 1.0;
}

fn main() {
    let mut res = 0.0;
    modifies(&amp;mut res);
    println!(&quot;res is {}&quot;, res);
}</code></pre></pre>
<p>Bu C++'dan çok C'ye benzedi. Açıkça referansı (<code>&amp;</code> ile) belirtmelisiniz ve aynı şekilde <code>*</code> ile deferans etmelisiniz. Sonra da <code>mut</code>'u ekleyin çünkü varsayılan değişebilir değiller. (Bana hep C++ referansları C'ye göre gözden kaçırılmaya daha müsaitmiş gibi gelir.)</p>
<p>Temel olarak, Rust burada biraz bizi <em>yoruyor</em> ve fonksiyonlardan değer döndürmeye zorluyor.  Neyse ki, Rust'ın &quot;işlem başarılı, bu da sonucu&quot; gibi güçlü ifadeleri olduğundan <code>&amp;mut</code>'u sıklıkla kullanmayız. Referans kullanmak, büyük bir nesnemiz olduğunda ve onu kopyalamak istemediğimizde dikkate değerdir. </p>
<p>&quot;Değişkenden sonra tip gelir&quot; tarzı <code>let</code> için de gayet uyuyor, bir değişkenin türünü belirtmek istersek eğer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bigint: i64 = 0;
<span class="boring">}</span></code></pre></pre>
<h1 id="yolumuzu-yordamımızı-bilmek"><a class="header" href="#yolumuzu-yordamımızı-bilmek">Yolumuzu Yordamımızı Bilmek</a></h1>
<p>Şimdi belgelendirmeye bakmanın tam zamanı. Belgeler makinenize yüklenmiş olmalı ve onu <code>rustup doc --std</code> komutu ile tarayıcınızda açabilir olmalısınız.</p>
<p>Arama kutucuğunun en üstte olduğuna dikkat edin, zira bu sizin en yakın dostunuz olacak; çalışmak için İnternet'e gerek duymaz.</p>
<p>Diyelim ki matematiksel fonksiyonların nerede olduğunu merak ediyorsunuz, &quot;cos&quot; diye aratmanız yeterli. Klavyede dokunduğunuz ilk iki tuş her iki noktalı sayı tipi için de var olduğunu gösterir. Aradığımız işlem, değerin kendisinde metot olarak tanımlıdır, mesela şöyle:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi: f64 = 3.1416;
let x = pi/2.0;
let cosine = x.cos();
<span class="boring">}</span></code></pre></pre>
<p>Sonuç sıfıra epey yakın çıkacaktır, belli ki tahmini değere değil gerçek PI sayısına ihtiyacımız var.</p>
<p>(Sahi, neden <code>f64</code> diye belirtmemize gerek var ki? Aslına bakarsanız o olmadan değerimiz <code>f32</code> veya <code>f64</code> olabilir ki bunlar epey farklı şeyler.)
(Ç.N: Noktalı sayı tutan)</p>
<p><code>Cos</code> için verilen örneğe bakalım, bunu çalışabilir bir programa çevirdik. (<code>assert!</code> de <code>assert_eq!</code>'in amcaoğlu oluyor, verilen ifade kesinlikle doğru olmalıdır.)</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0 * std::f64::consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}</code></pre></pre>
<p><code>std::f64::consts::PI</code> şu güzel ortamı iyice bozdu! <code>::</code> C++'daki anlamıyla aynı şeye denk geliyor, (Bazı dillerde yerine <code>.</code> kullanılır) - bu <em>tam yolu belirtilmiş bir isim</em>. Bu tam adı, <code>PI</code> için yaptığımız aramayı yaparken ikinci klavye tuşlamasında alıyoruz. </p>
<p>Şimdiye dek, bizim ufak Rust programımıza &quot;Merhaba Dünya&quot; tartışmalarında gündemi meşgul eden <code>import</code> ya da <code>include</code> gibi şeyleri eklemedik. Hadi, programımızı bir <code>use</code> deyimi ile şenlendirelim:</p>
<pre><pre class="playground"><code class="language-rust">use std::f64::consts;

fn main() {
    let x = 2.0 * consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}</code></pre></pre>
<p>Tamam da buna neden şimdiye dek ihtiyaç duymadık? Çünkü Rust <em>prelude</em> aracılığıyla, <code>use</code> deyimini kullanmaya gerek bırakmadan pek çok temel işlevi görünür kılar (ama siz kullanana kadar yüklemez).</p>
<h1 id="diziler-ve-dilimler"><a class="header" href="#diziler-ve-dilimler">Diziler ve Dilimler</a></h1>
<p>Bütün statik tiplenen dillerde <em>diziler (array)</em> bulunur, bu birden çok veriyi bellek içerisinde baştan sona kontrol eder. Diziler, sıfırdan itibaren <em>indekslenir</em>.</p>
<pre><pre class="playground"><code class="language-rust">// array1.rs
fn main() {
    let arr = [10, 20, 30, 40];
    let first = arr[0];
    println!(&quot;first {}&quot;, first);

    for i in 0..4 {
        println!(&quot;[{}] = {}&quot;, i,arr[i]);
    }
    println!(&quot;length {}&quot;, arr.len());
}</code></pre></pre>
<p>Ve çıktı:</p>
<pre><code>first 10
[0] = 10
[1] = 20
[2] = 30
[3] = 40
length 4
</code></pre>
<p>Burada Rust dizinin büyüklüğünü net olarak bilir ve eğer <code>arr[4]</code>'e erişmeye çalışırsanız derleme hatası alırsınız. </p>
<p>Yeni bir dil öğrenmek aynı zamanda diğer dillerden edindiğiniz alışkanlıkları da <em>terk etmek</em> demektir; eğer bir Pythonista iseniz bu köşeli parantezleri <code>List</code> diye isimlendirebilirsiniz. Rust'taki <code>List</code>'in muadiline daha sonra bakacağız, ancak diziler düşündüğünüz işi yapmıyor; <em>sabit</em> bir büyüklükleri vardır. (Eğer yalvarırsak) <em>değişebilir</em>ler ancak yeni değerler ekleyemeyiz.</p>
<p>Diziler Rust'ta o kadar çok kullanılmaz, çünkü her dizi tipi uzunluğunun bilgisini de taşır. Mesela <code>[i32; 4]</code> dizi tipine bakabilirsiniz; aynı zamanda <code>[10, 20]</code> olan bir dizinin tipi de <code>[i32; 2]</code> olacaktır vs, hepsinin farklı tipi vardır. Yani bunlar aslında fonksiyon argümanı olmaktan başka şeye yaramayan başıboş serserilerdir.</p>
<p>Esas sık kullanılan<em>lar</em> <em>dilimlerdir</em>. Bunları bir dizinin <em>parçalanmış hâli<sup class="footnote-reference"><a href="#slice">1</a></sup></em> olarak düşünebilirsiniz. Tıpkı dizilerin davrandığı gibi davranırlar ve <em>uzunluklarını bilirler</em>, C'deki <em>gösterici (pointer)</em> denen korkunç yaratıkların tam tersi olarak.</p>
<p>İki önemli noktaya dikkat edin - bir dilimin tipi nasıl yazıldığına ve fonksiyona ne zaman <code>&amp;</code> eklemeniz gerektiğine.</p>
<div class="footnote-definition" id="slice"><sup class="footnote-definition-label">1</sup>
<p>Ç.N: Esas çeviride &quot;parçalanmış hâl&quot; yerine &quot;görünüm (view)&quot; kelimesi kullanılıyor. İngilizce için cümle gayet geçerli, ancak Türkçe'de tuhaf duruyor.</p>
</div>
<pre><pre class="playground"><code class="language-rust">// array2.rs
// read as: slice of i32
fn sum(values: &amp;[i32]) -&gt; i32 {
    let mut res = 0;
    for i in 0..values.len() {
        res += values[i]
    }
    res
}

fn main() {
    let arr = [10,20,30,40];
    // look at that &amp;
    let res = sum(&amp;arr);
    println!(&quot;sum {}&quot;, res);
}</code></pre></pre>
<p><code>Sum</code>'da kodu bir saniyeliğine görmezden gelin ve <code>&amp;[i32]</code>'ye bakın. Rust dizileri ve dilimleri arasındaki ilişki C'deki diziler ve göstericiler arasındaki ilişkiye benzer, iki detay hariç - Rust dilimleri kendi uzunluğunun takibini yaparlar (ve eğer bu uzunluğun dışına çıkarlarsa paniklerler) sonra da <code>&amp;</code> 'ı operatörünü kullanarak dilim olarak kullanmak istediğinizi açıkça belirtmeniz gereklidir.</p>
<p>Bir C programcısı <code>&amp;</code>'ı gördüğü zaman &quot;falancanın adresi&quot; diye okur, Rust programcısı ise &quot;ödünç (borrow)&quot; olarak. Bu, Rust öğrenirken dikkat etmeniz gereken kilit sözcüktür. Ödünç alma, esasında programlamada kullanılan genel bir terimdir ve (Dinamik dillerde her zaman olduğu gibi) referans olarak bir veriyi ya da C'de bir gösterici (pointer) yollamanıza denir. Ödünç alınan her şey esas sahibinde kalır.</p>
<h1 id="dilimleme-ve-biçme"><a class="header" href="#dilimleme-ve-biçme">Dilimleme ve Biçme</a></h1>
<p>Bir diziyi <code>{}</code> yolu ile ekrana yazamazsınız fakat <em>hata ayıklama (debug)</em> yani <code>{:?}</code> ile ekrana yazdırabilirsiniz.</p>
<p>Bu: </p>
<pre><pre class="playground"><code class="language-rust">// array3.rs
fn main() {
    let ints = [1, 2, 3];
    let floats = [1.1, 2.1, 3.1];
    let strings = [&quot;hello&quot;, &quot;world&quot;];
    let ints_ints = [[1, 2], [10, 20]];
    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;floats {:?}&quot;, floats);
    println!(&quot;strings {:?}&quot;, strings);
    println!(&quot;ints_ints {:?}&quot;, ints_ints);
}</code></pre></pre>
<p>Bunu yazdırır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ints [1, 2, 3]
floats [1.1, 2.1, 3.1]
strings [&quot;hello&quot;, &quot;world&quot;]
ints_ints [[1, 2], [10, 20]]
<span class="boring">}</span></code></pre></pre>
<p>Bu arada, dizilerin dizileri de olabilir ancak dizide sadece bir tipten değerler bulunmalıdır. Dizideki değerler verimlilikten dolayı bellekte yanyana bulunurlar ki bu erişim için oldukça faydalıdır.</p>
<p>Eğer bir değişkenin gerçek tipini merak ediyorsanız, size bir hile gösterebilirim. Bir değişkeni, geçersiz olduğunu bildiğiniz bir tiple bildirin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let var: () = [1.1, 1.2];
<span class="boring">}</span></code></pre></pre>
<p>İşte aradığınız şeyi gösteren hata:</p>
<pre><code>3 |     let var: () = [1.1, 1.2];
  |                   ^^^^^^^^^^ expected (), found array of 2 elements
  |
  = note: expected type `()`
  = note:    found type `[{float}; 2]`
</code></pre>
<p>(<code>{float}</code>, &quot;bir nevi noktalı sayı ama tam tipi henüz belirtilmedi.&quot; demektir.)</p>
<p>Dilimler size aynı dizinin farklı <em>parçalarını</em> sunar:</p>
<pre><pre class="playground"><code class="language-rust">// slice1.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice1 = &amp;ints[0..2];
    let slice2 = &amp;ints[1..];  // open range!

    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;slice1 {:?}&quot;, slice1);
    println!(&quot;slice2 {:?}&quot;, slice2);
}</code></pre></pre>
<p>Bu, Python'daki dilim anlayışına epey yakındır ancak arada büyük bir fark vardır: Veri asla kopyalanmadı. Bu dilimler, bütün verilerini dizilerden <em>ödünç</em> alırlar. Dilimlerin dizilerle epey sıkı bir bağ vardır ve Rust bu bağın kopmaması için elinden gelen her şeyi kuvvetle yapar.</p>
<h1 id="opsiyonel-değerler-optional-values"><a class="header" href="#opsiyonel-değerler-optional-values">Opsiyonel Değerler (Optional Values)</a></h1>
<p>Dilimler, diziler gibi, indekslenebilir. Rust, derleme zamanında dizinin değerini bilir, ama bir dilimin değeri ancak çalışma zamanında bilinebilir. Bundan dolayı, <code>s[i]</code> kullanımı belleğin yanlış bir yerine erişmeye sebep olabilir ve bu durumda program <em>panikleyecektir.</em> Bu gerçekten de olmasını istediğiniz şey değildir - aradaki fark Florida'dan atılacak çok pahalı bir uydunun gökyüzünde parçalanması ile atışın güvenlice iptal edilmesine kadar varabilir. Ve burada <em>hata yakalama mekanizmaları (exceptions)</em> yok.</p>
<p>Şimdi hazır olun zira gelecek şey sizi şok edecek. Burada panikleyebilecek kodları try-bloğu ve hatayı yakala (try - catch) yapısı yok - en azından her gün kullandığınız şekliyle yok. Peki, Rust nasıl güvenli kalabiliyor?</p>
<p>İşte size bir paniklemeyen <code>get</code> metotu. İyi de, bu ne dönüyor?</p>
<pre><pre class="playground"><code class="language-rust">// slice2.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;
    let first = slice.get(0);
    let last = slice.get(5);

    println!(&quot;first {:?}&quot;, first);
    println!(&quot;last {:?}&quot;, last);
}
// first Some(1)
// last None</code></pre></pre>
<p><code>last</code> çuvalladı. (Sıfır temelli indekslemeyi unuttuk.) Ama <code>None</code> diye bir şey döndü. <code>first</code> için sorun yok, ama <code>Some</code> diye bir şey dönüverdi. <code>Option</code> tipini selamlayın! Bu tip <code>Some</code> <em>olabilir</em>, <code>None</code> <em>olabilir</em>.</p>
<p><code>Option</code> tipinin gayet faydalı metotları vardır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;first {} {}&quot;, first.is_some(), first.is_none());
    println!(&quot;last {} {}&quot;, last.is_some(), last.is_none());
    println!(&quot;first value {}&quot;, first.unwrap());

// first true false
// last false true
// first value 1
<span class="boring">}</span></code></pre></pre>
<p>Eğer <code>last</code> üzerinde <em>unwrap</em> kullanırsanız nurtopu gibi bir paniğiniz olur. Bunun yerine en azından <code>is_some</code> kullanabilirsiniz - varsayılan bir değeriniz varsa gayet faydalıdır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let maybe_last = slice.get(5);
    let last = if maybe_last.is_some() {
        *maybe_last.unwrap()
    } else {
        -1
    };
<span class="boring">}</span></code></pre></pre>
<p><code>*</code> operatörünün kullanıldığına dikkat edin - <code>Some</code> içindeki esas tip bir referans olan <code>&amp;i32</code>'dir. <code>i32</code> verisini almak için veriyi deferans ediyoruz.</p>
<p>Bu biraz işi uzatıyor, onun yerine bir kısayol kullanabiliriz - <code>unwrap_or</code> metodu <code>Option</code> <code>None</code> ise yerine bir değer atayabilir. Tipler muhakkak uyuşmalı -<code>get</code> referans dönecek. Bundan ötürü bir <code>&amp;i32</code> olan <code>&amp;-1</code>'ı kullanmamız gereklidir. Şimdi tekrar  <code>*</code> operatörünü <code>i32</code> değeri almak için kullanalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let last = *slice.get(5).unwrap_or(&amp;-1);
<span class="boring">}</span></code></pre></pre>
<p><code>&amp;</code>'ı unutmak gayet olası ama derleyici arkanızı toplayacaktır. <code>-1</code> yazsaydık, <code>rustc</code> şuna benzer bir hata verecekti: &quot;&amp;{integer} bekleniyordu ancak tam sayı alındı&quot; ve eklerdi ki: &quot;yardım: <code>&amp;-1</code>'ı deneyin&quot; *</p>
<p>* &quot;expected &amp;{integer}, found integral variable&quot;, &quot;help: try with <code>&amp;-1</code>&quot;</p>
<p><code>Option</code> tipini veri taşıyan bir paket olarak zihninizde canlandırabilirsiniz, ya da hiçbir şey ifade etmeyen bir değer (<code>None</code>). (Haskell'deki karşılığı <code>Maybe</code>dir.) Bu tip tipi belirtilebilen herhangi bir veriyi barındırabilir. Bizim örneğimizde üzerinde çalıştığımız tip <code>Option&lt;&amp;i32&gt;</code>'dir, C++'ın &quot;Genellemeler (generics)&quot; yazılımı ile gösterirsek. Paketi açmak bir patlamaya sebep olabilir ancak bu mevzu Schrödinger'in kedisi kadar karmaşık değil ve önceden paketin içinde ne var bilebiliriz.</p>
<p>Rust fonksiyonlarının ve metotların bu tür paketleri döndürmesi gayet olağandır ve üzerinde uzmanlaşana kadar nasıl kullanıldığını öğrenin.</p>
<h1 id="vektörler"><a class="header" href="#vektörler">Vektörler</a></h1>
<p>Ç.N: Doğrusunu isterseniz ilk gördüğümde bu vektörleri geometrideki vektörlerle ilişkili zannetmiştim. Yüzde yüz programlama deyimi, aklınıza farklı şeyler gelmesin. :)</p>
<p>Tekrar dilim metotlarına döneceğiz ancak vektörleri gözden geçirelim. Bunlar <em>yeniden biçimlendirilebilen</em> dizilerdir ve Python'un <code>List</code>ine ve C++'ın <code>std::vector</code>'üne epey benzerler. Rust'ın <code>Vec</code> tipi (&quot;vektör&quot; olarak okunur.) dilimlere çok benzerler; esas farklılıkları ise vektöre yeni bir veri ekleyebiliyor olmanız - <em>değişebilir (mutable)</em> olarak değişkenin bildirilmesi kaydı ile.</p>
<pre><pre class="playground"><code class="language-rust">// vec1.rs
fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    let first = v[0];  // will panic if out-of-range
    let maybe_first = v.get(0);

    println!(&quot;v is {:?}&quot;, v);
    println!(&quot;first is {}&quot;, first);
    println!(&quot;maybe_first is {:?}&quot;, maybe_first);
}
// v is [10, 20, 30]
// first is 10
// maybe_first is Some(10)</code></pre></pre>
<p>Yeni başlayanların başına sıklıkla gelen şey <code>mut</code> eklemeyi unutmalarıdır; bunu yaparsanız dostça uyarılırsınız.</p>
<pre><code>3 |     let v = Vec::new();
  |         - use `mut v` here to make mutable
4 |     v.push(10);
  |     ^ cannot borrow mutably
</code></pre>
<p>Vektörler ve dilimler arasında çok yakın bir bağ vardır.</p>
<pre><pre class="playground"><code class="language-rust">// vec2.rs
fn dump(arr: &amp;[i32]) {
    println!(&quot;arr is {:?}&quot;, arr);
}

fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    dump(&amp;v);

    let slice = &amp;v[1..];
    println!(&quot;slice is {:?}&quot;, slice);
}</code></pre></pre>
<p>Ufak ama önemli ödünç alma operatörümüz <code>&amp;</code>, vektörü dilime çevirmeye <em>zorluyor. (coercing)</em>. Ve bu pek mantıksız değil çünkü vektörler bellekte <em>dinamik</em> bir yer tutarlar ve dizi gibi çalışırlar.</p>
<p>Eğer dinamik tipli bir dilden geliyorsanız, sizinle bazı şeyleri konuşmanın vakti geldi. Sistem programlama dillerinde iki farklı bellek yönetim tarzı vardır:  Yığıt (Stack) ve Öbek (Heap).<sup class="footnote-reference"><a href="#heapstack">2</a></sup> Stack bellek üzerinde oldukça hızlı bir şekilde alan tahsis ederler ancak yapıları ancak bir kaç megabaytla çıkabilecek kadar sınırlıdır. Heap ise gigabaytlara kadar çıkabilir ancak alan tahsis etme süreci biraz meşakkatlidir ve bu bellek alanının sonradan temizlemesi gereklidir. Bazı sözüm ona &quot;yönetilen (managed)&quot; dillerde (Bunlar Java olur, Go olur, bazı sözde betik dilleri olur) bu tarz detaylar sizden gizlenir ve belediyemizin <em>çöp toplayıcıları (garbage collector)</em> tarafından bu pis işler halledilir. Sistem, bir verinin başka bir veriye referans gösterilmediğine emin olunca kullanılabilir bellek alanına geri döner.</p>
<div class="footnote-definition" id="heapstack"><sup class="footnote-definition-label">2</sup>
<p>Yığıt ve Öbek, benim çeviri standartlarıma göre bile aşırı yapay kalıyor. Bundan ötürü kafa karışıklığını ortadan kaldırmak için Heap ve Stack kelimelerinden devam ettim. </p>
</div>
<p>İşin özü bu durumun faydaları olsa da bazı sorunları da vardır. Stack ile oynamanın bazı tehlikeleri var ve içinde bulunduğunuz fonksiyonun dönüş adresini bozabilirsiniz, sonra da iğrenç bir şekilde can verirsiniz. Ya da daha da kötüsü, Hacker Okan'ın elini öpmek zorunda kalabilirsiniz.</p>
<p>İlk C programım (DOS'ta yazmıştım) tüm bilgisayarı çökertmişti. Unix sistemleri bu tarz şeylere karşı daha iyi tavır alırdı ve <em>segfault</em> mekanizması ile kontrolden çıkan süreçler &quot;öldürülür&quot;. Peki, bu neden Rust'ın (ya da Go'nun) paniklemesinden daha kötüdür? Çünkü panik sorunun olduğu yerde meydana gelir, bütün program birbirine girdiğinde ve ev ödevlerine dadandığında değil. Panikler <em>bellek için emniyetlidir (memory safe)</em> çünkü belleğin canına okunmadan hemen önce gerçekleşirler. Bu, C'deki güvenlik sorunlarının yaygın bir nedenidir çünkü bütün bellek erişimleri emniyetsizdir ve işi bilen bir saldırgan bu güvensizlikten faydalanabilir.</p>
<p>Panikler kulağınıza korkunç ve plansız gelebilir ama Rust'ın panikleri bile yapılandırılmıştır - stack tek tek serbest bırakılır. Bellekte tahsis edilmiş alanı olan bütün veriler boşatılır ve geriye dönük bir rapor oluşturulur.</p>
<p>Peki çöp toplayıcıların (garbage collector) dezavantajları nedir? Birincisi belleği çok hoyratça kullanıyorlar, sizin için önemli olmayabilir ama gömülü mikroçiplerde bu çok fena bir sorun oluşturur. İkincisi, en olur olmaz zamanlarda belleği temizlemeye başlamasıdır. (Odanızda uzanmış telefonda sevgilinizle hassas bir konuşma yaparken birden odanızı temizlemeye kalkışan annenizi düşünün.) Gömülü sistemlerin olaylara <em>gerçekleştiği anda</em> yanıt vermesi gerekir ve planlanmamış bir temizliğe hiç tahammütleri yoktur. Roberto Lerusalimsch, Lua gibi çok zarif bir dinamik dilin baş tasarımcısı, çöp toplayıcılı bir yazılımın kullanıldığı uçakta asla uçmak isteyemeyeceğini söylemiştir.</p>
<p>Vektörlere geri dönelim, bir vektör yaratıldığı ya da düzenlendiğinde heap içerisinden alan tahsis eder ve bu tahsis edilen alanın sahibi olur. Vektör öldüğünde ya da bellekten temizlendiğinde, bellek de serbest bırakılır.</p>
<h1 id="döngüleyiciler-iterators"><a class="header" href="#döngüleyiciler-iterators">Döngüleyiciler (Iterators)</a></h1>
<p>Rust bilinmezinin en temel noktasından henüz bahsetmedik - döngüleyiciler. Bir aralık (range) üzerinde kullanılan for döngüsü bir döngüleyici (iterator) kullanır. (<code>0..n</code> Python3'teki <code>range</code> fonksiyonuna benzer.)</p>
<p>Bir döngüleyiciyi fark etmek oldukça kolaydır. <code>Option</code> değerini bize dönen <code>next</code> metotuna sahip bir &quot;objeye&quot; döngüleyici deriz. <code>None</code> dönene kadar, <code>next</code> kullanabiliriz.</p>
<pre><pre class="playground"><code class="language-rust">// iter1.rs
fn main() {
    let mut iter = 0..3;
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
}</code></pre></pre>
<p><code>for var in iter {}</code> 'in yaptığı da tam olarak budur.</p>
<p>Bu size for döngüsü tanımlamanın faydasız bir yolu gibi görünebilir ancak <code>rustc</code>'nin yapacağı akıl almaz optimizasyonların sonucunda While döngüsü kadar hızlı çalışacaktır.</p>
<p>Bir dizi üzerinde döngü kurmayı deneyelim:</p>
<pre><pre class="playground"><code class="language-rust">// iter2.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr {
        println!(&quot;{}&quot;, i);
    }
}</code></pre></pre>
<p>Elbette ki hata dönecek. Ama çıktıya bakınca:</p>
<pre><code>4 |     for i in arr {
  |     ^ the trait `std::iter::Iterator` is not implemented for `[{integer}; 3]`
  |
  = note: `[{integer}; 3]` is not an iterator; maybe try calling
   `.iter()` or a similar method
  = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p><code>Rustc</code>'nin tavsiyesiyle programımız bir kez daha çalıştı:</p>
<pre><pre class="playground"><code class="language-rust">`// iter3.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr.iter() {
        println!(&quot;{}&quot;, i);
    }

    // slices will be converted implicitly to iterators...
    let slice = &amp;arr;
    for i in slice {
        println!(&quot;{}&quot;, i);
    }
}</code></pre></pre>
<p>Aslında, dizi üzerinde <code>for i in 0..slice.len() {}</code> gibi bir kullanımdansa bu yöntem çok daha verimlidir çünkü Rust'ı obsesifçe her indeks operasyonunda bir ton şeyi kontrol etmeye yönlendirmemiş oluyoruz.</p>
<p>Bir de bir aralığın hepsini hızlıca toplamanın bir başka örneğine bakalım. Daha önce bir döngü ve <code>mut</code> değişkenini kullanıyordum. Burada ise toplamanın &quot;<em>idiomatic</em>&quot; ve profesyonelce bir yolu var:</p>
<pre><pre class="playground"><code class="language-rust">// sum1.rs
fn main() {
    let sum: i32  = (0..5).sum();
    println!(&quot;sum was {}&quot;, sum);

    let sum: i64 = [10, 20, 30].iter().sum();
    println!(&quot;sum was {}&quot;, sum);
}</code></pre></pre>
<p>Rust'ta tiplerin önceden bildirilmiş olması gereken durumlardan birisi olduğuna dikkat edin, aksi taktirde Rust tam olarak ne yapması gerektiğini bilemeyecektir. Burada farklı tam sayı tipleriyle çalışmaktayız ki bu sorun teşkil etmez. (Aynı zamanda, isim sıkıntısı çektiğiniz zamanlarda aynı ismi tekrar kullanmanız da sorun teşkil etmez.)</p>
<p>Bu bilgiyle birlikte, <a href="https://doc.rust-lang.org/std/primitive.slice.html">dilim metotları</a> gözünüze biraz daha anlamlı gelecektir. (Belgelendirme hakkında bir bilgi; her belgenin sağ tarafında '[-]' işareti bulunur ve bu butona tıklayınca metot listesini kapatabilirsiniz. İlginizi çeken şeylerin detaylarını da genişletebilirsiniz. Şimdilik biraz tuhaf görünüyor, görmezden geliverin.)</p>
<p><code>windows</code> metotu size dilimlerin döngüleyicisini verir - birbiriyle örtüşen pencereler olarak değerler (Ç.N: Burada ne demek istediği benim için bile bir bilinmez.)</p>
<pre><pre class="playground"><code class="language-rust">
// slice4.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;

    for s in slice.windows(2) {
        println!(&quot;window {:?}&quot;, s);
    }
}
// window [1, 2]
// window [2, 3]
// window [3, 4]
// window [4, 5]</code></pre></pre>
<p><code>Chunks</code> da benzer işlevi yapabilir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> for s in slice.chunks(2) {
        println!(&quot;chunks {:?}&quot;, s);
    }
// chunks [1, 2]
// chunks [3, 4]
// chunks [5]
<span class="boring">}</span></code></pre></pre>
<h1 id="vektörler-Üzerine-biraz-daha-konuşalım"><a class="header" href="#vektörler-Üzerine-biraz-daha-konuşalım">Vektörler Üzerine Biraz Daha Konuşalım</a></h1>
<p>Bir vektör kurmak için <code>vec!</code> isminde oldukça kullanışlı bir makromuz var. Bununla birlikte vektörün sonundaki verileri <code>pop</code> ile <em>silebiliriz</em> ve vektörü bir başka vektörle <em>genişletebiliriz (extend).</em></p>
<pre><pre class="playground"><code class="language-rust">// vec3.rs
fn main() {
    let mut v1 = vec![10, 20, 30, 40];
    v1.pop();

    let mut v2 = Vec::new();
    v2.push(10);
    v2.push(20);
    v2.push(30);

    assert_eq!(v1, v2);

    v2.extend(0..2);
    assert_eq!(v2, &amp;[10, 20, 30, 0, 1]);
}</code></pre></pre>
<p>Vektörler birbirleriyle kıyaslanacağı zaman dilim olarak karşılaştırılır.</p>
<p>Vektörün belirli noktalarına <code>insert</code> kullanarak verileri yerleştirebilirsiniz, <code>remove</code> ile de silebilirsiniz. Bu vektörün sonuna veri eklemekten (<em>push</em>) ya da veri çıkartmaktan (<em>pop</em>) daha verimsizdir çünkü veriler yeni yer yaratmak için taşınır, büyük boyutlu vektörlerle çalışırken bu duruma dikkat etmeniz gerekir.</p>
<p>Vektörlerin bir büyüklüğü ve <em>kapasitesi</em> vardır. Eğer bir vektörü <code>clear</code> ile temizlerseniz, büyüklüğü sıfır olur ama eski kapasitesini korur. Bu durumda <code>push</code> vs ile yeni veriler eklerken yeniden bellek alanı tahsis edilmesi yalnızca eski kapasitenin aşımıyla gerekli olur.</p>
<p>Vektörler sıralanabilir ve içinde tekrarlayan veriler temizlenebilir - bu işlemler vektörü değiştirir. (Eğer önce vektörü kopyalamak isterseniz, <code>clone</code> kullanın.)</p>
<pre><pre class="playground"><code class="language-rust">// vec4.rs
fn main() {
    let mut v1 = vec![1, 10, 5, 1, 2, 11, 2, 40];
    v1.sort();
    v1.dedup();
    assert_eq!(v1, &amp;[1, 2, 5, 10, 11, 40]);
}</code></pre></pre>
<h1 id="karakter-dizileri-string"><a class="header" href="#karakter-dizileri-string">Karakter Dizileri (String)</a></h1>
<p>Rust'taki karakter dizileri diğer dillerden biraz daha gelişkindir. <code>String</code> tipi, <code>Vec</code> gibi, belleği dinamik olarak tahsis eder ve yeniden boyutlandırılabilir. (C++'ın <code>std::string</code> tipine çok benzer ancak Java'nın ve Python'nun değişemez karakter dizileri gibi değildir.) Ancak bir program, pek çok <code>string</code> kalıbı <em>(string literal)</em> de barındırabilir (&quot;merhaba&quot; gibi) ve bir sistem programlama dili bunları çıktı dosyasının içinde barındırabilmelidir. Gömülü mikroçiplerde bunun anlamı, bunları pahalı RAM yerine ucuz ROM'a yerleştirmektir. (Düşük seviyeli cihazlar için, RAM'ın pahalılığı aynı zamanda enerji üretimi pahalılığıdır.) Bir sistem programlama dilinde iki tür karakter dizisi bulunmalıdır, statik ya da bellekte yeri tahsis edilmiş.</p>
<p>Yani &quot;merhaba&quot; bir <code>String</code> değildir. Onun tipi <code>&amp;str</code>'dir. (&quot;Karakter dizisi dilimi <em>String Slice</em> olarak okunur.&quot;) Bu ayrım, C++'daki <code>const char*</code> ve <code>std::string</code> arasındaki fark gibidir ancak <code>&amp;str</code> biraz daha kullanışlıdır. Doğrusu, <code>&amp;str</code> ve <code>String</code> ilişki <code>&amp;[T]</code> ile <code>Vec&lt;T&gt;</code> arasındaki ilişkiye çok benzer.</p>
<pre><pre class="playground"><code class="language-rust">// string1.rs
fn dump(s: &amp;str) {
    println!(&quot;str '{}'&quot;, s);
}

fn main() {
    let text = &quot;hello dolly&quot;;  // the string slice
    let s = text.to_string();  // it's now an allocated string

    dump(text);
    dump(&amp;s);
}</code></pre></pre>
<p>Tekrar edelim, ödünç alma operatörü tıpkı <code>Vec&lt;T&gt;</code>'yi <code>&amp;[T]</code>'ye çevirmesi gibi <code>String</code>'i de <code>&amp;str</code>'ye çevirir.</p>
<p>Aslında içten içe, <code>String</code> aslında bir <code>Vec&lt;u8&gt;</code>'dir ve <code>&amp;str</code> de bir <code>&amp;[u8]</code>'dir, ancak bu baytlar UTF-8'e <em>kesinlikle</em> uygun olmalıdır.</p>
<p>Vektör gibi, bir karakteri <code>push</code>layabilirsiniz veyahut sonundaki karakteri <code>pop</code>layabilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust">// string5.rs
fn main() {
    let mut s = String::new();
    // initially empty!
    s.push('H');
    s.push_str(&quot;ello&quot;);
    s.push(' ');
    s += &quot;World!&quot;; // short for `push_str`
    // remove the last char
    s.pop();

    assert_eq!(s, &quot;Hello World&quot;);
}</code></pre></pre>
<p>Pek çok tipi String'e <code>to_string</code> diyerek çevirebilirsiniz. (Eğer onları &quot;{}&quot; ile ekranda gösterebiliyorsanız, çevrilebilirler.) <code>format!</code> makrosu da tıpkı <code>println!</code> gibi karmaşık karakter dizileri üretmek için kullanılabilir.</p>
<pre><pre class="playground"><code class="language-rust">// string6.rs
fn array_to_str(arr: &amp;[i32]) -&gt; String {
    let mut res = '['.to_string();
    for v in arr {
        res += &amp;v.to_string();
        res.push(',');
    }
    res.pop();
    res.push(']');
    res
}

fn main() {
    let arr = array_to_str(&amp;[10, 20, 30]);
    let res = format!(&quot;hello {}&quot;, arr);

    assert_eq!(res, &quot;hello [10,20,30]&quot;);
}</code></pre></pre>
<p><code>v.to_string()</code>'in önündeki <code>&amp;</code> operatörüne dikkat edin - operatör bir karakter dizesi dilimi üzerinde tanımlanmış, <code>String</code>'in kendisine değil, uyuşması için bazı detaylar eklememiz gerekiyor.</p>
<p>Dilimlerde kullanılan ifade şekli karakter dizilerinde de gösterilebilir:</p>
<pre><pre class="playground"><code class="language-rust">// string2.rs
fn main() {
    let text = &quot;static&quot;;
    let string = &quot;dynamic&quot;.to_string();

    let text_s = &amp;text[1..];
    let string_s = &amp;string[2..4];

    println!(&quot;slices {:?} {:?}&quot;, text_s, string_s);
}
// slices &quot;tatic&quot; &quot;na&quot;</code></pre></pre>
<p>Ancak karakter dizilerini indeksleyemezsiniz. Çünkü onlar tek ve gerçek kodlama olan UTF-8'i kullanırlar ki bu kodlamada bazı &quot;karakterler&quot; sadece baytların sayısı olabilir.</p>
<pre><pre class="playground"><code class="language-rust">// string3.rs
fn main() {
    let multilingual = &quot;Hi! ¡Hola! привет!&quot;;
    for ch in multilingual.chars() {
        print!(&quot;'{}' &quot;, ch);
    }
    println!(&quot;&quot;);
    println!(&quot;len {}&quot;, multilingual.len());
    println!(&quot;count {}&quot;, multilingual.chars().count());

    let maybe = multilingual.find('п');
    if maybe.is_some() {
        let hi = &amp;multilingual[maybe.unwrap()..];
        println!(&quot;Russian hi {}&quot;, hi);
    }
}
// 'H' 'i' '!' ' ' '¡' 'H' 'o' 'l' 'a' '!' ' ' 'п' 'р' 'и' 'в' 'е' 'т' '!'
// len 25
// count 18
// Russian hi привет!</code></pre></pre>
<p>Şimdi şuna bakalım - 25 baytımız var ama sadece 18 kataktere sahibiz! Fakat, eğer <code>find</code> gibi bir metot kullanırsak (bulunması hâlinde) geçerli bir indeks elde alırsınız ve herhangi bir dilimleme doğru çalışacaktır. </p>
<p>(Rust'ın <code>char</code> tipi 4-baytlık Unicode karakteridir. Karakter dizileri ise <code>char</code>ların dizisi değildir!)</p>
<p>Karakter dizelerini dilimlemek vektör dilimlemek gibi riskli bir iştir, çünkü bayt &quot;aralıkları&quot; kullanılır. Alttaki koşulda karakter dizesi iki bayttan oluşur, bunun ilk baytını almaya çalışmak bir Unicode hatasıdır. Bundan dolayı karakter dizisi metotlarından gelen uygun aralıkları kullanmaya dikkat edin.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = &quot;¡&quot;;
    println!(&quot;{}&quot;, &amp;s[0..1]); &lt;-- bad, first byte of a multibyte character
<span class="boring">}</span></code></pre></pre>
<p>Karakter dizilerini parçalamak popüler ve faydalı bir meşgaledir.  <code>split_whitespace</code> metotu bir döngüleyici döner ve bunun ne yapacağımızı biz belirleriz. Genelde bir karakter dizisini daha ufak karakter dizilerinin vektörünü kurmak için buna ihtiyaç duyarız.</p>
<p><code>collect</code> ise çok geneldir ve <em>neyi</em> topladığımız (collect) hakkında bir ipucu ister - bundan dolayı açıkça tip belirtilir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let text = &quot;the red fox and the lazy dog&quot;;
    let words: Vec&lt;&amp;str&gt; = text.split_whitespace().collect();
    // [&quot;the&quot;, &quot;red&quot;, &quot;fox&quot;, &quot;and&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog&quot;]
<span class="boring">}</span></code></pre></pre>
<p>Döngüleyicilerin <code>extend</code> metotuyla da aynı işi yapabilirdiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut words = Vec::new();
    words.extend(text.split_whitespace());
<span class="boring">}</span></code></pre></pre>
<p>Pek çok dilde bunları yapmak için <em>bellekte ayrıca alanı tahsis edilmiş karakter dizilerine</em> ihtiyacımız olurdu, oysa burada sadece bir ödünç alma olayı var. Tek tahsis edilen alan, dilimleri bellekte tutacak alandır.</p>
<p>Şu şirin çift-satıra bir bakınız; karakterler üzerine bir döngüleyici kuruyoruz ve boşluk olmayan karakterleri alıyoruz. Hatırlatalım, <code>collect</code> ipucu ister. (Ve biz de karakterler vektörü istemiş olabiliriz)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let stripped: String = text.chars()
        .filter(|ch| ! ch.is_whitespace()).collect();
    // theredfoxandthelazydog
<span class="boring">}</span></code></pre></pre>
<p><code>filter</code> metotu ise argüman olarak <em>kapama (closure)</em> alır, kapama dediğimiz de Rust'ın dilinde lambdalara veya anonim fonksiyonlara verdiğimiz isim. Argüman, işlevsel olarak çalışmayı bozmadığı için apaçık tip belirtme kuralını genişletebiliyoruz.</p>
<p>Tabii bunca şeyi apaçık bir döngü ile değişebilir bir vektöre karakter dizilerini iterek de yapabilirsiniz, ama şimdi yaptığımız daha kısa, daha okunaklı (<em>alışınca</em> tabii) ve denk bir hızda. Bir döngü kullanmak elbet ayıp değildir ama bu şekilde yazmanızı şiddetle tavsiye ederim.</p>
<h1 id="reklam-arası-komut-satırından-argümanları-almak"><a class="header" href="#reklam-arası-komut-satırından-argümanları-almak">Reklam Arası: Komut Satırından Argümanları Almak</a></h1>
<p>Şimdiye kadar programlarımız neyin ne olduğundan habersiz bir şekilde kendi kendilerine yaşayıp gittiler. Artık onları gerçek dünya ile tanıştırmalıyız.</p>
<p><code>std::env::args</code> ile komut satırındaki argümanlara ulaşabilirsiniz; size bütün argümanları, programın ismi de dahil olmak üzere, birer karakter dizisi olarak döner.</p>
<pre><pre class="playground"><code class="language-rust">// args0.rs
fn main() {
    for arg in std::env::args() {
        println!(&quot;'{}'&quot;, arg);
    }
} </code></pre></pre>
<pre><code>src$ rustc args0.rs
src$ ./args0 42 'hello dolly' frodo
'./args0'
'42'
'hello dolly'
'frodo'
</code></pre>
<p>Bir <code>Vec</code> dönse daha iyi olmaz mıydı? Bunu <code>collect</code> ile bir vektöre çevirmek de pek zor değildir, hatta döngüleyicilerin <code>skip</code> metotu ile programın adını atlayabilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let args: Vec&lt;String&gt; = std::env::args().skip(1).collect();
    if args.len() &gt; 0 { // we have args!
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>İşin en iyi tarafı, bütün dillerde bunu bu şekilde kullanıyor olmanız.</p>
<p>Biraz daha Rustça yaklaşım ise tek bir argümanı okumak. (Ve aynı zamanda bir tam sayı verisini okumak):</p>
<pre><pre class="playground"><code class="language-rust">// args1.rs
use std::env;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply an argument&quot;);
    let n: i32 = first.parse().expect(&quot;not an integer!&quot;);
    // do your magic
}</code></pre></pre>
<p><code>nth(1)</code> size bir döngüleyicinin ikinci verisini döner, <code>expect</code> ise <code>unwrap</code> gibi çalışır ancak bir de mesaj belirtmenize izin verir.</p>
<p>Bir karakter dizisini bir sayıya çevirmenin yolu gayet bariz, ancak dönüştürülecek tipi açıkça belirtmeniz gerekmekte - yoksa <code>parse</code> bunu nereden bilecek?</p>
<h1 id="Örüntü-eşleştirme-matching"><a class="header" href="#Örüntü-eşleştirme-matching">Örüntü Eşleştirme (Matching)</a></h1>
<p><code>string3.rs</code> dosyasındaki Rusça selamlamayı kullandığımız kodda aslında bu tarz durumları o şekilde çözmeyiz. <code>Match</code> ile deneyelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    match multilingual.find('п') {
        Some(idx) =&gt; {
            let hi = &amp;multilingual[idx..];
            println!(&quot;Russian hi {}&quot;, hi);
        },
        None =&gt; println!(&quot;couldn't find the greeting, Товарищ&quot;)
    };
<span class="boring">}</span></code></pre></pre>
<p><code>Match</code> şu kızılderili okunu barındıran, virgüllerle ayrılmış pek çok örüntü tanımından oluşur. Bu ifade, çok rahat bir şekilde <code>Option</code> içerisinden ifadeyi ayıklayabilir ve <code>idx</code>'e bağlayabilir. Bütün koşulların <em>muhakkak</em> karşılanması gerektiği için <code>None</code>'u da ele alıyoruz. </p>
<p>Buna bir kere alışınca (yani, bir kaç kez yazınca) size ayrıca <code>Option</code> tutacak ek bir değişken gerektiren <code>is_some</code> yazmaktan çok daha rahat gelecek.</p>
<p>Ancak hatalarla ilgilenmiyorsanız, mahalleden <code>if let</code>'i çağırabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if let Some(idx) = multilingual.find('п') {
        println!(&quot;Russian hi {}&quot;, &amp;multilingual[idx..]);
    }
<span class="boring">}</span></code></pre></pre>
<p><code>Match</code> C'deki <code>switch</code> gibi de çalışabilir ve diğer Rust kurucuları gibi veri de dönebilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let text = match n {
        0 =&gt; &quot;zero&quot;,
        1 =&gt; &quot;one&quot;,
        2 =&gt; &quot;two&quot;,
        _ =&gt; &quot;many&quot;,
    };
<span class="boring">}</span></code></pre></pre>
<p><code>_</code>'ı C'deki <code>default</code> olarak düşünebilirsiniz - varsayılan değer ifadesidir kendileri. Eğer bunu belirtmezseniz <code>rustc</code> bunun bir hata olduğunu düşünür. (C++'da bekleyebileceğiniz ilgili koşullar hakkında pek çok şeyi belirtilen bir uyarıyı almak olur.)</p>
<p>Rust'ın <code>match</code> deyimleri aralıkları da eşleştirebilir. Bu aralıkların üç noktalı olduğuna dikkat edin, bunlar kapsayan aralıklardır, mesela ilk koşul &quot;3&quot; sayısıyla eşleşecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let text = match n {
        0...3 =&gt; &quot;small&quot;,
        4...6 =&gt; &quot;medium&quot;,
        _ =&gt; &quot;large&quot;,
     };
<span class="boring">}</span></code></pre></pre>
<h1 id="dosyaları-okumak"><a class="header" href="#dosyaları-okumak">Dosyaları Okumak</a></h1>
<p>Bizim programlarımızı dünyaya açacak olan bir sonraki adımımız ise <em>dosyaları okumaktır.</em></p>
<p><code>expect</code>'in <code>unwrap</code> gibi çalıştığını ancak fazladan bir hata mesajı girmemize izin verdiğini aklınızda tutun. Şimdi birden çok hata hortlatacağız:</p>
<pre><pre class="playground"><code class="language-rust">// file1.rs
use std::env;
use std::fs::File;
use std::io::Read;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let mut file = File::open(&amp;first).expect(&quot;can't open the file&quot;);

    let mut text = String::new();
    file.read_to_string(&amp;mut text).expect(&quot;can't read the file&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());

}</code></pre></pre>
<pre><code>src$ file1 file1.rs
file had 366 bytes
src$ ./file1 frodo.txt
thread 'main' panicked at 'can't open the file: Error { repr: Os { code: 2, message: &quot;No such file or directory&quot; } }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
src$ file1 file1
thread 'main' panicked at 'can't read the file: Error { repr: Custom(Custom { kind: InvalidData, error: StringError(&quot;stream did not contain valid UTF-8&quot;) }) }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Dosyanın var olmadığı veyahut okunmasına izin olmadığı durumlarda <code>open</code> hata dönebilir, <code>read_to_string</code> ise dosya içeriğinin UTF-8 olmaması durumunda hata döner. (Tabii, bu koşulda yerine <code>read_to_end</code> kullanıp içeriği bayt vektörlerine koymak da bir seçenek.) Çok da büyük olmayan dosyaları tek hamlede okumak daha faydalı ve basittir.</p>
<p>Eğer diğer dillerde dosya işleme nasıl olur bir fikriniz varsa dosyanın ne zaman kapatılması gerektiğini düşünüyor olabilirsiniz. Eğer dosyaya bir şeyler yazdırsaydık kapatmamak veri kaybına sebebiyet verebilirdi ancak burada dosya kendiliğinden kapatılıyor ve fonksiyon sona erdiği zaman da <code>file</code> değişkeni <em>düşürülüyor.</em></p>
<p>Bu &quot;hata hortlatma işi&quot;ne biraz fazla alıştık galiba. Bütün programı böyle çökertebilen bir kodu kendi fonksiyonlarınıza yerleştirmek istemezsiniz. O zaman <code>File::open</code>'ın ne döndüğüne bakalım. Eğer <code>Option</code> bir şeyin varlığını ya da yokluğunu işaret ediyorsa <code>Result</code> da bir şeyin olup olmadığını gösterir. İkisi de <code>unwrap</code>'i bilir (ve amcaoğlu <code>expect</code>i de) ancak biraz farklıdırlar. <code>Result</code>, <code>Ok</code> ve <code>Err</code> için iki farklı tür parametre içerir. <code>Result</code> &quot;paketi&quot; iki farklı kompartmana sahiptir, birisi <code>Ok</code> ve diğeri de <code>Err</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn good_or_bad(good: bool) -&gt; Result&lt;i32,String&gt; {
    if good {
        Ok(42)
    } else {
        Err(&quot;bad&quot;.to_string())
    }
}

fn main() {
    println!(&quot;{:?}&quot;,good_or_bad(true));
    //Ok(42)
    println!(&quot;{:?}&quot;,good_or_bad(false));
    //Err(&quot;bad&quot;)

    match good_or_bad(true) {
        Ok(n) =&gt; println!(&quot;Cool, I got {}&quot;,n),
        Err(e) =&gt; println!(&quot;Huh, I just got {}&quot;,e)
    }
    // Cool, I got 42

}</code></pre></pre>
<p>(Aslında &quot;hata (error)&quot; için seçtiğimiz tip biraz gereksiz - pek çok insan <code>Rust</code>'ın hata tiplerine alışana kadar karakter dizelerini tercih eder.) Bu, bir veriyi ya da başka bir veriyi döndürmenin gayet uygun bir yoludur.</p>
<p>Dosya okumamızın bu şekli çökmez. <code>Result</code> döner ve onu <em>çağırana</em> gelen verinin nasıl işlenmesi gerektiğini seçtirir.</p>
<pre><pre class="playground"><code class="language-rust">// file2.rs
use std::env;
use std::fs::File;
use std::io::Read;
use std::io;

fn read_to_string(filename: &amp;str) -&gt; Result&lt;String,io::Error&gt; {
    let mut file = match File::open(&amp;filename) {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(e),
    };
    let mut text = String::new();
    match file.read_to_string(&amp;mut text) {
        Ok(_) =&gt; Ok(text),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    let file = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let text = read_to_string(&amp;file).expect(&quot;bad file man!&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());
}</code></pre></pre>
<p>Birinci eşleşme <code>Ok</code> içindeki veriyi güvenli bir şekilde dışarı çıkartır ve eşleşmenin değeri yapar. Eğer bir <code>Err</code> verisi ise, hatayı döner ve onu tekrar <code>Err</code> içerisine paketler.</p>
<p>İkinci eşleşme ise <code>Ok</code> içerisine paketlenmiş bir karakter dizesi döner ya da hatayı tekrar eder. <code>Ok</code> içindeki esas veriye ihtiyacımız yok ondan dolayı <code>_</code> ile yok sayıyoruz.</p>
<p>Bu biraz sıkıcı, yazdığımız kodu büyük kısmı hatayı işlemekten ibaret olunca &quot;işin ruhunu&quot; kaybediyoruz. Mesela Go'da bunu hissedersiniz, düzinesiyle erken dönen hataları kontrol etmeniz gerekir ya da sadece <em>görmezden gelirsiniz</em>. (Rust evreninde bu tuvalette ekmek çiğnemek kadar kötü bir şeydir.)</p>
<p>Neyse ki, bir kısayolumuz var.</p>
<p><code>std::io</code> modülü <code>io::Result&lt;T&gt;</code> diye bir tipe sahiptir ki bu <code>Result&lt;T, io::Error&gt;</code> ile aynı şeydir ve daha kolay yazılabilir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(&amp;filename)?;
    let mut text = String::new();
    file.read_to_string(&amp;mut text)?;
    Ok(text)
}
<span class="boring">}</span></code></pre></pre>
<p><code>?</code> operatörü <code>File::open</code> üzerinde denediğimiz eşleştirmelerle birebir aynı şeyi yapıyor; eğer sonuç hataysa hemen fonksiyonu döndürüyor. Değilse, <code>Ok</code> sonucunu dönüyor. Sonuç olarak hâlâ daha karakter dizisini paketlememiz gerekiyor.</p>
<p>2017 senesi Rust için iyi bir yıldı ve <code>?</code> gibi karizmatik şeyler kararlı hâle geldi. Eski kodlarda <code>try!</code> diye bir makroyu görebilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = try!(File::open(&amp;filename));
    let mut text = String::new();
    try!(file.read_to_string(&amp;mut text));
    Ok(text)
}
<span class="boring">}</span></code></pre></pre>
<p>Sonuç olarak, tek tek hataları bildirmeden güvenli Rust kodu yazmak düşündüğünüz kadar çirkin değil.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yapılar-numaralandırmalar-ve-eşleştirme"><a class="header" href="#yapılar-numaralandırmalar-ve-eşleştirme">Yapılar, Numaralandırmalar ve Eşleştirme</a></h1>
<h1 id="rust-lekta-movik-movik"><a class="header" href="#rust-lekta-movik-movik">Rust Lekta Movik Movik</a></h1>
<p>Fazla ileri gitmiyor muyuz? Mesela kaçırdığımız bazı şeyler var:</p>
<pre><pre class="playground"><code class="language-rust">// move1.rs
fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    let s2 = s1;
    println!(&quot;s1 {}&quot;, s1);
}</code></pre></pre>
<p>Kod çalışınca da şu hatayı alırız:</p>
<pre><code>error[E0382]: use of moved value: `s1`
 --&gt; move1.rs:5:22
  |
4 |     let s2 = s1;
  |         -- value moved here
5 |     println!(&quot;s1 {}&quot;, s1);
  |                      ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
  which does not implement the `Copy` trait
</code></pre>
<p>Rust diğer dillerden biraz daha farklı davranır. Bütün değişkenleri birer referans olduğu dillerde (Java ve Python gibi) <code>s2</code> <code>s1</code>'in karakter dizesi objesine bir başka referans olur. C++'da ise <code>s1</code> bir veridir ve <code>s2</code>'ye kopyalanır. Ancak Rust veriyi <em>taşır (move)</em>, karakter dizelerini ise kopyalanabilir bir tür olarak da görmez. (&quot;does not implement the Copy trait&quot; - &quot;Kopyala özelliğini barındırmıyor&quot;)</p>
<p>Böyle bir şeyi sayılar gibi &quot;ilkel (primitive)&quot; tiplerde görmeyiz çünkü onlar sadece veridir; kopyalanabilmelerine izin vardır çünkü kopyalaması ucuzdur. Ama <code>String</code> &quot;Hello Dolly&quot; için bellekte yer tahsis eder ve kopyalama daha fazla belleğin tahsis edilmesini ve karakterlerin tek tek kopyalanmasını içerir. Rust'ın bunu sessiz sedasız yapmasını bekleyemezsiniz. </p>
<p><code>String</code>'in bütün &quot;Moby Dick&quot;i barındırdığını düşünün. Bu karmaşık bir <em>yapı (struct)</em> olmazdı; sadece yazının bulunduğu bellek bölgesini tutan adresi, büyüklüğünü ve ne kadar bellekte alan tahsis edildiğini barındırırdı. Kopyalamak epey bir yük olurdu çünkü bellek <em>heap</em> bölgesinde tahsis edilmişti ve kopyalamanın kendisi de bellekte alan tahsis etmeyi gerektirirdi. </p>
<pre><code>    String
    | addr | ---------&gt; Call me Ishmael.....
    | size |                    |
    | cap  |                    |
                                |
    &amp;str                        |
    | addr | -------------------|
    | size |

    f64
    | 8 bytes |
</code></pre>
<p>İkinci veri ise karakter dizisi dilimidir (<code>&amp;str</code>) ve <code>String</code> ile aynı bellek alanına yönlendirir, büyüklüğü ile birlikte. Kopyalaması çok basit!</p>
<p>Üçüncü verimiz ise <code>f64</code> - sadece 8 bayt tutuyor. Herhangi bir bellek alanına yönlendirilmiyor, yani kopyalaması onu taşımak kadar basit.</p>
<p><code>Copy</code> verileri bellekteki karşılıklarıyla tanımlanır ve Rust kopyaladığı zaman bu baytları sadece başka bir yere kopyalar. Buna benzer olarak <code>Copy</code> olmayan bir veri ise <em>sadece taşınır</em>. C++'ın aksine kopyalama ve taşımada herhangi bir karmaşa yoktur.</p>
<p>Aynı şeyi bir fonksiyon çağrısı olarak yazmak da aynı soruna sebep olur:</p>
<pre><pre class="playground"><code class="language-rust">// move2.rs

fn dump(s: String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(s1);
    println!(&quot;s1 {}&quot;, s1); // &lt;---error: 'value used here after move'
}</code></pre></pre>
<p>Şimdi bir tercih yapmanız gerekiyor. Ya <code>String</code>'i bir referans olarak kullanacaksınız ya da açık açık <code>clone</code> metotu ile onu kopyalayacaksınız. Genelde ilk olan daha iyi bir seçenektir.</p>
<pre><pre class="playground"><code class="language-rust">fn dump(s: &amp;String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(&amp;s1);
    println!(&quot;s1 {}&quot;, s1);
}</code></pre></pre>
<p>Artık hatadan çok uzaktayız. Ancak <code>String</code> referansını çok nadir görürsünüz, çünkü bir karakter dizisi kalıbını bu şekilde kullanmak gerçekten çirkin ve bu yolla geçici bir <code>String</code> oluşturmak zorunda kalırsınız. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    dump(&amp;&quot;hello world&quot;.to_string());
<span class="boring">}</span></code></pre></pre>
<p>Onun yerine en iyi yol şudur:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dump(s: &amp;str) {
    println!(&quot;{}&quot;, s);
}
<span class="boring">}</span></code></pre></pre>
<p>Ve böylece <code>dump(&amp;s1)</code> ve <code>dump(&quot;hello world&quot;)</code> kullanımlarının ikisi de geçerli olacaktır. (Burada Rust'ın <code>Deref</code> zorlaması işin içine girer ve <code>&amp;String</code>'i <code>&amp;str</code> yapar.)</p>
<p>Sonuç olarak, <code>Copy</code> olmayan bir değerin değişkene atanması bir konumdan öbürüne taşınmasıdır. Eğer bu olmasaydı Rust <em>gizlice</em> kopyalamak zorunda kalırdı ve bellek tahsislerini <em>açıkça</em> yapma sözünü gerçekleştiremezdi.</p>
<h1 id="değişkenlerin-kapsamları"><a class="header" href="#değişkenlerin-kapsamları">Değişkenlerin Kapsamları</a></h1>
<p>Birinci kural, verileri kopyalamak yerine orijinal veriye referans göstermektir - yani &quot;ödünç almak.&quot;</p>
<p>Ancak bir referans sahibinden daha uzun <em>asla</em> yaşayamaz!</p>
<p>Öncelikle Rust blok kapsamlı bir dildir. Değişkenler kendi blokları kadar yaşar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let a = 10;
    let b = &quot;hello&quot;;
    {
        let c = &quot;hello&quot;.to_string();
        // a,b and c are visible
    }
    // the string c is dropped
    // a,b are visible
    for i in 0..a {
        let b = &amp;b[1..];
        // original b is no longer visible - it is shadowed.
    }
    // the slice b is dropped
    // i is _not_ visible!
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>i</code> gibi) Döngü değişkenleri biraz farklıdır, onlar sadece döngülerinin blokları için geçerlidir. Aynı isimle yeni bir değişken oluşturmak (&quot;gölgelemek/<em>shadowing</em>&quot;) bir hata değildir ama kafa karıştırıcı olabilir.</p>
<p>Bir değişken &quot;kapsam dışına çıkınca&quot; <em>düşürülür (dropped)</em>. Kullanılan her bir bellek tanesi geri dönüştürülür ve sistemden alınan kaynaklar iade edilir - örneğin, <code>File</code>'ı düşürmek onu kapatır. Bu iyi bir şey. Kullanılmayan kaynaklar ihtiyaç olmayınca hemen geri teslim edilir.</p>
<p>(Rust'a özgü bir başka sorun da verinin taşınmış olmasına rağmen kapsam dahilinde görünmüş olmasıdır.)</p>
<p>Bu örnekte <code>rs1</code> isminde bir referans hazırladık ve değerini sadece iç bloğun ömrü kadar uzun kalan <code>tmp</code>'ye ayarladık.</p>
<pre><pre class="playground"><code class="language-rust">01 // ref1.rs
02 fn main() {
03    let s1 = &quot;hello dolly&quot;.to_string();
04    let mut rs1 = &amp;s1;
05    {
06        let tmp = &quot;hello world&quot;.to_string();
07        rs1 = &amp;tmp;
08    }
09    println!(&quot;ref {}&quot;, rs1);
10 }</code></pre></pre>
<p><code>s1</code>'in verisini ödünç aldık ve sonra da <code>tmp</code>'i ödünç aldık. Ancak <code>tmp</code>, bloğun dışında yok!</p>
<pre><code>error: `tmp` does not live long enough
  --&gt; ref1.rs:8:5
   |
7  |         rs1 = &amp;tmp;
   |                --- borrow occurs here
8  |     }
   |     ^ `tmp` dropped here while still borrowed
9  |     println!(&quot;ref {}&quot;, rs1);
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p><code>Tmp</code> nerede? Gitti, yok, öldü o artık: <em>düşürüldü</em>. Rust sizi burada C'nin &quot;işaretçiler (dangling pointer)&quot; belasından koruyor - çoktan yitip gitmiş bir veriye işaret eden referanslardan yani.</p>
<h1 id="demetler-tuple"><a class="header" href="#demetler-tuple">Demetler (Tuple)</a></h1>
<p>Bir fonksiyondan çoklu veriler dönmeyi gerektiren zamanlar muhakkak gelecek. Demetler bunun için gayet uygun bir gözümdür.</p>
<pre><pre class="playground"><code class="language-rust">// tuple1.rs

fn add_mul(x: f64, y: f64) -&gt; (f64,f64) {
    (x + y, x * y)
}

fn main() {
    let t = add_mul(2.0,10.0);

    // can debug print
    println!(&quot;t {:?}&quot;, t);

    // can 'index' the values
    println!(&quot;add {} mul {}&quot;, t.0,t.1);

    // can _extract_ values
    let (add,mul) = t;
    println!(&quot;add {} mul {}&quot;, add,mul);
}
// t (12, 20)
// add 12 mul 20
// add 12 mul 20</code></pre></pre>
<p>Demetlerin dizilerden temel farkları, demetlerin <em>farklı</em> tipler barındırabilmesidir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple = (&quot;hello&quot;, 5, 'c');

assert_eq!(tuple.0, &quot;hello&quot;);
assert_eq!(tuple.1, 5);
assert_eq!(tuple.2, 'c');
<span class="boring">}</span></code></pre></pre>
<p>Bazen <code>Iterator</code> metotlarından karşınıza fırlarlar. <code>enumerate</code> tıpkı Python'daki aynı isimli oluşturucu gibi çalışır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for t in [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;].iter().enumerate() {
        print!(&quot; {} {};&quot;,t.0,t.1);
    }
    //  0 zero; 1 one; 2 two;
<span class="boring">}</span></code></pre></pre>
<p><code>zip</code> ise iki döngüleyiciyi birbiriyle eşleştirir ve bir demet içerisinde veri dönen tek bir döngüleyici olarak birleştirir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let names = [&quot;ten&quot;,&quot;hundred&quot;,&quot;thousand&quot;];
    let nums = [10,100,1000];
    for p in names.iter().zip(nums.iter()) {
        print!(&quot; {} {};&quot;, p.0,p.1);
    }
    //  ten 10; hundred 100; thousand 1000;
<span class="boring">}</span></code></pre></pre>
<h1 id="yapılar-struct"><a class="header" href="#yapılar-struct">Yapılar (Struct)</a></h1>
<p>Demetler fena şeyler değiller ancak <code>t.1</code> gibi bir anlam içermeyen parçalarını incelerken biraz kafa karıştırıcı olabilir.</p>
<p>Rust <em>yapıları</em> ise isimli <em>alanlar (field)</em> barındırır:</p>
<pre><pre class="playground"><code class="language-rust">// struct1.rs

struct Person {
    first_name: String,
    last_name: String
}

fn main() {
    let p = Person {
        first_name: &quot;John&quot;.to_string(),
        last_name: &quot;Smith&quot;.to_string()
    };
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}</code></pre></pre>
<p>Sizin bunu fark etmemenize rağmen yapıların verileri bellekte yanyana dururlar çünkü derleyici belleği verimliliğe göre düzenler, büyüklüğüne göre değil ve arada bazı boşluklar olabilir.</p>
<p>Bu yapıyı ilklemek (initalize) biraz garip görünebilir, bundan dolayı <code>Person</code> yapısını oluşturmayı bir fonksiyon içerisine taşıyorum. Bu fonksiyon bir <code>impl</code> bloğunun içerisine taşınarak <code>Person</code>'a ait bir <em>ilişkili fonksiyona (associated function)</em> dönüştürülebilir.</p>
<pre><pre class="playground"><code class="language-rust">// struct2.rs

struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

}

fn main() {
    let p = Person::new(&quot;John&quot;,&quot;Smith&quot;);
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}</code></pre></pre>
<p><code>new</code> ile ilişkili özel bir şey yok. C++ tarzı <code>::</code> notasyonu ile bu fonksiyona ulaşabiliyoruz.</p>
<p>Bir de argüman olarak <em>kendisini referans alan (reference self)</em> <code>Person</code> metotunu hazırlayalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    ...

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }

}
...
    println!(&quot;fullname {}&quot;, p.full_name());
// fullname John Smith
<span class="boring">}</span></code></pre></pre>
<p><code>self</code>, bir referans olarak açıkça belirtildi. (<code>&amp;self</code>'i <code>self: &amp;Person</code>'un kısaltması olarak düşünebilirsiniz.)</p>
<p><code>Self</code> kelimesi <code>struct</code> tipine atıfta bulunur -  <code>Person</code> yerine <code>Self</code> yazdığınızı düşünebilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn copy(&amp;self) -&gt; Self {
        Self::new(&amp;self.first_name,&amp;self.last_name)
    }
<span class="boring">}</span></code></pre></pre>
<p>Metotlar veri düzenlemek için kendilerini <em><code>mutable self</code></em> olarak argüman alırlar.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }
<span class="boring">}</span></code></pre></pre>
<p>Ve sadece <code>self</code> kullanıldığında veri <em>taşınacaktır</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }
<span class="boring">}</span></code></pre></pre>
<p>(Bunu bir de <code>&amp;self</code> ile deneyin ve yapıların (struct) kendi verileri konusunda ne kadar inatçı olduğunu bir de siz görün!)</p>
<p><code>v.to_tuple()</code> çağrıldığı zaman <code>v</code>'nin taşındığını ve kullanılamaz hâle geldiğini göreceksiniz.</p>
<p>Özetlersek:</p>
<ul>
<li><code>self</code> kullanılmazsa: fonksiyonları bu şekilde bağlayabilirsiniz, <code>new</code> &quot;oluşturucusu&quot; gibi .</li>
<li><code>&amp;self</code> ile: Yapının verilerini kullanabilir ancak değiştiremezsiniz.</li>
<li><code>&amp;mut self</code> ile: Yapının verilerini düzenleyebilirsiniz.</li>
<li><code>self</code> ile: Yapıyı yok edersiniz, yani içindeki verileri taşırsınız.</li>
</ul>
<p>Eğer <code>Person</code>'u veri ayıklama şeklinde ekrana yazdırırsanız, bilgilendirici bir hata alırsınız:</p>
<pre><code>error[E0277]: the trait bound `Person: std::fmt::Debug` is not satisfied
  --&gt; struct2.rs:23:21
   |
23 |     println!(&quot;{:?}&quot;, p);
   |                     ^ the trait `std::fmt::Debug` is not implemented for `Person`
   |
   = note: `Person` cannot be formatted using `:?`; if it is defined in your crate,
    add `#[derive(Debug)]` or manually implement it
   = note: required by `std::fmt::Debug::fmt`
</code></pre>
<p>Derleyici bazı tavsiyesine uyuyoruz ve <code>Person</code>'un tanımı üstüne  <code>#[derive(Debug)]</code> ekliyoruz, böylece işe yarar bir çıktımız oluyor:</p>
<pre><code>Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
</code></pre>
<p>Bu direktif, derleyicinin faydalı bir özellik olan <code>Debug</code>'u eklemesine yarıyor ki bu da sizin kendi yapılarınızla (struct) ekrana yazdırarak pratik yapmanıza yardımcı olur. (Ya da <code>format!</code> ile yazdırabilirsiniz). (Bunu <em>varsayılan</em> olarak gerçekleştirmek Rust'ın tarzı değil doğrusu.)</p>
<p>İşte minik programımızın son hâli:</p>
<pre><pre class="playground"><code class="language-rust">// struct4.rs
use std::fmt;

#[derive(Debug)]
struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;,self.first_name, self.last_name)
    }

    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }

    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }
}

fn main() {
    let mut p = Person::new(&quot;John&quot;,&quot;Smith&quot;);

    println!(&quot;{:?}&quot;, p);

    p.set_first_name(&quot;Jane&quot;);

    println!(&quot;{:?}&quot;, p);

    println!(&quot;{:?}&quot;, p.to_tuple());
    // p has now moved.

}
// Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
// Person { first_name: &quot;Jane&quot;, last_name: &quot;Smith&quot; }
// (&quot;Jane&quot;, &quot;Smith&quot;)</code></pre></pre>
<h1 id="yaşam-sürelerinin-yüreğimizi-dağlamaya-başladığı-o-an"><a class="header" href="#yaşam-sürelerinin-yüreğimizi-dağlamaya-başladığı-o-an">Yaşam Sürelerinin Yüreğimizi Dağlamaya Başladığı O An</a></h1>
<p>Yapıların çoğu zaman veri taşır ancak bazen referans taşıması da gerekebilir. Mesela düşünelim ki yapımıza karakter dizisi değeri yerine bir karakter dizisi dilimi ekleyeceğiz.</p>
<pre><pre class="playground"><code class="language-rust">// life1.rs

#[derive(Debug)]
struct A {
    s: &amp;str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}</code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; life1.rs:5:8
  |
5 |     s: &amp;str
  |        ^ expected lifetime parameter
</code></pre>
<p>Buradaki sorunu anlayabilmek için problemi bir de Rust'ın gözünden görmeniz gerekmekte. Rust, bir referansın ömrünün ne kadar uzun süreceğini hesaplamadan o referansa izin vermeyecektir. Bütün referanslar bir veriyi önüç alır ve her verinin bir yaşam süresi vardır. Referansların yaşam süreleri o verinin yaşam süresinden uzun olamaz. Rust, referansın geçersiz olduğu bir koşulun oluşma ihtimaline izin vermeyecektir. </p>
<p>Şimdi, karakter dizisi diliminin referansı bir <code>String</code> değerini ya da &quot;merhaba&quot; gibi bir <em>karakter dizisi kalıbını</em> ödünç alır. Karakter dizesi kalıpları programın yaşamı boyunca yaşar ki buna &quot;statik (static)&quot; yaşam süresi deriz.</p>
<p>İşte şimdi tıkır tıkır çalışıyor - Rust'ın bir karakter dizisi kalıbının sürekli olarak var olacağını garanti etmiş olduk. </p>
<pre><pre class="playground"><code class="language-rust">// life2.rs

#[derive(Debug)]
struct A {
    s: &amp;'static str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
// A { s: &quot;hello dammit&quot; }</code></pre></pre>
<p>Tabii bu hâli de çok şık görünmüyor ama net olmak için bazı bedeller ödemek gerekir.</p>
<p>Bunu bir fonksiyondan karakter dizisi dilimi döndürmek için de kullanabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn how(i: u32) -&gt; &amp;'static str {
    match i {
    0 =&gt; &quot;none&quot;,
    1 =&gt; &quot;one&quot;,
    _ =&gt; &quot;many&quot;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Kısıtlayıcı olmasına karşın statik karakter dizilerinin bu tarz durumları için işe yarar.</p>
<p>Buna karşın, biz bir referansın yaşam ömrünü <em>en az yapının ömrü kadar uzun</em> olarak da belirtebiliriz. </p>
<pre><pre class="playground"><code class="language-rust">// life3.rs

#[derive(Debug)]
struct A&lt;'a&gt; {
    s: &amp;'a str
}

fn main() {
    let s = &quot;I'm a little string&quot;.to_string();
    let a = A { s: &amp;s };

    println!(&quot;{:?}&quot;, a);
}</code></pre></pre>
<p>Yaşam ömürleri geleneksel olarak &quot;a&quot;, &quot;b&quot; gibi harflerle belirtilir ancak siz dilerseniz &quot;patlıcan&quot; gibi kelimelerle de ifade edebilirsiniz.</p>
<p>Bu ekleme ile beraber, bizim <code>A</code> yapısı ile <code>s</code> karakter dizisi birbirine sıkı sıkıya bağlanmıştır: <code>a</code>, <code>s</code>ten ödünç alır ve o olmadan yaşayamaz.</p>
<p>Bu tanımla birlikte şu şekilde <code>A</code> dönen bir fonksiyon yazabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn makes_a() -&gt; A {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}
<span class="boring">}</span></code></pre></pre>
<p>Ancak bu sefer de <code>A</code>'nın açıkça yaşam süresinin belirtilmesine ihtiyaç vardır - &quot;expected lifetime parameter&quot; (beklenilen yaşam süresi parametresi)</p>
<pre><code>  = help: this function's return type contains a borrowed value,
   but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p><code>rustc</code>'nin verdiği tavsiyeye uyalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn makes_a() -&gt; A&lt;'static&gt; {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}
<span class="boring">}</span></code></pre></pre>
<p>Ve hatamız:</p>
<pre><code>8 |      A { s: &amp;string }
  |              ^^^^^^ does not live long enough
9 | }
  | - borrowed value only lives until here
</code></pre>
<p>Bunu güvenli bir şekilde yapmanın bir yolu yok, çünkü fonksiyon sona verdiği zaman <code>string</code> düşecek ve <code>string</code>e yapılan referanslar kendinden daha uzun süre yaşayamaz.</p>
<p>Bazen, bir yapının değer ve o değeri içeren bir referans taşıması iyi bir fikirmiş gibi görünebilir. Ama bu çok basit bir şekilde imkansızdır çünkü yapılar <em>taşınabilir</em> olmalıdır, ve her türlü taşınma referansı geçersiz kılacaktır. Üstelik bunu yapmanın bir gereği de yok - mesela yapınızın karakter dizisi alanı varsa ve bunun dilimlerini sunmaya ihtiyacınız varsa, indeks numaralarını tutabilir ve bir metot içerisinde gerçek dilimleri dönebilirsiniz.</p>
<h1 id="Özellikler-trait"><a class="header" href="#Özellikler-trait">Özellikler (Trait)</a></h1>
<p>Rust'ta <code>struct</code>'ın <em>sınıf (class)</em> olmadığına dikkat edin. <code>class</code> kelimesinin anlamı diğer dillerde içi öylesine doldurulmuştur ki size nasıl düşüneceğinizi dikte eder hâle gelmiştir.</p>
<p>Şimdi şunlara dikkat edin: Rust'ta yapılar birbirini <em>miras (inherit)</em> alamaz; hepsi özgün tiplerdir. <em>Alt-tip</em> diye bir şey yok, o tarz şeyler sadece bir saçmalıktan ibaret.</p>
<p>Peki ya tipler arasındaki ilişkiler nasıl kurulur?</p>
<p><code>rustc</code> bazen &quot;implementing X trait (X özelliğini uygulamak)&quot; diye gevezelik eder ve şimdi özellikler (tipler) hakkında konuşmanın tam zamanı.</p>
<p>Aşağıdaki bir özellik tanımlamanın ve belirli tiplere nasıl <em>uygulandığının</em> örneğini görüyorsunuz.</p>
<pre><pre class="playground"><code class="language-rust">// trait1.rs

trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte signed {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}

fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let s1 = answer.show();
    let s2 = maybe_pi.show();
    println!(&quot;show {}&quot;, s1);
    println!(&quot;show {}&quot;, s2);
}
// show four-byte signed 42
// show eight-byte float 3.14</code></pre></pre>
<p>Şahane; <code>i32</code> ve <code>f64</code> içerisine <em>yeni bir metot</em> ekledik.</p>
<p>Rust ile haşır neşir oldum diyebilmek için standart kütüphanedeki basit özellikleri de bilmeniz gerekir. (Ki genelde bir arada bulunurlar.)</p>
<p><code>Debug</code> epey yaygındır. <code>Person</code> üzerinde <code>#[derive(Debug)]</code> ile uyguladık, ancak isteseydik tam ismi görüntüleyecek şekilde de uygulayabilirdik.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Debug for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.full_name())
    }
}
...
    println!(&quot;{:?}&quot;, p);
    // John Smith
<span class="boring">}</span></code></pre></pre>
<p><code>write!</code> da epey kullanışlı bir makrodur - burada <code>f</code> <code>Write</code> özelliğini barındıran her şeyi temsil ediyor. (Mesela bu bir <code>File</code> olabilir - ya da sadece bir <code>String</code>)</p>
<p><code>Display</code> ise &quot;{}&quot; ile yazdırılabilen verileri kontrol ve tıpkı <code>Debug</code> gibi uygulanır. Ve faydalı bir yan etki olarak, <code>ToString</code> <code>Display</code>'e sahip olan her türlü tipe uygulanır. Mesela <code>Display</code>'ı <code>Person</code> için uygularsak <code>p.to_string()</code> de çalışır hâle gelir.</p>
<p><code>Clone</code> ise <code>clone</code> metotunu tanımlar ve sadece <code>#[derive(Clone)]</code> ile tanımlanabilir - eğer bütün alanların (fields) tipleri <code>Clone</code>'a sahipse. (Ç.N: Clone - İngilizce Klonlamak)</p>
<h1 id="Örnek-noktalı-sayı-aralıklarının-döngüleyicisi"><a class="header" href="#Örnek-noktalı-sayı-aralıklarının-döngüleyicisi">Örnek: Noktalı sayı aralıklarının döngüleyicisi</a></h1>
<p>Daha önce aralıklarla (range, <code>0..n</code>) karşılaştık ancak noktalı sayı kabul etmiyorlar. (<em>Şansınızı zorlayabilirsiniz</em> ancak pek de numarası olmayan 1.0'da takılıp kalırsınız.) </p>
<p>Bir döngüleyici (iterator) için yaptığımız gayriresmi tanımı hatırlayın; <code>Some</code> veya <code>None</code> dönebilen bir <code>next</code> metotuna sahip yapı. Bu süreçte, döngüleyicinin kendisi düzenlenir ve döngülemenin durumu hakkında bilgi tutar. (Sonraki indeks gibi) Döngülenen verinin içeriği genellikle değişmez. (Ancak <code>Vec::drain</code> gibi kendi verisini düzenleyen enteresan bir döngüleyiciyi de inceleyeceğiz.)</p>
<p>Ve şimdi de resmi tanımı görelim: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">&quot;Iterator&quot; özelliği</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    ...
}
<span class="boring">}</span></code></pre></pre>
<p><code>Iterator</code> için <a href="https://doc.rust-lang.org/stable/book/associated-types.html">ilişkili tipi (associated type)</a> de tanımış olduk. Bu özelliğin (trait) çalışması için bir tipe ihtiyaç vardır ve dönüş tipini de belirtmeniz gerekmektedir. <code>next</code> metotu belirli bir tip belirtilmeden çalışabilir, sadece <code>Self</code> üzerinden <code>Item</code>'e atışta bulunulması yeterlidir.</p>
<p><code>f64</code> tipi için uygulanmış bir <code>Iterator</code>, <code>Iterator&lt;Item=f64&gt;</code> ile belirtilir ki bunu &quot;f64 tipi ile ilişkilendirilmiş bir döngüleyici&quot; olarak okuyabilirsiniz. </p>
<p><code>...</code> ile gösterilen kısım <code>Iterator</code>ün tedarik ettiği metotlardır. Sadece <code>Item</code> ve <code>next</code>'i belirttikten sonra pek çok metot da sizin için sunulacaktır.</p>
<pre><pre class="playground"><code class="language-rust">// trait3.rs

struct FRange {
    val: f64,
    end: f64,
    incr: f64
}

fn range(x1: f64, x2: f64, skip: f64) -&gt; FRange {
    FRange {val: x1, end: x2, incr: skip}
}

impl Iterator for FRange {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let res = self.val;
        if res &gt;= self.end {
            None
        } else {
            self.val += self.incr;
            Some(res)
        }
    }
}


fn main() {
    for x in range(0.0, 1.0, 0.1) {
        println!(&quot;{} &quot;, x);
    }
}</code></pre></pre>
<p>Ve şöyle biçimsiz bir görüntüyü elde etmiş oluyoruz:</p>
<pre><code>0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
</code></pre>
<p><code>0.1</code> tam olarak noktalı sayı olarak gösterilemediğinden böyle tuhaf şeyler yaşıyoruz, minik bir formatlama yardımı ile bundan kurtulabiliriz. <code>println!</code> kısımını şöyle düzeltelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:.1} &quot;, x);
<span class="boring">}</span></code></pre></pre>
<p>Ve daha temiz bir çıktımız olmuş oluyor. (Bu <a href="https://doc.rust-lang.org/std/fmt/index.html">formatlama</a> &quot;noktadan sonra bir rakam&quot; anlamına geliyor.)</p>
<p>Şimdi bütün döngüleyici metotlarını kullanabiliriz, hadi bütün verileri bir vektörde toplayalım, daha da coşmak için bunu <code>map</code> ile yapalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v: Vec&lt;f64&gt; = range(0.0, 1.0, 0.1).map(|x| x.sin()).collect();
<span class="boring">}</span></code></pre></pre>
<h1 id="genellenen-fonksiyonlar"><a class="header" href="#genellenen-fonksiyonlar">Genellenen Fonksiyonlar</a></h1>
<p>Diyelim ki <code>Debug</code> özelliiğine sahip herhangi bir tipi argüman olarak alan bir fonksiyon yazacağız. Burada jenerik fonksiyon kullanmamızın bir örneğini görüyorsunuz, herhangi bir verinin referansını argüman olarak alabilir. <code>T</code>, tip parametresi oluyor ki fonksiyon ismi yazıldıktan hemen sonra tanımlandı:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dump&lt;T&gt; (value: &amp;T) {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);
<span class="boring">}</span></code></pre></pre>
<p>Ancak, Rust kelimenin tam anlamıyla <code>T</code> tipi hakkında hiçbir şey bilmiyor.</p>
<pre><code>error[E0277]: the trait bound `T: std::fmt::Debug` is not satisfied
...
   = help: the trait `std::fmt::Debug` is not implemented for `T`
   = help: consider adding a `where T: std::fmt::Debug` bound
</code></pre>
<p>Bunun çalışması için, <code>T</code>'nin <code>Debug</code> içermesi gerektiğinden bahsetmeliyiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dump&lt;T&gt; (value: &amp;T)
where T: std::fmt::Debug {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);
// value is 42
<span class="boring">}</span></code></pre></pre>
<p>Rust'ın genellenen fonksiyonlarının tipe <em>özellikleri sağlaması (trait bounds)</em> gerekir - burada &quot;T is any type that implements Debug&quot; kısmını anlatıyoruz. (T, Debug'ı içeren herhangi bir tiptir) <code>rustc</code> epey yardımcı oluyor ve hangi tipin tam olarak belirtilmesi gerektiğini bize bildiriyor.</p>
<p>Şimdi Rust, <code>T</code> için tip bağlarını biliyor, artık derleyiciden mantıklı mesajlar alabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    name: String
}

let foo = Foo{name: &quot;hello&quot;.to_string()};

dump(&amp;foo)
<span class="boring">}</span></code></pre></pre>
<p>Buradaki hata ise  &quot;the trait <code>std::fmt::Debug</code> is not implemented for <code>Foo</code> (<code>std::fmt::Debug</code> özelliği <code>Foo</code> için uygulanmadı)&quot;</p>
<p>Fonksiyonlar dinamik dillerde aslında genellenir çünkü değerler beraberinde türlerini taşırlar ve tür denetimi çalışma zamanı denetlenir - ya da başarısız olur. Karmaşık programlarda daha derleme zamanında tiplerin kontrol edilmesini ciddi anlamda isteriz! Bu dillerdeki bir programcı, derleme hatalarını sakince incelemek yerine programın çalışma anındadaki sürprizleri incelemek zorundadır. Murphy kanununa göre sorunlar en uygunsuz, ters zamanda ortaya çıkmaya meyillidir.</p>
<p>Bir sayının karesini almak jeneriktir; tam sayılar, noktalı sayılar ve çarpım operatörünü içeren her türlü şeyin karesini <code>x*x</code> ile alabilirsiniz. Peki ya tip bağları?</p>
<pre><pre class="playground"><code class="language-rust">// gen1.rs

fn sqr&lt;T&gt; (x: T) -&gt; T {
    x * x
}

fn main() {
    let res = sqr(10.0);
    println!(&quot;res {}&quot;,res);
}</code></pre></pre>
<p>Sorun, Rust'ın <code>T</code>'nin çarpılabilir olduğunu bilmemesidir.</p>
<pre><code>error[E0369]: binary operation `*` cannot be applied to type `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
  |
note: an implementation of `std::ops::Mul` might be missing for `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
</code></pre>
<p>Derleyicinin tavsiyesine uyarak bu tipi <code>*</code> çarpım operatörünü barındıran <a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">ilgili özelliğe</a> zorlamayı deneyelim.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sqr&lt;T&gt; (x: T) -&gt; T
where T: std::ops::Mul {
    x * x
}
<span class="boring">}</span></code></pre></pre>
<p>Yine de hâlen daha çalışmıyor:</p>
<pre><code>error[E0308]: mismatched types
 --&gt; gen2.rs:6:5
  |
6 |     x * x
  |     ^^^ expected type parameter, found associated type
  |
  = note: expected type `T`
  = note:    found type `&lt;T as std::ops::Mul&gt;::Output`
</code></pre>
<p>Bu tipi daha da kısıtlamayı deneyelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sqr&lt;T&gt; (x: T) -&gt; T::Output
where T: std::ops::Mul + Copy {
    x * x
}
<span class="boring">}</span></code></pre></pre>
<p>(Ancak) şimdi oldu! Derleyiciyi sakince dinlemek sizi esas noktaya yaklaştırır, ta ki temizce program derlenene dek.</p>
<p>Tabii <em>bunu</em> <code>C++</code>'da yapmak daha kolay.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T sqr(x: T) {
    return x * x;
}
</code></pre>
<p>Ama (dürüst olmak gerekirse), C++ laz müteahhit mantığını benimsiyor. C++'ın şablon (template) hataları berbattır çünkü derleyicinin tek bildiği şey bazı metotların ya da operatörlerin tanımlanıp tanımlanmadığıdır. C++ komitesi bu sorunu biliyor ve <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">konseptler</a> üzerinde çalışıyorlar ki bunlar daha çok özelliklerle kısıtlanmış tip parametrelerine çok benziyorlar. </p>
<p>Genellenmiş fonksiyonlar başta biraz zorlayıcı gelebilir ancak net olmak, ne tür değerleri güvenle kullanabileceğinizi sadece tanıma bakarak kullanabileceğiniz anlamına geliyor.</p>
<p>Bu fonksiyonlar <em>çok biçimli</em>nin tersi olarak <em>tek biçimli</em> olarak bilinir. (ÇN: Tek biçimli - monomorfik, çok biçimli - polimorfik) Fonksiyonun gövdesi her bir tip için ayrı ayrı derleme yapar. Çok biçimli fonksiyonlarda ise makine eşlesen her tip için aynı kodu kullanır, dinamik olarak doğru metota <em>yönlendirir (dispatch)</em>.</p>
<p>Tek biçimlilik hızlı kod üretir, tipler için özelleştirilmiştir ve <em>satır içi</em> çalışabilirler. <code>sqr(x)</code> görüldüğü anda hemen <code>x*x</code> ile değiştirirlir. Ancak bunun dezavantajı, büyük genellenmiş fonksiyonların her için çok fazla kod üretmesidir ki buna <em>kod şişmesi (code bloat)</em> denir. Her zaman bir takas vardır ve deneyimli bir kişi hangi iş için doğru aracı seçeceğini bilmelidir.</p>
<h1 id="basit-numaralandırmalar"><a class="header" href="#basit-numaralandırmalar">Basit Numaralandırmalar</a></h1>
<p>Numaralandırmalar (Enums) birkaç verisi bulunan tiplerdir. Örneğin, bir yön dört farklı şekil alabilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Direction {
    Up,
    Down,
    Left,
    Right
}
...
    // `start` is type `Direction`
    let start = Direction::Left;
<span class="boring">}</span></code></pre></pre>
<p>Çeşitli metotlar alabilirler, tıpkı yapılar gibi. <code>Match</code> ifadesi <code>enum</code> tiplerini kontrol etmenin en basit yoludur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Direction {
    fn as_str(&amp;self) -&gt; &amp;'static str {
        match *self { // *self has type Direction
            Direction::Up =&gt; &quot;Up&quot;,
            Direction::Down =&gt; &quot;Down&quot;,
            Direction::Left =&gt; &quot;Left&quot;,
            Direction::Right =&gt; &quot;Right&quot;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Noktalama da önemlidir. <code>self</code>'ten önce <code>*</code> operatörünü kullandığımıza dikkat edin. Unutması kolaydır çünkü çoğu zaman Rust böyle düşünür. (<code>self.first_name</code> deriz, <code>(*self).first_name</code> değil.) Fakat eşleştirmenin biraz daha net olması gerekir. Olduğu gibi bırakmak buna kadar varan bir sürü çıktıya sebep olur:</p>
<pre><code>   = note: expected type `&amp;Direction`
   = note:    found type `Direction`
</code></pre>
<p>Çünkü <code>self</code> <code>&amp;Direction</code> tipidir, bundan dolayı <code>*</code> ile deferans ederiz. </p>
<p>Yapılar gibi numaralandırmalar da özellikleri içerebilir, <code>#[derive(Debug)]</code> arkadaş da <code>Direction</code>'a eklenebilir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        println!(&quot;start {:?}&quot;,start);
        // start Left
<span class="boring">}</span></code></pre></pre>
<p>Yani <code>as_str</code> metotu aslında o kadar da gerekli değil, <code>Debug</code> ile isimleri her zaman alabiliriz. (Ancak <code>as_str</code> alan tahsis etmez, ki bu önemli olabilir.)</p>
<p>Ancak burada net bir sıralama aramamalısınız - numaralandırmalar tam sayı değeri barındırmaz. </p>
<p>(Ç.N: Numaralandırma olarak çevrilen <code>enum</code> sözcüğü gerçekten de C ve C++'da sayılandırma işlemi için kullanılır ancak Rust'ta böyle bir özellik yoktur. C++'daki karşılığı <code>enum</code> değil, <code>enum class</code>'tır.)</p>
<p>Şimdi her <code>Direction</code> değerinin ardılını gösteren bir metot yazdık. <code>use</code> içinde <em>yıldız jokerini</em> kullanmak metotun içeriğine bütün numaralandırma değerlerini sıraladığı için epey kullanışlıdır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn next(&amp;self) -&gt; Direction {
        use Direction::*;
        match *self {
            Up =&gt; Right,
            Right =&gt; Down,
            Down =&gt; Left,
            Left =&gt; Up
        }
    }
    ...

    let mut d = start;
    for _ in 0..8 {
        println!(&quot;d {:?}&quot;, d);
        d = d.next();
    }
    // d Left
    // d Up
    // d Right
    // d Down
    // d Left
    // d Up
    // d Right
    // d Down
<span class="boring">}</span></code></pre></pre>
<p>Bu şekilde istenen ve belirlenmiş düzende bütün yönleri sonsuza dek sıralamaya izin verir. Aslında bu oldukça basit bir <em>durum makinesidir</em>.</p>
<p>Numaralandırma verileri kıyaslanamaz:</p>
<pre><code>assert_eq!(start, Direction::Left);

error[E0369]: binary operation `==` cannot be applied to type `Direction`
  --&gt; enum1.rs:42:5
   |
42 |     assert_eq!(start, Direction::Left);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: an implementation of `std::cmp::PartialEq` might be missing for `Direction`
  --&gt; enum1.rs:42:5
</code></pre>
<p>Çözüm, <code>enum Direction</code> tanınımının üstüne <code>#[derive(Debug,PartialEq)]</code> eklemektir.</p>
<p>Önemli bir nokta, Rust'ın kullanıcı tiplerinin bir eklenti ile birlikte gelmemesidir. Genel özellikleri (trait) ekleyerek onlara olağan davranışları verirsiniz. Bu yapılar için de geçerlidir - eğer bir yapıya <code>PartialEq</code> verirseniz akla yatkın bir şey belirlenecek, tüm alanların <code>PartialEq</code>'e sahip olduğunu düşünerek bir kıyas yapacaktır. Eğer alanlar buna sahip değilse, eşitliği tanımlananız gerekmektedir ki bunu açıkça tanımlamanıza izin vardır.</p>
<p>Rust'ta &quot;C tarzı numaralandırmalar&quot; da kullanılabilir.</p>
<pre><pre class="playground"><code class="language-rust">// enum2.rs

enum Speed {
    Slow = 10,
    Medium = 20,
    Fast = 50
}

fn main() {
    let s = Speed::Slow;
    let speed = s as u32;
    println!(&quot;speed {}&quot;, speed);
}</code></pre></pre>
<p>İlklendiği zaman tam sayı değeri alırlar ve tip dönüşümleriyle tam sayıya dönüşebilirler.</p>
<p>Bunun için sadece ilk isme değer vermeniz yeterlidir, diğerleri de bir arttırarak onu takip edecektir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Difficulty {
    Easy = 1,
    Medium,  // is 2
    Hard   // is 3
}
<span class="boring">}</span></code></pre></pre>
<p>Tabii isim diyince anlamı tam oturmadı, tıpkı her şeye &quot;şey&quot; demek gibi. Esas kullanılması gereken terim <em>varyanttır</em> - <code>Speed</code>in varyantları <code>Slow</code>, <code>Medium</code> ve <code>Fast</code>tır.</p>
<p>Numaralandırmalar doğal bir sıralama da alabilir, ancak bunu kibarca istemelisiniz. <code>enum Speed</code>'in başına <code>#[derive(PartialEq,PartialOrd)]</code> ekledikten sonra <code>Speed::Fast &gt; Speed::Slow</code> ve <code>Speed::Medium != Speed::Slow</code> gibi ifadeler kullanılabilir olur.</p>
<h1 id="numaralandırmalar-tam-teçhizatlıyken"><a class="header" href="#numaralandırmalar-tam-teçhizatlıyken">Numaralandırmalar Tam Teçhizatlıyken</a></h1>
<p>Rust'ın numaralandırmaları tam anlamıyla kullanıldığı zaman C'deki birliklerin (union) steroidli hâline benzer, tıpkı Ferrari ile Fiat Uno gibi. Çeşitli tiplerden verileri bir araya güvenlice toplamanın zorluğunu düşünün.</p>
<pre><pre class="playground"><code class="language-rust">// enum3.rs

#[derive(Debug)]
enum Value {
    Number(f64),
    Str(String),
    Bool(bool)
}

fn main() {
    use Value::*;
    let n = Number(2.3);
    let s = Str(&quot;hello&quot;.to_string());
    let b = Bool(true);

    println!(&quot;n {:?} s {:?} b {:?}&quot;, n,s,b);
}
// n Number(2.3) s Str(&quot;hello&quot;) b Bool(true)</code></pre></pre>
<p>Numaralandırma bu verilerden sadece birisini taşıyabilir, büyüklüğü bir varyantın en büyük değeri kadardır.</p>
<p>Şimdiye kadar bir süper araba etmese de numaralandırmaların kendilerini yazdırabilmeleri de güzel şey. Bunun yanında verilerinin ne tarz veriler olduğunu da biliyorlar ki bu <code>match</code>'ın süpergücüdür. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn eat_and_dump(v: Value) {
    use Value::*;
    match v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
....
eat_and_dump(n);
eat_and_dump(s);
eat_and_dump(b);
//number is 2.3
//string is 'hello'
//boolean is true
<span class="boring">}</span></code></pre></pre>
<p>(<code>Result</code> ve <code>Option</code> kardeşleri hatırladınız mı? Onlar da bir numaralandırma.)</p>
<p><code>eat_and_dump</code> fonksiyonu hiç fena değil ancak veriyi bir referans olarak iletsek iyi olur çünkü şu an verinin yerini taşıyor ve onu &quot;yiyor&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dump(v: &amp;Value) {
    use Value::*;
    match *v {  // type of *v is Value
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}

error[E0507]: cannot move out of borrowed content
  --&gt; enum3.rs:12:11
   |
12 |     match *v {
   |           ^^ cannot move out of borrowed content
13 |     Number(n) =&gt; println!(&quot;number is {}&quot;,n),
14 |     Str(s) =&gt; println!(&quot;string is '{}'&quot;,s),
   |         - hint: to prevent move, use `ref s` or `ref mut s`
<span class="boring">}</span></code></pre></pre>
<p>Ödünç alınmış referanslarla yapamayacağınız bazı şeyler var. Rust, orijinal değerin içerisindeki karakter dizisini <em>dışarı çıkartmanıza</em> izin vermeyecektir. <code>Number</code> üzerinde sorun yok çünkü <code>f64</code>'ün kopyalanmasında bir sakınca yok ama <code>String</code> <code>Copy</code>'i içermez.</p>
<p><code>match</code>'ın kesin tipler hakkında seçici olduğunu söyledim, ipucunu takip edelim ve sıkıntı çıkartmayacaktır, şimdi içerideki karakter dizisine bir referans ödünç alıyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dump(v: &amp;Value) {
    use Value::*;
    match *v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(ref s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
    ....

    dump(&amp;s);
    // string is 'hello'
<span class="boring">}</span></code></pre></pre>
<p>Devam etmeden önce, başarılı bir Rust derlemesinin mutluluğu ile dolup taşmışken, bir saniye bekleyelim. <code>Rustc</code> o kadar iyi ki sorunu tam olarak <em>anlamadan</em> onu çözmemizi sağlıyor. </p>
<p>Sorun, eşleştirmenin kesinliğinden ve ödünç kontrolünün kuralların çiğnenmemesinden kaynaklanıyor. Bu kurallardan birisi, sahipliği olan bir tipe dahil olan veriyi zart diye çekemiyor olmamızdan geliyor. Biraz C++ bilmek burada kafa karıştırabilir çünkü akla yatkın olsa bile C++ problemin yolunu kopyalayacaktır. Bir vektörden karakter dizesi alırken de aynı hatayı alabilirsiniz, mesela <code>*v.get(0).unwrap</code> ile deneyin. (<code>*</code> kullanmanızın sebebi indekslemenin referans dönmesi) Buna yapmanıza izin vermecektir. (Bu tarz durumlarda <code>Clone</code> çok da kötü bir tercih olmayabilir.)</p>
<p>(Bu arada, <code>v[0]</code> karakter dizeleri gibi kopyalanamaz verilerde tam olarak bundan dolayı çalışmayacaktır. <code>&amp;v[0]</code> ile ödünç almanız ya da <code>v[0].clone()</code> kullanmanız gerekmektedir.)</p>
<p><code>match</code> kullanırken <code>Str(s: String) =&gt;</code> yerine <code>Str(s)</code> yazıldığını görebilirsiniz. Yeni bir yerel değişken yaratılır. (bazen <em>bağlama (binding)</em> olarak anılır) Çoğu zaman tatmin edilen tip uyar, mesela veriyi alıp onun içinden çıkartırken. Ancak burada <code>s: &amp;String</code> yazmaya ihtiyacımız oldu ve <code>ref</code> ile sadece <code>String</code>'i ödünç almak istediğimizi bildirmiş olduk.</p>
<p>Burada da bir karakter dizisini dışarı çıkartıyoruz ve değerin daha sonra ne olacağını umursamıyoruz. <code>_</code> geri kalan her şeyle eşleşecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Value {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        match self {
        Value::Str(s) =&gt; Some(s),
        _ =&gt; None
        }
    }
}
    ...
    println!(&quot;s? {:?}&quot;, s.to_str());
    // s? Some(&quot;hello&quot;)
    // println!(&quot;{:?}&quot;, s) // error! s has moved...
<span class="boring">}</span></code></pre></pre>
<p>İsimlendirme önemlidir -, <code>as_str</code> olarak değil de <code>to_str</code> olarak tanımlamamıza dikkat edin. (Ç.N: To Str - Str'ye çevir, As Str - Str olarak) Bir karakter dizisini <code>Option&lt;&amp;String&gt;</code> olarak dönen  bir metot yazabilirsiniz. (Referansın da numaralandırma değeri ile aynı yaşam süresinde olmasına gerek vardır) Ancak onu <code>to_str</code> olarak isimlendirmemelisiniz. </p>
<p><code>to_str</code> örneğimizi şöyle yazabilirsiniz - tamamen aynı işi yapar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn to_str(self) -&gt; Option&lt;String&gt; {
        if let Value::Str(s) = self {
            Some(s)
        } else {
            None
        }
    }
<span class="boring">}</span></code></pre></pre>
<h1 id="eşleştirme-hakkında-daha-fazlası"><a class="header" href="#eşleştirme-hakkında-daha-fazlası">Eşleştirme Hakkında Daha Fazlası</a></h1>
<p>&quot;()&quot; kullanarak bir demeti dışarı çıkartabileceğinizi hatırladınız mı?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let t = (10,&quot;hello&quot;.to_string());
    ...
    let (n,s) = t;
    // t has been moved. It is No More
    // n is i32, s is String
<span class="boring">}</span></code></pre></pre>
<p>Bu <em>parçalama</em> işleminin özel bir durumudur; elimizdeki bazı veriler var ve (buradaki gibi) parçalara ayırmayı ya da verilerini ödünç almayı düşünebiliriz. Her iki durum da da bir bütünün parçalarına ulaşmaya çalışıyoruz.</p>
<p>Sözdizimi <code>match</code>'taki gibi kullanılabilir. Burada açıkça ödünç alınmış verileri ödünç alıyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (ref n,ref s) = t;
    // n and s are borrowed from t. It still lives!
    // n is &amp;i32, s is &amp;String
<span class="boring">}</span></code></pre></pre>
<p>Yapıları parçalamak da pekâlâ mümkün:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Point {
        x: f32,
        y: f32
    }

    let p = Point{x:1.0,y:2.0};
    ...
    let Point{x,y} = p;
    // p still lives, since x and y can and will be copied
    // both x and y are f32
<span class="boring">}</span></code></pre></pre>
<p><code>match</code>'ı yeni örüntülerle tekrar inceleyelim. İlk iki örüntü <code>let</code> parçalaması gibi çalışır - ilki ilk elemanı sıfır olan, ikinci indeksi karakter dizesi olan her türlü demetle eşleşir, ikincisi ise sadece <code>(1, &quot;hello&quot;)</code> ile eşleşir. Son koşulda ise olarak, bir değişken <em>herhangi bir şeyle</em> eşleşir. Eğer <code>match</code> bir ifadeyi eşleştiriyorsa ancak bunu değişkene bağlamak istemiyorsanız bu epey kullanışlıdır. <code>_</code> da bir değişken gibi çalışır ancak görmezden gelinir, bir <code>match</code>'ı bitirmenin yaygın bir yoludur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn match_tuple(t: (i32,String)) {
    let text = match t {
        (0, s) =&gt; format!(&quot;zero {}&quot;, s),
        (1, ref s) if s == &quot;hello&quot; =&gt; format!(&quot;hello one!&quot;),
        tt =&gt; format!(&quot;no match {:?}&quot;, tt),
        // or say _ =&gt; format!(&quot;no match&quot;) if you're not interested in the value
     };
    println!(&quot;{}&quot;, text);
}
<span class="boring">}</span></code></pre></pre>
<p>Peki neden sadece <code>(1, &quot;hello&quot;)</code> kullanmıyoruz? Eşleştirme kesin olarak çalışır ve derleyici de bundan bahsedecektir:</p>
<pre><code>  = note: expected type `std::string::String`
  = note:    found type `&amp;'static str`
</code></pre>
<p>Neden <code>ref s</code>'e ihtiyacımız var? Bu biraz belirsiz bir durum (E00008 numaralı hataya bakın.) ve eğer bir koşula bağlayacaksanız bunu ödünç almanız gerekir, koşula bağlamanız farklı bir bağlamda gerçekleştiğinden bellekteki alanın taşınması gerekebilir. Bu, işin en civcivli olduğu yerlerden birisi.</p>
<p>Eğer tipimiz <code>&amp;str</code> olsaydı bunu doğrudan eşleştirebilirdik:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    match (42,&quot;answer&quot;) {
        (42,&quot;answer&quot;) =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;)
    };
<span class="boring">}</span></code></pre></pre>
<p><code>match</code> için geçerli olan <code>if let</code> için de geçerlidir. Bu mesela güzel bir örnek, bir <code>Some</code> verimiz olduğu için içindeki veriyi çekebiliriz ve içinden sadece bir karakter dizisini çıkartabiliriz. İç içe geçmiş <code>if let</code> ifadelerine ihtiyacımız da yok üstelik. Burada <code>_</code> kullanıyoruz çünkü demetin ilk parçası ilgimizi çekmiyor. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let ot = Some((2,&quot;hello&quot;.to_string());

    if let Some((_,ref s)) = ot {
        assert_eq!(s, &quot;hello&quot;);
    }
    // we just borrowed the string, no 'destructive destructuring'
<span class="boring">}</span></code></pre></pre>
<p><code>parse</code> ile ilgili bir enteresan bir sorunumuz da var. (Ya da dönüş tipini bilmesi gereken fonksiyonlar için de bunu düşünebiliriz)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if let Ok(n) = &quot;42&quot;.parse() {
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p><code>n</code>'in tipi nedir? Bir ipucu vermeniz gerekir, ne tür bir tam sayılı değer bu? Hatta bu tam sayı mıdır?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if let Ok(n) = &quot;42&quot;.parse::&lt;i32&gt;() {
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>Bu rezil söz diziminin adı &quot;<a href="https://turbo.fish/">turbofish operatörüdür</a>&quot;. </p>
<p>Eğer <code>Result</code> dönen bir fonksiyonun içerisindeyseniz, soru işareti ile çok daha şık bir çözüm kullanabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let n: i32 = &quot;42&quot;.parse()?;
<span class="boring">}</span></code></pre></pre>
<p>Her neyse, herhangi bir <code>parse</code> hatası <code>Result</code>'ın hata tipine dönüştürülebilir bir tipe ihtiyaç duyar ki bunu sonra <a href="2-structs-enums-lifetimes.html#bu_yay%C4%B1nlan%C4%B1nca_d%C3%BCzenlenecek">hata kontrolü</a> kısmında ele alacağız.</p>
<h1 id="kapamalar-closure"><a class="header" href="#kapamalar-closure">Kapamalar (Closure)</a></h1>
<p>Rust'ın gücünün büyük bir kısmı bu kapamalardan gelir. En basit hâliyle bir fonksiyonun kısa yoluna benzerler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = |x| x * x;

    let res = f(10);

    println!(&quot;res {}&quot;, res);
    // res 100
<span class="boring">}</span></code></pre></pre>
<p>Burada açıkça belirtilmiş bir tip yoktur - bir &quot;10&quot; tam sayı kalıbının kullanılmasına kadar her şey tahmin edilmiştir. </p>
<p>Ancak <code>f</code>'i farklı farklı tipler için kullanırsak hata alırız - Rust <code>f</code>'in tam sayılarla çalışması gerektiğine karar vermişti.</p>
<pre><code>    let res = f(10);

    let resf = f(1.2);
  |
8 |     let resf = f(1.2);
  |                  ^^^ expected integral variable, found floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>İlk kullanım <code>x</code> için argümanı belirlemişti. Aslında yaptığımız şey şudur:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn f (x: i32) -&gt; i32 {
        x * x
    }
<span class="boring">}</span></code></pre></pre>
<p>Ancak açıkça tiplerin yazılmaması dışında fonksiyonlar ve kapamaların bir farkı daha vardır. Doğru fonksiyonunu inceleyelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let m = 2.0;
    let c = 1.0;

    let lin = |x| m*x + c;

    println!(&quot;res {} {}&quot;, lin(1.0), lin(2.0));
    // res 3 5
<span class="boring">}</span></code></pre></pre>
<p>Bunu <code>fn</code> ile böyle yapamayız, kapsamının dışında kalan hiçbir şeyle <code>fn</code> ilgilenmez. Buradaki kapama, <code>m</code> ve <code>c</code>'yi kendi kapsamı içerisine ödünç aldı.</p>
<p>Peki ya <code>lin</code>'in tipi nedir? Ancak <code>rustc</code> bilebilir. Aslında görünenin altında kapama, çağrılabilir bir (çağırma operatörünü içeren bir) <em>yapıdır (struct).</em> Şu şekilde yazılmış gibi davranır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyAnonymousClosure1&lt;'a&gt; {
    m: &amp;'a f64,
    c: &amp;'a f64
}

impl &lt;'a&gt;MyAnonymousClosure1&lt;'a&gt; {
    fn call(&amp;self, x: f64) -&gt; f64 {
        self.m * x  + self.c
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Derleyici bu konuda epey yardımcı oluyor ve basit bir kapamayı buna dönüştürüyor! Tek bilmeniz gereken kapama bir <em>yapıdır</em> ve verileri içinde bulunduğu çevreden <em>ödünç alır.</em> Bu referansların da bir <em>yaşam ömrü</em> vardır. </p>
<p>Bütün kapamaların benzersiz tipleri vardır ancak benzer özellikleri (trait) içerirler. Türü tam bilmesek de en azından jeneriklerde nasıl ifade edeceğimi biliyoruz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply&lt;F&gt;(x: f64, f: F) -&gt; f64
where F: Fn(f64)-&gt;f64  {
    f(x)
}
...
    let res1 = apply(3.0,lin);
    let res2 = apply(3.14, |x| x.sin());
<span class="boring">}</span></code></pre></pre>
<p>El-meal: <code>apply</code> <code>Fn(f64)-&gt;f64</code>'e sahip herhangi bir T tipi ile çalışabilir - yani <code>f64</code> alıp <code>f64</code> dönen bir fonksiyon olabilir bu.</p>
<p><code>apply(3.0, lin)</code> şeklinde çağırdıktan sonra <code>lin</code>'e erişmek şu tuhaf hatayı ortaya çıkartıyor:</p>
<pre><code>    let l = lin;
error[E0382]: use of moved value: `lin`
  --&gt; closure2.rs:22:9
   |
16 |     let res = apply(3.0,lin);
   |                         --- value moved here
...
22 |     let l = lin;
   |         ^ value used here after move
   |
   = note: move occurs because `lin` has type
    `[closure@closure2.rs:12:15: 12:26 m:&amp;f64, c:&amp;f64]`,
     which does not implement the `Copy` trait
</code></pre>
<p>Ve bu kadar, <code>apply</code> bizim kapamamızı yedi. Ve ayrıca, <code>rustc</code>'nin kullanmaya çalıştığı yapının (struct) gerçek tipi. Kapamaları bir yapı olarak düşünmek işi epey kolaylaştırıyor.</p>
<p>Bir kapama çağırmak aslında <em>metot çağrısıdır</em>: Üç tip fonksiyon özelliği (trait) üç tip metoda sahiptir:</p>
<ul>
<li><code>Fn</code>, <code>&amp;self</code> olarak geçer.</li>
<li><code>FnMut</code>, <code>&amp;mut self</code> olarak geçer.</li>
<li><code>FnOnce</code> ise sadece <code>self</code> olarak geçer.</li>
</ul>
<p>Bir kapama içerisinde <em>yakalanmış referansları</em> düzenlemek de mümkündür.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   fn mutate&lt;F&gt;(mut f: F)
   where F: FnMut() {
       f()
   }
   let mut s = &quot;world&quot;;
   mutate(|| s = &quot;hello&quot;);
   assert_eq!(s, &quot;hello&quot;);
<span class="boring">}</span></code></pre></pre>
<p><code>mut</code>'a dikkat edin - <code>f</code>'in değişebilir olması gerekiyor.</p>
<p>Yine de, ödünç alma ile ilgili kurallardan kaçınamazsınız. Şuna bakın:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = &quot;world&quot;;

// closure does a mutable borrow of s
let mut changer = || s = &quot;world&quot;;

changer();
// does an immutable borrow of s
assert_eq!(s, &quot;world&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Çalışamaz! Çünkü <code>s</code>'i <code>assert</code> deyiminde ödünç alamıyoruz, çünkü daha önce <code>changer</code> kapamasında değişken olarak ödünç almıştır. Kapama düşürülmediği sürece <code>s</code>'e hiç kimse erişemez, bundan dolayı iç bir kapsam alanı içerisinde kullanarak yaşam süresini kontrol etmek en iyi çözümdür.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = &quot;world&quot;;
{
    let mut changer = || s = &quot;world&quot;;
    changer();
}
assert_eq!(s, &quot;world&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Eğer Lua ve JavaScript gibi dillere aşinaysanız, bu dillerde basit olmasına karşın Rust'ta kapamaların bu denli karmaşık olduğunu merak ediyor olabilirsiniz. Bu, Rust'ın gizlice bellek tahsis etmemesi için gerekli bir bedeldir. JavaScript'te, <code>mutate(function() {s = &quot;hello&quot;;})</code> gibi bir ifadenin karşılığı her zaman dinamik bellek tahsis edilmiş kapamadır. </p>
<p>Bazen kapamaların verileri ödünç almasını değil direkt taşımasını isteyebilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let name = &quot;dolly&quot;.to_string();
    let age = 42;

    let c = move || {
        println!(&quot;name {} age {}&quot;, name,age);
    };

    c();

    println!(&quot;name {}&quot;,name);
<span class="boring">}</span></code></pre></pre>
<p>Burada alacağımız hata son <code>println</code>'dadır: &quot;taşınmış verinin kullanımı: <code>name</code> (use of moved value: <code>name</code>)&quot;. Burada tek bir çözüm var, kapamanın içine veriyi taşımak: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let cname = name.to_string();
    let c = move || {
        println!(&quot;name {} age {}&quot;,cname,age);
    };
<span class="boring">}</span></code></pre></pre>
<p>Neden taşıyan kapamalara ihtiyacımız var? Çünkü orijinal verinin erişilemeyeceği bir durumda onları çağırmamız gerekebilir. En basit örneği <em>iş parçacıklarıdır.</em> Taşıyan kapamalar ödünç almaz, bundan dolayı yaşam süresi açısından hiçbir sorunları olmaz.</p>
<p>Kapamaların esas kullanımı döngüleyici metotlarıdır. Noktalı sayılar için hazırladığımız <code>range</code> döngüleyicisini hatırlayın. Kapama kullanarak bu döngüleyici (veya başka döngüleyiciler) üzerinde işlem yapmak gayet kolay:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let sine: Vec&lt;f64&gt; = range(0.0,1.0,0.1).map(|x| x.sin()).collect();
<span class="boring">}</span></code></pre></pre>
<p><code>map</code> vektörler üzerinde tanımlanmadı (Bunu kullanan bir özellik (trait) yaratmak oldukça kolay olmasına rağmen) çünkü <code>map</code>'ın yeni bir vektör yaratması gerekirdi. Bu şekilde elimizde seçeneklerimiz oluyor. Üstelik, geçici hiçbir öğe yaratılmış olmuyor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let sum: f64 = range(0.0,1.0,0.1).map(|x| x.sin()).sum();
<span class="boring">}</span></code></pre></pre>
<p>Tıpkı bir döngü yazmak kadar kadar hızlı. Eğer Rust kapamaları JavaScript kapamaları kadar &quot;acısız&quot; olsaydı bu performansı garanti edemezdik.</p>
<p><code>filter</code> da ayrıca bir iterator metotudur - geriye sadece koşullara uyanlar kalır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let tuples = [(10,&quot;ten&quot;),(20,&quot;twenty&quot;),(30,&quot;thirty&quot;),(40,&quot;forty&quot;)];
    let iter = tuples.iter().filter(|t| t.0 &gt; 20).map(|t| t.1);

    for name in iter {
        println!(&quot;{} &quot;, name);
    }
    // thirty
    // forty
<span class="boring">}</span></code></pre></pre>
<h1 id="Üç-tarz-ı-döngüleyici"><a class="header" href="#Üç-tarz-ı-döngüleyici">Üç Tarz-ı Döngüleyici</a></h1>
<p>Üç farklı çeşit (yine) üç basit argüman tipine denk düşüyor. Bir <code>String</code> vektörümüz olduğunu düşünelim. Bunlar bizim döngüleyici tiplerimiz, ilk üçü aleni bir şekilde sonraki üçü de gizil bir şekilde belirtilmiştir. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for s in vec.iter() {...} // &amp;String
for s in vec.iter_mut() {...} // &amp;mut String
for s in vec.into_iter() {...} // String

// implicit!
for s in &amp;vec {...} // &amp;String
for s in &amp;mut vec {...} // &amp;mut String
for s in vec {...} // String
<span class="boring">}</span></code></pre></pre>
<p>Şahsen ben aleni bir şekilde ifade etmeyi tercih ediyorum, ancak iki formu da anlamak ve nasıl kullanıldığını bilmek önemlidir. </p>
<p><code>into_iter</code> vektörü tüketir ve içeriğindeki karakter dizilerini çıkartır, ve ardından artık vektör kullanılamaz - artık taşınmış olur. Pythonistalar alışkanlıktan <code>for s in vec</code> dediği zaman başlarına bu gelir.</p>
<p><code>for s in &amp;vec</code> şeklindeki gizil form muhtemelen kullanmak isteyeceğiniz şekildir, tıpkı fonksiyon argümanlarında <code>&amp;T</code> kullanmak gibi.</p>
<p>Üç çeşidi de anlamak önemlidir çünkü Rust tip tahminlerini epeyce kullanır - kapama argümanlarında tip bildirimlerini pek görmezsiniz. Bu iyi bir şey çünkü bu tiplerin hepsi yazılsaydı kafa şişirici olurdu. Ancak, bu ufak kodun bedeli gizil tiplerin ne olduğunu net olarak bilmenizin gerekmesidir!</p>
<p><code>map</code> döngüleyicinin değerini ne olursa olsun alır ve onu başka bir şeye dönüştürür, ancak <code>filter</code> veriye bir <em>referans</em> alır. Aşağıda, <code>iter</code> kullanıyoruz ve bundan dolayı döngüleyici tipi <code>&amp;String</code>tir. <code>filter</code>'ın her veriyi referansını aldığını gözden kaçırmayın:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for n in vec.iter().map(|x: &amp;String| x.len()) {...} // n is usize
....
}

for s in vec.iter().filter(|x: &amp;&amp;String| x.len() &gt; 2) { // s is &amp;String
...
}
<span class="boring">}</span></code></pre></pre>
<p>Metotları çağırdığınız zaman Rust kendiliğinden dereferans eder, ondan dolayı sorunu pek anlamazsınız. Ancak <code>|x: &amp;&amp;String| x == &quot;one&quot;</code> çalışmayacaktır çünkü operatörler tip eşleştirmesinden daha katıdır. <code>rustc</code>, <code>&amp;str</code> ve <code>&amp;&amp;String</code>'i kıyaslayacak bir operatör olmadığını bildirecektir. Bundan dolayı eşleşme yapabilmek için <code>&amp;&amp;String</code>'i <code>&amp;String</code>e çevirmek için dereferans etmeniz gerekecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for s in vec.iter().filter(|x: &amp;&amp;String| *x == &quot;one&quot;) {...}
// same as implicit form:
for s in vec.iter().filter(|x| *x == &quot;one&quot;) {...}
<span class="boring">}</span></code></pre></pre>
<p>Eğer tipleri bildirmeyi bırakırsanız, argümanı şu şekilde düzeltebilirsiniz ki bu sefer s'in tipi <code>&amp;String</code> olur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for s in vec.iter().filter(|&amp;x| x == &quot;one&quot;)
<span class="boring">}</span></code></pre></pre>
<p>Ve çoğu zaman bu şekilde yazıldığını görürsünüz.</p>
<h1 id="dinamik-verili-yapılar"><a class="header" href="#dinamik-verili-yapılar">Dinamik Verili Yapılar</a></h1>
<p><em>Kendisine refereans barındıran yapı</em> tekniği çok güçlü bir tekniktir.</p>
<p>Aşağıda C ile yazılmış bir <em>ikili ağacın</em> temel tuğlasını görüyorsunuz. (C... Âdeta Beyoğlu'nun arka sokakları gibi... &quot;Acaba başıma ne gelecek?&quot; demeden dolaştığınız tarihî sokaklarda nefes kesici bir gezi...)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Node {
        const char *payload;
        struct Node *left;
        struct Node *right;
    };
<span class="boring">}</span></code></pre></pre>
<p>Bunu doğrudan <code>Node</code> alanlarını içererek yapamazsınız çünkü <code>Node</code>'un büyüklüğü yine <code>Node</code>'a dayanır. Ki bu hesaplanamaz. Bundan dolayı <code>Node</code> yapılarının göstericilerini (pointer) kullanıyoruz, ki göstericinin boyutu her zaman kestirilebilir.</p>
<p>Eğer <code>left</code>, <code>NULL</code> değilse <code>Node</code>'un <code>left</code> tarafı bir başka <code>Node</code> gösteriyordur ve bu böyle sonsuza kadar gidebilir.</p>
<p>Rust'ta <code>NULL</code> yoktur (en azından bu güvensiz hâliyle yok), bu <code>Option</code>'un işidir. Ancak <code>Node</code>'u doğrudan <code>Option</code> içerisine ekleyemezsiniz çünkü <code>Node</code>'un boyutunu bilemezsiniz. (gibi gibi) Bu da <code>Box</code>'un işidir, kendisinin sabit bir boyutu vardır ancak bellekte alanı tahsis edilmiş veriyi işaret eder. </p>
<p>İşte Rust'taki karşılığına bakalım, <code>type</code> ile tipimize bir takma ad verdik:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type NodeBox = Option&lt;Box&lt;Node&gt;&gt;;

#[derive(Debug)]
struct Node {
    payload: String,
    left: NodeBox,
    right: NodeBox
}
<span class="boring">}</span></code></pre></pre>
<p>(Rust işte böyle kalender meşreptir, ileriye dönük bildirimlere ihtiyacınız yoktur.)</p>
<p>Şimdi bunu test edelim:</p>
<pre><pre class="playground"><code class="language-rust">impl Node {
    fn new(s: &amp;str) -&gt; Node {
        Node{payload: s.to_string(), left: None, right: None}
    }

    fn boxer(node: Node) -&gt; NodeBox {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node) {
        self.right = Self::boxer(node);
    }

}


fn main() {
    let mut root = Node::new(&quot;root&quot;);
    root.set_left(Node::new(&quot;left&quot;));
    root.set_right(Node::new(&quot;right&quot;));

    println!(&quot;arr {:#?}&quot;, root);
}</code></pre></pre>
<p>Çıktı beklediğimizden çok daha iyi, &quot;{:#?}&quot; sağolsun. (&quot;#&quot; genişletilmiş demektir.)</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;left&quot;,
            left: None,
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;right&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>Peki ya <code>root</code> düşerse? Bütün alanlar da düşer, ağacın <code>dalları</code> düşerse kendi alanlarını da kaybolur ve böyle devam eder. <code>Box::new</code>, C++'daki <code>new</code> anahtar kelimesine en çok ulaşacağınız alandır ancak <code>delete</code> veyahut <code>free</code> gibi bir kelimeye ihtiyacınız yoktur.</p>
<p>Bu ağacı kullanmak için bir yol bulmalıyız. Karakter dizilerinin sıralanabildiğine dikkat edin: &quot;hede&quot; &lt; &quot;hödö&quot;, &quot;ayı&quot; &gt; &quot;abi&quot;; sözde alfabetik sıralama olarak anılır. (Aslını söylemek gerekirse, insan dillerinin çeşitliliğinden ve tuhaf kurallarına istinaden buna sözlüksel sıralama denir.)</p>
<p>Aşağıda <code>Node</code>ları sözlüksel sıralamaya göre yerleştiren bir metot görüyorsunuz. Veriyi mevcut <code>Node</code> ile kıyaslıyoruz - eğer küçükse soluna yerleştiriyoruz, değilse de sağına yerleştirmeye çalışıyoruz. Solda bir <code>Node</code> olmayabilir, bundan dolayı <code>set_left</code> kullanıyoruz.</p>
<pre><pre class="playground"><code class="language-rust">    fn insert(&amp;mut self, data: &amp;str) {
        if data &lt; &amp;self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }

    ...
    fn main() {
        let mut root = Node::new(&quot;root&quot;);
        root.insert(&quot;one&quot;);
        root.insert(&quot;two&quot;);
        root.insert(&quot;four&quot;);

        println!(&quot;root {:#?}&quot;, root);
    }</code></pre></pre>
<p><code>match</code>'a dikkat edin - <code>Box</code> içerisinden değişken bir referans çıkartıyoruz, eğer <code>Option</code>'un içeriği <code>Some</code> ise <code>insert</code> kullanıyoruz. Değilse, sol tarafa yeni bir <code>Node</code> ekliyoruz ve böyle devam ediyoruz. <code>Box</code>, akıllı bir göstericidir; <code>Node</code> metotlarını çağırmak için &quot;kutudan çıkarmamıza&quot; gerek yok!</p>
<p>İşte ağacımızın görüntüsü:</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;one&quot;,
            left: Some(
                Node {
                    payload: &quot;four&quot;,
                    left: None,
                    right: None
                }
            ),
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;two&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>Diğerlerinden daha &quot;küçük&quot; olan karakter dizileri sol eklenir, aksi durumda ise sağa eklenirler.</p>
<p>Şimdi gezinti zamanı. Bu <em>iç-sıralı gezinmedir. (inorder traversal)</em> - önce solu ziyaret ediyoruz, bir şeyler yapıyoruz ve sonra da sağa geçiyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn visit(&amp;self) {
        if let Some(ref left) = self.left {
            left.visit();
        }
        println!(&quot;'{}'&quot;, self.payload);
        if let Some(ref right) = self.right {
            right.visit();
        }
    }
    ...
    ...
    root.visit();
    // 'four'
    // 'one'
    // 'root'
    // 'two'
<span class="boring">}</span></code></pre></pre>
<p>Karakter dizilerini bir sıralamaya göre geziyoruz! <code>ref</code>'in <code>if let</code> için kullanıldığına dikkat edin, <code>match</code> ile aynı kurallara sahiptir.</p>
<h1 id="genellenen-yapılar"><a class="header" href="#genellenen-yapılar">Genellenen Yapılar</a></h1>
<p>Önceki örneğimizde kullandığımız ikili ağaç yapısını düşünün. Bütün <code>payload</code> tipleri için yeniden yazmak epey <em>çıldırtıcı</em> olurdu doğrusu. <code>T</code> tip parametresiyle <code>Node</code>'u yeniden jenerik şekilde yazıyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type NodeBox&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

#[derive(Debug)]
struct Node&lt;T&gt; {
    payload: T,
    left: NodeBox&lt;T&gt;,
    right: NodeBox&lt;T&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>Bu kullanım diller arasındaki farkları da belli ediyor. <code>Payload</code> üzerindeki temel işlem karşılaştırmadır, bundan dolayı T ile <code>&lt;</code> kullanılabilmelidir ki <code>PartialOrd</code> bunu sağlar. Tip parametresi <code>impl</code> bloğu içerisinde özellik kısıtlamasıyla birlikte yazılmalıdır.</p>
<pre><pre class="playground"><code class="language-rust">impl &lt;T: PartialOrd&gt; Node&lt;T&gt; {
    fn new(s: T) -&gt; Node&lt;T&gt; {
        Node{payload: s, left: None, right: None}
    }

    fn boxer(node: Node&lt;T&gt;) -&gt; NodeBox&lt;T&gt; {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node&lt;T&gt;) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node&lt;T&gt;) {
        self.right = Self::boxer(node);
    }

    fn insert(&amp;mut self, data: T) {
        if data &lt; self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }
}


fn main() {
    let mut root = Node::new(&quot;root&quot;.to_string());
    root.insert(&quot;one&quot;.to_string());
    root.insert(&quot;two&quot;.to_string());
    root.insert(&quot;four&quot;.to_string());

    println!(&quot;root {:#?}&quot;, root);
}</code></pre></pre>
<p>Tıpkı C++ gibi genellenen yapımız tip parametrelerinin köşeli ayraçlarla gösterilmesine ihtiyaç duyar. Rust genellikle bu tür tip parametresini bağlamdan tahmin edebilecek kadar zekidir - Bunun <code>Node&lt;T&gt;</code> olduğunu biliyor ve <code>T</code> üzerinde <code>insert</code> kullanıyor. İlk <code>insert</code> tasarısı sadece <code>String</code> ile takılıp kalmıştı. Ancak yeni kullanım uymuyorsa muhtemelen bir şekilde bunu bildirecektir.</p>
<p>Ancak, tipi uygun biçimde kısıtlamanız gerektiğine dikkat edin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dosya-sistemi-ve-süreçler"><a class="header" href="#dosya-sistemi-ve-süreçler">Dosya Sistemi ve Süreçler</a></h1>
<h1 id="dosya-okumaya-farklı-bir-bakış"><a class="header" href="#dosya-okumaya-farklı-bir-bakış">Dosya Okumaya Farklı Bir Bakış</a></h1>
<p>Birinci bölümün sonunda bütün dosyayı bir karakter dizisi içerisine aktarmayı göstermiştim. Doğal olarak bu her zaman iyi bir fikir olmayabilir, bu yüzden bir dosyayı satır satır okumayı göstereceğim.</p>
<p><code>fs::File</code>, <code>io::Read</code>'ı tanımlar ki bu okunabilen her şeyin özelliğidir. (trait) Bu özellik, <code>u8</code> ile bayt içeren bir dilimi dolduran <code>read</code> metotunu tanımlar - bu özelliğin <em>gerekli</em> tek metotudur ve <em>beraberinde gelen</em> pek çok metotu bedavaya kapmış olursunuz, <code>Iterator</code> gibi. Bir bayt vektörünü doldurmak için <code>read_to_end</code>'u veya bir karakter dizisini doldurmak için <code>read_to_string</code>'i kullanabilirsiniz - UTF-8 ile kodlanmış olması bir zorunluluktur.</p>
<p>Bu arabellek kullanılmayan (buffering) &quot;saf&quot; bir okumadır. Arabellekli okuma için <code>read_line</code> ve <code>lines</code> döngüleyicisini sunan <code>io::BufRead</code> özelliğini kullanabilirsiniz. <code>io::BufReader</code>, <code>io::BufRead</code>'ın kullanımlarını okunabilir <em>herhangi</em> bir şey için sunacaktır.</p>
<p><code>fs::File</code> ise aynı zamanda <code>io::Write</code>'ı da barındırır.</p>
<p>Bütün bu özelliklerin kullanılabilir olduğunu görmenin en kolay yolu <code>use std::io::prelude::*</code> kullanmaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::prelude::*;

fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let reader = io::BufReader::new(file);

    for line in reader.lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><code>let line = line?</code> gözünüze biraz tuhaf görünebilir. Döngüleyiciden dönen <code>line</code>  aslında <code>io::Result&lt;String&gt;</code> tipidir ve <code>?</code> ile onu paketinden dışarı çıkartıyoruz. Bunu yapmamızın sebebi döngü esnasında bir şeylerin yanlış gide<em>bile</em>ceğidir. - Girdi/çıktı hataları, UTF-8 olmayan bir bayt serisini almak gibi şeyler.</p>
<p>Bir döngüleyici olarak <code>lines</code>'i <code>collect</code> ile bir vektöre kolayca çevirebiliriz ya da <code>enumerate</code> döngüleyicisi ile her satırın sırasını öğrenebiliriz.</p>
<p>Yine de bütün satırları okumak için en iyi tercih bu değildir çünkü her satır için yeni bir <code>String</code> tahsis edilir. En iyi yöntem <code>read_line</code> kullanmaktır, biraz daha acayip görünse de. Satırın bir satır sonu karakteri içerdiğine dikkat edin ki bunu <code>trim_right</code> ile siliyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut reader = io::BufReader::new(file);
    let mut buf = String::new();
    while reader.read_line(&amp;mut buf)? &gt; 0 {
        {
            let line = buf.trim_right();
            println!(&quot;{}&quot;, line);
        }
        buf.clear();
    }
<span class="boring">}</span></code></pre></pre>
<p>Sonuçta çok daha az tahsis etme işlemimiz oluyor çünkü bir karakter dizisini <em>temizlemek</em> onun tahsis edilmiş alanını boşaltmıyor, bu alanı işgal eden yeni tahsis işlemleriyle uğraşmıyoruz.</p>
<p>Bu arada ödünç alma işlemini bozmamak için blok kullandığımız durumlardan birisiyle karşı karşıyayız. <code>line</code>, <code>buf</code> tarafından ödünç alınıyor ve bu ödünç <code>buf</code>'ı tekrardan düzenlemeden önce belleği terk etmelidir. Yine Rust bizi aptalca bir şey yapmaktan alıkoymaya çalışıyor, ara belleği boşalttıktan <em>sonra</em> <code>line</code>'a ulaşmak gibi. (Ödünç alma mekanizması bazen sizi darlayabilir. Rust bu kodu inceleyecek ve <code>line</code>'ın, <code>buf.clear()</code>'dan sonra kullanılmadığını görecektir, bu &quot;sözcüksel olmayan yaşam sürelerini (non-lexical lifetimes)&quot; ayıklamasından kaynaklanır.</p>
<p>Bu pek şık görünmüyor. Belki size arabelleğe referanslar dönen bir döngüleyici veremem ama en azından döngüleyiciye <em>benzeyen</em> bir şeyler verebilirim.</p>
<p>Şimdi jenerik bir yapı tanımlayalım; <code>R</code> ismindeki tip parametremiz <code>Read</code> içeren her tipi kabul edebilir. Bu yapının içeriğinde okuyucu (reader) ve referansını alabileceğimiz bir arabelleğimiz (buffer, ya da kısaca buf) olacak.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// file5.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

struct Lines&lt;R&gt; {
    reader: io::BufReader&lt;R&gt;,
    buf: String
}

impl &lt;R: Read&gt; Lines&lt;R&gt; {
    fn new(r: R) -&gt; Lines&lt;R&gt; {
        Lines{reader: io::BufReader::new(r), buf: String::new()}
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Şimdi <code>next</code> metotunu kullanalım. Tıpkı bir döngüleyici gibi <code>Option</code> dönecek, <code>None</code> döndüğü zaman döngüleyici başa dönmüş olacak. İçerisinden dönen tip <code>Result</code> olacak çünkü <code>read_line</code> başarısız olabilir ve <em>asla hataları görmezden gelmiyoruz</em>. Eğer başarısız olursa hatayı <code>Some&lt;Result&gt;</code> olarak dönebiliriz. Eğer dosyanın doğal sınırı olan &quot;sıfır baytları&quot; okunursa bu bir hata değildir, sadece <code>None</code>'dur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;io::Result&lt;&amp;'a str&gt;&gt;{
        self.buf.clear();
        match self.reader.read_line(&amp;mut self.buf) {
            Ok(nbytes) =&gt; if nbytes == 0 {
                None // no more lines!
            } else {
                let line = self.buf.trim_right();
                Some(Ok(line))
            },
            Err(e) =&gt; Some(Err(e))
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Şimdi, yaşam sürelerinin nasıl çalıştığına dikkat edin. Açık bir yaşam süresi belirtmemiz gerekti çünkü Rust hiçbir zaman karakter dizelerini yaşam sürelerini belirtmeden ödünç almaya izin vermeyecektir ve burada ödünç alınan karakter dizisinin yaşam süresini <code>self</code> ile birlikte belirtiyoruz.</p>
<p>Bu yaşam süresiyle birlikte bu tanım <code>Iterator</code> özelliği ile uyumsuz. Ancak uyumlu olsaydı sorunları kolayca görebilirdik, <code>collect</code>'in karakter dizileririnden vektör yapmaya çalıştığını düşünün. Bu mümkün değil zira hepsi aynı değişebilir (mutable) karakter dizisini ödünç almış olurdu! (Eğer <em>bütün</em> dosyayı bir karakter dizesine çevirmek isteseydiniz karakter dizelerinin <code>lines</code> metotu karakter dizeleri dönebilirdi çünkü hepsi esas karakter dizilerinden ödünç alınmıştır.)</p>
<p>Neticedeki döngü çok daha temizdir ve ara belleğe alma işlemi pek çok kullanıcı tarafından görünmez.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let mut lines = Lines::new(file);
    while let Some(line) = lines.next() {
        let line = line?;
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Hatta eşleştirme karakter dizisi dilimini dışarı çıkartacağından, döngüyü bu şekilde de yazabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    while let Some(Ok(line)) = lines.next() {
        println!(&quot;{}&quot;, line)?;
    }
<span class="boring">}</span></code></pre></pre>
<p>Bunu yapmak isteyebilirsiniz ancak muhtemel hataları halının altına süpürmüş olursunuz; döngü bir hata söz konusu olduğu zaman sessizce duracaktır. Daha da ötesi, Rust'ın <code>UTF-8</code>'e çeviremediği ilk yerde duracaktır. Gündelik kodlar için kabul edilebilir ancak kodu yayına aldığınız zaman kötüdür.</p>
<h1 id="dosyalara-yazmak"><a class="header" href="#dosyalara-yazmak">Dosyalara Yazmak</a></h1>
<p><code>Debug</code>'u kullanırken <code>write!</code> ile tanışmıştık - <code>Write</code>'ın kullanıldığı her yerde aynı zamanda <code>write!</code> kullanabiliriz. <code>print!</code> demenin farklı bir yoluna bakalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stdout = io::stdout();
    ...
    write!(stdout,&quot;answer is {}\n&quot;, 42).expect(&quot;write failed&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Eğer bir hata <em>söz konusu olabilirse</em> bunu idare edebilirsiniz. Bu <em>genellikle</em> gerçekleşmez ancak yine de söz konusu olabilir. Eğer bir girdi/çıktı işlemi yapıyor Bu genellikle kabul edilebilir çünkü bir dosyayla oynaşıyorsanız <code>?</code> eklemeniz gereken bazı yerler olabilir. </p>
<p>Ancak bir fark var; <code>print!</code>, <code>stdout</code>'u her yazım için kitler. Çoğu zaman istediğiniz şey budur çünkü çoklu süreçlerin yazıldığı programlarda <code>stdout</code>'u kitlemezseniz çıktınız tuhaf bir şekilde karmaşıklaşabilir. Ancak çok fazla metin yolluyorsanız <code>write!</code> çok daha hızlı davranacaktır.</p>
<p>Çeşitli dosyalar için <code>write!</code> kullanmamız gerekiyor. <code>out</code>,  <code>write_out</code>'un sonunda düşürüldüğü zaman dosya kapanır ki bu hem istenen şeydir hem de önemlidir.</p>
<pre><pre class="playground"><code class="language-rust">// file6.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

fn write_out(f: &amp;str) -&gt; io::Result&lt;()&gt; {
    let mut out = File::create(f)?;
    write!(out,&quot;answer is {}\n&quot;, 42)?;
    Ok(())
}

fn main() {
  write_out(&quot;test.txt&quot;).expect(&quot;write failed&quot;);
}</code></pre></pre>
<p>Eğer performansı önemsiyorsanız Rust'ın varsayılan olarak önbelleğe alınmadığını bilmeniz gerekir. Her bir yazma talebi doğrudan işletim sistemine gönderilir ki bu işleri oldukça yavaşlatır. Bundan bahsediyorum çünkü diğer programlama dillerinde varsayılan davranış farklıdır ve Rust'ın betik dilleri tarafından geride bırakıldığını görmek sizi epeyce şaşırtabilir! Nasıl ki <code>Read</code>'ın <code>io::BufReader</code>'ı varsa <code>io::BufWriter</code>ın da <code>Write</code>'ı var.</p>
<h1 id="dosyalar-konumlar-ve-dizinler"><a class="header" href="#dosyalar-konumlar-ve-dizinler">Dosyalar, Konumlar ve Dizinler</a></h1>
<p>Şimdi makinedeki Cargo dizinini bulan bir program yazalım. En basit yöntem <code>~/.cargo</code> altına bakmaktır. Ancak bu Unix kabuğu için geçerlidir, çoklu ortam desteği için <code>env::home_dir</code> fonksiyonunu kullanacağız. (Başarısız olabilir ancak ev dizini olmayan bir bilgisayar da Rust araçlarını barındırmaz.)</p>
<p>Ç.N: <a href="https://doc.rust-lang.org/std/env/fn.home_dir.html"><code>env::home_dir</code></a> fonksiyonu beklenildiği gibi çalışmadığı için <code>1.29.0</code>'dan itibaren tedavülden kaldırılmıştır. Bu fonksiyonu kullanmayın, Windows ve Unix ortamları için ev dizinlerini kendi yöntemlerinizle bulmanızı veya bir <a href="https://crates.io">crates.io</a>'yu karıştırmanızı tavsiye ederim.</p>
<p>Sonra bir <code>PathBuf</code> yaratalım ve <code>push</code> metotunu <em>parçalardan</em> tam bir dosya konumu inşa etmek için kullanalım. (Bu <code>/</code> gibi bir şeyle ile debelenmekten çok daha kolaydır.)</p>
<pre><pre class="playground"><code class="language-rust">// file7.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let home = env::home_dir().expect(&quot;no home!&quot;);
    let mut path = PathBuf::new();
    path.push(home);
    path.push(&quot;.cargo&quot;);

    if path.is_dir() {
        println!(&quot;{}&quot;, path.display());
    }
}</code></pre></pre>
<p><code>PathBuf</code>, <code>String</code> gibi çalışır - karakterlerin büyüyebilen bir paketidir ancak konum inşa etmek için kendi araçlarını kullanır. Ancak özelliklerinin çoğunluğu <code>Path</code>'ın referans versiyonundan gelir, tıpkı <code>&amp;str</code> gibi. Yani, mesela, <code>is_dir</code> bir <code>Path</code> metotudur.</p>
<p>Bu kulağınıza şüphe uyandıran bir miras alma (inheritance) tarzı gibi gelebilir, ancak bu <a href="https://doc.rust-lang.org/book/deref-coercions.html">Deref</a> özelliğinin maharetidir. Gözünüze tıpkı <code>String/&amp;str</code> gibi görünebilir - bir <code>PathBuf</code> referansı bir  <code>Path</code> referansına <em>dönüşür/zorlanır. (coerced)</em> (&quot;Zorlamak (Coerce)&quot; kelimesi biraz ağır kaçmış olabilir ancak bu Rust sizin için dönüşüm uyguladığı nadir yerlerden birisidir.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(p: &amp;Path) {...}
...
let path = PathBuf::from(home);
foo(&amp;path);
<span class="boring">}</span></code></pre></pre>
<p><code>PathBuf</code>'un en yakın arkadaşı <code>OsString</code>'tir, kendisi sistemden doğrudan aldığımız karakter dizilerini gösterir. (Aynı şekilde buna karşılık <code>OsString/&amp;OsStr</code> ilişkisi de vardır.)</p>
<p>Bu tarz karakter dizilerinin UTF-8 olacağını <em>garanti edilmemiştir!</em> Gerçek hayatta her şey <a href="https://news.ycombinator.com/item?id=10519932">karmaşıktır</a>, özellikle &quot;Her şey neden bu kadar zor&quot; diye düşünürken. Sadede gelelim. Birincisi antik ASCII kodlamanın ve diğer diller için özel kodlamanın kullanıldığı yıllar oldu. İkincisi kendi aramızda konuştuğumuz dillerin kendisi de epey karmaşıktır. Mesela &quot;noël&quot; kelimesi <em>beş</em> Unikod kodu kadar yer tutar.</p>
<p>Modern işletim sistemlerinin dosya adlarının çoğu zaman Unikod olabileceği doğrudur. (Unix tarafı için UTF-8, Windows için UTF-16) Ama olmadığı zamanlar da vardır! Ve Rust bu olasılığı dikkatlice ele almalıdır. Örneğin <code>Path</code>, <code>as_os_str</code> diye <code>&amp;OsStr</code> dönen bir metota sahiptir. Ancak <code>to_str</code>, bazen <code>Option&lt;&amp;str&gt;</code> döner. Yani her zaman mümkün değildir!</p>
<p>İnsanlar genelde bu konuda biraz takılır çünkü &quot;karakter&quot; ve &quot;karakter dizesi&quot;ne fazlasıyla alıştılar. Einstein'ın dediği gibi programlama dilleri sade olmalı, basit değil. Bir sistem programlama dilinin <code>String/&amp;str</code> ayrımına ihtiyacı vardır (ödünç alınmışa karşılık sahiplenmiş: kafaya epeyce yatıyor) ve Unikod karakter dizilerini standartlaştırmak için Unikod olmayan stilleri de kapsamalıdırlar - işte <code>OsString/&amp;OsStr</code> kardeşlerin doğuşu. Bunların içeriğinde <code>String</code> benzeri enteresan metotlar bulunmadığına dikkat edin, çünkü tiplemelerinden tam olarak emin değiliz. </p>
<p>Ancak, insanlar dosya isimlerini olağan karakter dizileriymiş gibi işlemeye alışkınlardır ki kolayca dosya konumlarını kullanmak ve değiştirmek için Rust'ta <code>PathBuf</code> vardır.</p>
<p>Bir konumun adresinin parçalarını temizleyebilmek için <code>pop</code> kullanabilirsiniz. Mesela bulunduğumuz dizinden başlayalım.</p>
<pre><pre class="playground"><code class="language-rust">// file8.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        println!(&quot;{}&quot;, path.display());
        if ! path.pop() {
            break;
        }
    }
}
// /home/steve/rust/gentle-intro/code
// /home/steve/rust/gentle-intro
// /home/steve/rust
// /home/steve
// /home
// /</code></pre></pre>
<p>Bu da daha kullanışlı bir hâli. Bir konfigrasyon dosyasını aramak için bir program yazdık ve bütün altdizinleri bu dosya için arıyoruz. Bunun için <code>/home/steve/rust/config.txt</code> diye bir dosya yazdık ve program <code>/home/steve/rust/gentle-intro/code</code> içerisinden başlıyor:</p>
<pre><pre class="playground"><code class="language-rust">// file9.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        path.push(&quot;config.txt&quot;);
        if path.is_file() {
            println!(&quot;gotcha {}&quot;, path.display());
            break;
        } else {
            path.pop();
        }
        if !path.pop() {
            break;
        }
    }
}
// gotcha /home/steve/rust/config.txt</code></pre></pre>
<p>Bu <strong>git</strong>'in nasıl çalıştığı depoyu nasıl bulduğunun yöntemidir de aynı zamanda. </p>
<p>Bir dosya hakkındaki bilgiler <em>metaveri (metadata)</em> olarak geçer. Her zaman olduğu gibi bir hata olabilir - &quot;Bulunamadı&quot; dışında mesela dosyayı okumamız için gerekli izinlere sahip olamayabiliriz.</p>
<pre><pre class="playground"><code class="language-rust">// file10.rs
use std::env;
use std::path::Path;

fn main() {
    let file = env::args().skip(1).next().unwrap_or(&quot;file10.rs&quot;.to_string());
    let path = Path::new(&amp;file);
    match path.metadata() {
        Ok(data) =&gt; {
            println!(&quot;type {:?}&quot;, data.file_type());
            println!(&quot;len {}&quot;, data.len());
            println!(&quot;perm {:?}&quot;, data.permissions());
            println!(&quot;modified {:?}&quot;, data.modified());
        },
        Err(e) =&gt; println!(&quot;error {:?}&quot;, e)
    }
}
// type FileType(FileType { mode: 33204 })
// len 488
// perm Permissions(FilePermissions { mode: 436 })
// modified Ok(SystemTime { tv_sec: 1483866529, tv_nsec: 600495644 })</code></pre></pre>
<p>Bir dosyanın (bayt cinsinden) uzunluğu ve son değiştirilme tarihini bulmak oldukça kolaydır. (Ancak bunu yapamayacağımız zamanlar da vardır.) <code>File</code> tipinin ilgili metotları <code>is_dir</code> (Ç.N: Dizin midir?), <code>is_file</code> (Ç.N: Dosya mıdır?) ve <code>is_symlink</code>'dir. (Ç.N: &quot;Sembolik bağ mıdır?&quot;)</p>
<p><code>permissions</code> da ilginç bir metottur. Rust platformlar arası geçerli olmaya özen gösterir ve bu da bir &quot;en düşük ortak paydaya erişme&quot; durumudur. Genel olarak, dosya salt okunur ise onu sorgulayabilirsiniz - &quot;yetkiler (permissions) konsepti Unix'te oldukça geniştir ve kullanıcı/grup/diğerleri için okuma/yazma/çalıştırma yetkilerini barındırır. </p>
<p>Ancak Windows ile çalışmıyorsanız en azından yetki bitlerini öğrenmek için platforma yönelik özellikleri (trait) kapsama çağırabilirsiniz. (Genelde olduğu gibi özellikler kapsama çağrıldığı zaman etkinleşirler.) Sonrasında da programın dosyasını şöyle değiştirebiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::os::unix::fs::PermissionsExt;
...
println!(&quot;perm {:o}&quot;,data.permissions().mode());
// perm 755
<span class="boring">}</span></code></pre></pre>
<p>(&quot;{:o}&quot; sekizli (octal) sayı sistemine göre biçimlendirir.)</p>
<p>(Windows'ta bir dosyanın çalıştırılıp çalıştırılamayacağı dosyanın uzantısından tanımlanır. Çalıştırılabilir dosya uzantıları <code>PATHEXT</code> çevre değişkeninden öğrenilebilir - &quot;.exe&quot;, &quot;.bat&quot; vs.)</p>
<p>Dosyalarla çalışmak için <code>std::fs</code> bize pek çok faydalı fonksiyonlar sunar, bir dosyayı kopyalayıp taşımak, sembolik bağ kurmak ve dizin oluşturmak gibi.</p>
<p>Bir dizinin içeriğini öğrenmek için bir döngüleyici sunan <code>std::fs::read_dir</code>'i kullanabilirsiniz. İşte karşınızda boyutları 1024 bayttan büyük olan ve uzantısı <code>.rs</code> ile biten bütün dosyalar!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dump_dir(dir: &amp;str) -&gt; io::Result&lt;()&gt; {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let data = entry.metadata()?;
        let path = entry.path();
        if data.is_file() {
            if let Some(ex) = path.extension() {
                if ex == &quot;rs&quot; &amp;&amp; data.len() &gt; 1024 {
                    println!(&quot;{} length {}&quot;, path.display(),data.len());
                }
            }
        }
    }
    Ok(())
}
// ./enum4.rs length 2401
// ./struct7.rs length 1151
// ./sexpr.rs length 7483
// ./struct6.rs length 1359
// ./new-sexpr.rs length 7719
<span class="boring">}</span></code></pre></pre>
<p><code>read_dir</code>'in başarısız olabileceği aşikar (&quot;bulunamadı&quot; ya da &quot;yetki yok&quot; gibi bir hata çıkarabilir) ancak aynı zamanda her yeni bir girdiye erişmek de başarısız olabilir. (Okunmuş veriyi arabelleğe alan <code>lines</code> döngüleyicini düşünün.) Ek olarak, ilgili girdi için uygun metaveriye ulaşamayabiliriz de. Bir dosyanın uzantısı da pekala olmayabilir, bunu ayrıca kontrol etmemiz gerekir.</p>
<p>Neden konumların üzerinde bir döngüleyici kullanmıyoruz? Unix'te <code>opendir</code> sistem çağrısı bu şekilde çalışır ancak Windows'ta dosyaların metaverisini almadan üzerinde bir döngü kuramazsınız. Dolayısıyla platformlar arasındaki kodun en verimli çalışmasının en zarif yoludur. </p>
<p>Bu noktada &quot;hatalarla boğuştuğunuz&quot; için kendinizi bitkin hissedebilirsiniz. Ancak <em>hatalar her zaman</em> vardı - Rust sizin için yeni hatalar icat etmedi. Sadece hataları görmezden gelmemeniz için elinden geleni yapıyor. Herhangi bir işletim sistemi çağrısı başarısız olabilir. </p>
<p>Java ve Python gibi dillerde hata atarsınız (throw exceptions); Go ve Lua gibi diller ise size iki veri döner ve birincisi sonuç ikincisi de hata olur, Rust'ta kitaplık fonksiyonlarının hata oluşturması kötü bir davranış olarak kabul edilir. Bu nedenle pek çok hata denetimi vardır ve fonksiyonlar erkenden dönebilir.</p>
<p>Ya hata alırsınız ya da almazsınız, Rust bu yüzden <code>Result</code> kullanır: hem hata hem de sonuç elde edemezsiniz. Ve soru işareti operatörü kontrol oldukça kolaylaştırır.</p>
<h1 id="süreçler"><a class="header" href="#süreçler">Süreçler</a></h1>
<p>Esas ihtiyaç duyduğumuz şeylerden bir şey programların başka bir programı çalıştırması ya da <em>süreç başlatmaktır</em>. Programınız pek çok alt süreç çalıştırabilir ve alt süreçler üst süreçlerle pek çok ilişkide bulunabilir.</p>
<p>Bir programı, argümanları da beraberinde kullanmanızı sağlayan <code>Command</code> yapısı ile çalıştırabilirsiniz. </p>
<pre><pre class="playground"><code class="language-rust">use std::process::Command;

fn main() {
    let status = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .status()
        .expect(&quot;no rustc?&quot;);

    println!(&quot;cool {} code {}&quot;, status.success(), status.code().unwrap());
}
// rustc 1.15.0-nightly (8f02c429a 2016-12-15)
// cool true code 0</code></pre></pre>
<p><code>new</code> programın adını alır (Eğer kesin bir dosya konumu değilse <code>PATH</code> içinde arar), <code>arg</code> yeni argümanlar ekler ve <code>status</code> programın çalışmasını tetikler. Program çalışınca bir <code>Result</code> alırsınız, <code>Ok</code> programın çalıştığını belirtir ki içeriğinde <code>ExitStatus</code> bulunur. Bizim örneğimizde programımız başarıyla çalıştı ve çıkış değeri olarak 0 döndü. (<code>unwrap</code> kullanmamızın sebebi eğer program bir sinyal ile &quot;öldürülürse&quot; her zaman çıkış değerini öğrenemeyecek olmamız.)</p>
<p>Eğer <code>-V</code>'yi <code>-v</code> ile değiştirirsek <code>rustc</code> başarısız olur.</p>
<pre><code>error: no input filename given

cool false code 101
</code></pre>
<p>Üç farklı koşul gerçekleşebilir:</p>
<ul>
<li>Program var olmayabilir, çalıştırma iznimiz olmayabilir ya da kullanılamaz hâlde olabilir</li>
<li>Program çalışmış ancak başarısız olmamış olabilir - sıfır olmayan çıkış değeri</li>
<li>Program sıfır olan çıkış değeri ile sonuçlanmış olabilir. Yani başarılıdır!</li>
</ul>
<p>Varsayılan olarak programın standart çıktısı (stdout/Standart output) ve standart hata çıktısı (stderr/Standart Error) terminale yönlendirilir.</p>
<p>Bazen çıktıyı yakalamakla da ilgilenebiliriz ki <code>output</code> metotu bu işe yarar.</p>
<pre><pre class="playground"><code class="language-rust">// process2.rs
use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .output()
        .expect(&quot;no rustc?&quot;);

    if output.status.success() {
        println!(&quot;ok!&quot;);
    }
    println!(&quot;len stdout {} stderr {}&quot;, output.stdout.len(), output.stderr.len());
}
// ok!
// len stdout 44 stderr 0</code></pre></pre>
<p><code>status</code> ile alt süreçler sonuçlanana dek programımız durduruluyordu ve üç şey alıyorduk - sonuç (Önceden olduğu gibi), <code>stdout</code>'un ve <code>stderr</code>'un içeriği.</p>
<p>Şimdi ise yakaladığımız çıktı <code>Vec&lt;u8&gt;</code> içerisinde tutuluyor - sadece bayt olarak. İşletim sisteminden aldığımız şeylerin her zaman geçerli bir UTF-8 karakter dizisi olamayacağını hatırlayın. Aslında, bunun bir karakter dizisi <em>bile</em> olamayacağını bilmemiz gerekiyor - programlar tuhaf ikili veriler dönebilirler.</p>
<p>Eğer çıktının UTF-8 olacağından eminsek bu vektörü ya da baytları <code>String::from_utf8</code> ile dönüştürebiliriz. Sonuç <code>Result</code> dönecektir çünkü dönüşümün gerçekleşeceğinden emin değiliz. İşi biraz daha gevşekçe yapan başka bir fonksiyonumuz var, <code>String::from_utf8_lossy</code>, bununla çeviriyi deneyebilir ve dönüştürülemeyen karakterlerin yerlerine � koyabilirsiniz. </p>
<p>Aşağıda kabukta programda çalıştıran kullanışlı bir fonksiyon görmektesiniz. Programımız <code>stderr</code> ile <code>stdout</code>'u birleştirmek için sıradan bir kabuk tekniği kullanıyor. Kabuğun ismi Windows'ta biraz farklı ancak diğerleriyle de sorunsuz çalışacaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let shell = if cfg!(windows) {&quot;cmd.exe&quot;} else {&quot;/bin/sh&quot;};
    let flag = if cfg!(windows) {&quot;/c&quot;} else {&quot;-c&quot;};
    let output = Command::new(shell)
        .arg(flag)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}


fn shell_success(cmd: &amp;str) -&gt; Option&lt;String&gt; {
    let (output,success) = shell(cmd);
    if success {Some(output)} else {None}
}
<span class="boring">}</span></code></pre></pre>
<p>Sağ taraftaki boşlukları biraz törpülüyorum ve böylece <code>shell(&quot;which rustc&quot;)</code> dediğimiz zaman doğrudan konumu alabiliyoruz. </p>
<p><code>Process</code> ile çalıştırılmış bir programın <code>current_dir</code> ile çalışma dizinini, <code>env</code> ile çevre değişkenlerini belirleyerek çalışma şeklini kontrol edebilirsiniz.</p>
<p>Şimdiye kadar programımız alt süreçlerin tamamlanmasını bekledi. Eğer <code>spawn</code> metotunu kullanırsanız program size hemen döner ve programın basitçe bitişini bekler ki bu esnada gidip başka şeyler yapabiliriz. Aşağıdaki örnek <code>stdout</code> ve <code>stderr</code>in de aynı zamanda susturulmasına da örnektir. </p>
<pre><pre class="playground"><code class="language-rust">// process5.rs
use std::process::{Command,Stdio};

fn main() {
    let mut child = Command::new(&quot;rustc&quot;)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
        .expect(&quot;no rustc?&quot;);

    let res = child.wait();
    println!(&quot;res {:?}&quot;, res);
}</code></pre></pre>
<p>Varsayılan olarak alt süreç üst sürecin standart girdisini ve çıktısını &quot;miras alır&quot;. Ancak bu örnekte alt sürecin çıktısını &quot;hiçliğe&quot; yönlendirmiş olduk. Unix kabuğunda <code>&gt; /dev/null 2&gt; /dev/null</code> demekle aynı şey yani.</p>
<p>Rustta yaptığımız bu şeyleri sistem kabuğu (<code>sh</code> veya <code>cmd</code>) ile de yapabilirdik. Ancak bu yolla tamamen programatik bir şekilde süreç oluşturmayı kontrol etmiş oldunuz.</p>
<p>Bu örnekte eğer sadece <code>.stdout(Stdio::piped())</code> kullanmış olsaydık alt sürecin çıktısını bir izole etmiş olurduk. Sonra da <code>child.stdout</code> üzerinden izole ettiğimiz çıktıyı doğrudan okuyabilirdik. (<code>Read</code> özelliğini kullanıyor). Aynı şekilde doğrudan <code>child.stdin</code>'e yazabilmek için de <code>.stdout(Stdio::piped())</code> kullanabilirsiniz.</p>
<p>Ancak <code>wait</code> yerine <code>wait_with_output</code>'u kullansaydık bize <code>Result&lt;Output&gt;</code> dönerdi ve alt sürecin çıktısı <code>Output</code>'un <code>stdout</code> alanında daha önce olduğu gibi <code>Vec&lt;u8&gt;</code> olarak sunulurdu.</p>
<p><code>Child</code> yapısında aynı zamanda aleni bir şekilde <code>kill</code> (öldür) metotu da bulunur.</p>
<p>Ç.N: Alt süreç İngilizce'de &quot;çocuk süreç&quot; anlamına gelen &quot;Child process&quot; olarak bahsedilir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modüller-ve-cargo"><a class="header" href="#modüller-ve-cargo">Modüller ve Cargo</a></h1>
<h1 id="modüller"><a class="header" href="#modüller">Modüller</a></h1>
<p>Programlar büyüdükçe onları bir dosyanın dışına taşımak ve fonksiyonlarla tipleri farklı <em>isim alanlarına (namespace)</em> taşımak gereklidir. Rust'ın bu iki şeye çözümü <em>modüllerdir. (modules)</em></p>
<p>C ile başladı ama C ile bitmedi, bir süre sonra kendinizi <code>primitive_display_set_width</code> gibi rezilce isimler koyarken bulabilirsiniz. Sadece dosya isimlerini keyfinizce isimlendirebiliyorsunuz. </p>
<p>Rust'ta aynı şeyi <code>primitive::display::set_width</code> şeklinde isimlendirebiliyorsunuz. Üstelik <code>use primitive::display</code> kullandıktan sonra bunu kısaca <code>display::set_width</code> olarak çağırabilirsiniz. Hatta <code>use primitive::display::set_width</code> dedikten sonra onu doğrudan <code>set_width</code> diye çağırabilirsiniz fakat nasıl kullandığınıza dikkat etmelisiniz. <code>rustc</code> tarafında sorun olmaz ancak sizin kafanız karışabilir. Ancak, bu sistemin çalışabilmesi için dosya isimlerinin basit bir kaç kurala bakması gereklidir.</p>
<p>Yeni bir anahtar kelimemiz var, <code>mod</code>, bir bloğu içine yazılan tip ve fonksiyonlarla beraber topyekûn modül olarak ilan etmeye yarar.</p>
<pre><pre class="playground"><code class="language-rust">mod foo {
    #[derive(Debug)]
    struct Foo {
        s: &amp;'static str
    }
}

fn main() {
    let f = foo::Foo{s: &quot;hello&quot;};
    println!(&quot;{:?}&quot;, f);
}</code></pre></pre>
<p>Ancak bu çalışmayacaktır - &quot;Foo yapısı gizlidir (struct Foo is private)&quot; diye bir hata alacağız. Bunu çözmek için <code>pub</code> anahtar kelimesi aracılığıyla <code>Foo</code>'yu görünür kılmalıyız. Sonra bu hata &quot;foo::Foo yapısının s alanı gizlidir (field s of struct foo::Foo is private)&quot; olacaktır, <code>pub</code> anahtar kelimesini alanın başına eklemeliyiz ki <code>Foo::s</code> de görünür olsun. Sonra güzelinden çalışacaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct Foo {
        pub s: &amp;'static str
    }
<span class="boring">}</span></code></pre></pre>
<p>Bir alanı açıkça <code>pub</code> olarak belirmek bir modulün içerisinden neyin ulaşılabilir olduğunu <em>seçmek</em> demektir. Bir modülün içerisindeki erişebilen tiplere ve fonksiyonlara modulün <em>arayüzü (interface)</em> denir.</p>
<p>Bir yapının içindekileri gizlemek ve erişimi metotlarla sağlamak çoğunlukla doğru bir tercihtir.</p>
<pre><pre class="playground"><code class="language-rust">mod foo {
    #[derive(Debug)]
    pub struct Foo {
        s: &amp;'static str
    }

    impl Foo {
        pub fn new(s: &amp;'static str) -&gt; Foo {
            Foo{s: s}
        }
    }
}

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}</code></pre></pre>
<p>Neden bu yapıları gizlemek daha iyidir? Çünkü arayüzün canına okumadan ve modüle erişen diğer parçaların ayrıntılarıyla boğuşmadan onu değişebilirsiniz. Geniş ölçekli bir programın en büyük belası kodun birbirine girmeye olan meyilidir ki kodun gerekli parçasını izole etmeyi imkansız hâle getirir bu.</p>
<p>Cesur yeni dünyada modüller tek bir şeyi yapar ve kendi sırlarını kendilerine saklarlar.</p>
<p>Peki ne zaman gizlememeliyiz? Stroustrup'ın dediği gibi arayüzün kendisi kullanıldığı zaman, mesela <code>struct Point{x: f32, y: f32}</code>. </p>
<p>Bir modülün içinde bütün nesneler birbirine görünürler. Burada herkesin birbirini tanıdığı ve sırlarını bildiği bir mahalle yaşantısı vardır. </p>
<p>Herkesin programı çeşitli dosyalara ayırmaya başladığı bir sınırı vardır. Ben mesela 500 satıra geldiğimde bunu düşünmeye başlıyorum ancak hepimiz 2000 satırdan sonra sıkılırız.</p>
<p>Peki ya bir programı çeşitli dosyalara nasıl ayırırız?</p>
<p><code>foo</code> kodunu <code>foo.rs</code> içine koyalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo.rs
#[derive(Debug)]
pub struct Foo {
    s: &amp;'static str
}

impl Foo {
    pub fn new(s: &amp;'static str) -&gt; Foo {
        Foo{s: s}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ve sonra da ana dosyada <code>mod foo</code> deyimini bir blok olmadan kullanalım.</p>
<pre><pre class="playground"><code class="language-rust">// mod3.rs
mod foo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}</code></pre></pre>
<p>Şimdi <code>rustc mod3.rs</code> komutu herhangi bir hata olmadan derlenecektir. &quot;Makefile&quot;lar ile boğuşmaya hiç ihtiyacımız yok!</p>
<p>Ç.N: Makefile çoğunlukla C ve C++ ile kullanılan ancak Crystal, Go gibi yüksek seviye dillerde bile tercih edilen bir dosya. İşlevi birden çok kod dosyasını bir araya getirmek, onu yönetmektir. </p>
<p>Derleyici aynı zamanda <code>MODULADI/mod.rs</code> içine de bakacaktır, mesela ben <code>boo</code> isminde bir dizin açıp içerisine <code>mod.rs</code> diye bir dosya yerleştirebilirim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}
<span class="boring">}</span></code></pre></pre>
<p>Ana dosya bunu farklı bir dosyadaki farklı bir modül olarak tanımlayacaktır:</p>
<pre><pre class="playground"><code class="language-rust">// mod3.rs
mod foo;
mod boo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    let res = boo::answer();
    println!(&quot;{:?} {}&quot;, f,res);
}</code></pre></pre>
<p>Şu ana kadar içinde <code>main</code>  fonksiyonu olan bir <code>mod3.rs</code> dosyamızla beraber <code>boo/mod.rs</code> dosyamız da vardır ki diğer modüller bunu <code>boo</code> olarak görür. Genel alışkanlık, <code>main</code> fonksiyonunu barındıran dosyanın adını <code>main.rs</code> yapmaktır.</p>
<p>Neden bir şeyi yapmanın iki farklı yolu var? Çünkü <code>boo/mod.rs</code> aracılığıyla <code>boo</code> içerisinde yeni modüller tanımlayabilirsiniz. <code>boo/mod.rs</code>'yi değiştirelim ve yeni bir modül ekleyelim - bunu dışarıdan erişilebilir olmasına dikkat edin. (<code>pub</code> olmazsa <code>bar</code>a sadece <code>boo</code> modülü içerisinden erişebilirsiniz.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar {
    pub fn question() -&gt; &amp;'static str {
        &quot;the meaning of everything&quot;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ç.N: Question: Soru, Answer: Cevap</p>
<p>Şimdi, cevabımızı anlamlandıracak bir sorumuz var. (<code>bar</code> modülü, <code>boo</code>'nun içindedir.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let q = boo::bar::question();
<span class="boring">}</span></code></pre></pre>
<p>Dilersek modül bloğunu <code>boo/bar.rs</code> altına taşıyabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// boo/bar.rs
pub fn question() -&gt; &amp;'static str {
    &quot;the meaning of everything&quot;
}
<span class="boring">}</span></code></pre></pre>
<p>Ve <code>boo/mod.rs</code> şuna dönüşür:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar;
<span class="boring">}</span></code></pre></pre>
<p>Sonuç olarak modüller organizasyon ve erişilebilirlikle alakalı ve tercihen başka dosyalara erişebilir.</p>
<p>Lütfen <code>use</code>'ın herhangi bir içe aktarma işleminde kullanılmadığını ve kısayol oluşturduğumuza not edin. Örneğin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    use boo::bar;
    let q = bar::question();
    ...
}
{
    use boo::bar::question();
    let q = question();
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Bir başka önemli nokta ise Rust'ta <em>parçalı derleme</em> işlemlerinin bulunmamasıdır. Ana program ve onun modül dosyaları sil baştan yeniden derlenir. Büyük programların derlenme süresini kayda değer bir sürede uzatır, <code>rustc</code> zaman içerisinde artımlı derlemede iyileşmesine rağmen.</p>
<h1 id="sandıklar"><a class="header" href="#sandıklar">Sandıklar</a></h1>
<blockquote>
<p><em>Ç.N: Crate kelimesinin yaygınlığından ötürü &quot;sandık&quot; ya da &quot;crate&quot; arasında aklımda uzunca bir süre düşündüm. Çünkü bu genel programlamaya ait bir kelime değil, Rust terminolojisinin bir parçası ki bu da onu çevrilmemesi gereken bir özel isim yapar. Ancak &quot;Sandık&quot; kelimesi gerçekten mantığa uygun ve &quot;Sandık&quot; olarak düşünmenin hiçbir zararı yok. &quot;Crate&quot; diyerek geçseydim, İngilizce bilmeyen kişiler için bunu salt ezberlenmesi gereken, anlamsız bir kelimeye dönüştürürdüm.</em></p>
</blockquote>
<p>&quot;Her bir derleme parçasına&quot; <em>sandık (crate)</em> denir ki bu bir kütüphane veyahut çalıştırılabilir bir dosya olabilir. </p>
<p>Geçen bölümdeki dosyaları hep birlikte değil de ayrıca derlemek için, önce <code>foo.rs</code>'ı bir <em>statik kütüphane sandığına</em> çevirelim.</p>
<pre><code>src$ rustc foo.rs --crate-type=lib
src$ ls -l libfoo.rlib
-rw-rw-r-- 1 steve steve 7888 Jan  5 13:35 libfoo.rlib
</code></pre>
<p>Şimdi bunu bizim ana programımıza <em>ilişkilendirebiliriz. (linking)</em></p>
<pre><code>src$ rustc mod4.rs --extern foo=libfoo.rlib
</code></pre>
<p>Ana programımızın bu yeni yapıya uyum sağlaması gerekmektedir, <code>extern</code> (Dışsal) ile kullandığımız isim ilişkilendirdiğimiz zaman kullandığımız isimle aynı olmalıdır. Yeni kütüphanemiz artık <code>foo</code> modülü aracılığıyla görünür olacaktır:</p>
<pre><pre class="playground"><code class="language-rust">// mod4.rs
extern crate foo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}</code></pre></pre>
<p>İnsanlar &quot;Cargo! Cargo!&quot; diye zikre başlamadan önce Rust'ın inşa araçlarını neden bu kadar düşük seviyeden gösterdiğini anlatmam için bana izin verin. Ben &quot;Aletlerin Fıkhı&quot;na dahilim ve bunları bilmek sizin Cargo ile yeni projeler yönetirken daha az &quot;sinir&quot;le karşılaşmanızı sağlar. Modüller basit dil işlevleridir ve Cargo olmadan da kullabilirler.</p>
<p>Şimdi, Rust'ın çalıştırılabilir dosyaları neden bu kadar büyük onu anlayalım:</p>
<pre><code>src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 3,4M Jan  5 13:39 mod4

</code></pre>
<p>Yarım dünya olmuş! Aslında bu çalıştırılabilir dosyada <em>pek çok</em> hata ayıklama bilgisi bulunur. Eğer niyetiniz bir hata ayıklayıcı kullanmaksa ve program paniklediği zaman anlamlı geri dönüşler almak istiyorsanız bu kötü bir şey değildir.</p>
<p>Hata ayıklama bilgisini silelim ve bir de böyle bakalım:</p>
<pre><code>src$ strip mod4
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 300K Jan  5 13:49 mod4
</code></pre>
<p>Yine de basit bir şey için büyük bir dosya olduğunu düşünebilirsiniz ancak bu program Rust'ın standart kütüphanesine <em>statik</em> linklenmiştir. Bu iyi bir şey, bu programı doğru işletim sistemini kullanan herkesle paylaşabilirsiniz - Rust ile ilişkili hiçbir araca ihtiyaçları yoktur. (<code>rustup</code> sayesinde farklı işletim sistemlerine ve platformlara derleyebilirsiniz.)</p>
<p>Rust'ın kütüphanelerine dinamik linkleyebiliriz ki bu koşulda gerçekten küçük çalıştırılabilir dosyalar elde ederiz.</p>
<pre><code>src$ rustc -C prefer-dynamic mod4.rs --extern foo=libfoo.rlib
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 14K Jan  5 13:53 mod4
src$ ldd mod4
    linux-vdso.so.1 =&gt;  (0x00007fffa8746000)
    libstd-b4054fae3db32020.so =&gt; not found
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3cd47aa000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f3cd4d72000)
</code></pre>
<p>&quot;not found (bulunamadı)&quot; çıktısının sebebi <code>rustup</code>'ın dinamik kütüphanelerinin sistem çapında kurulamamış olması. En azından Unix'te şöyle bir şey yapabiliriz. (Sembolik bağların en iyi çözüm olduğunu ben de biliyorum.)</p>
<pre><code>src$ export LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib
src$ ./mod4
Foo { s: &quot;hello&quot; }
</code></pre>
<p><em>Teorik olarak</em> Rust'ın dinamik linklemeyle ilgili herhangi bir sorunu yok, tıpkı Go gibi. Sadece her altı haftada yeni bir stabil sürüm yayınlandığı için her şeyi tekrar tekrar derlemek biraz tuhaf kaçacaktır. Eğer her şeyin sizin için uygun olacağı bir stabil sürüm bulursanız, bunda sorun olmayacaktır. İşletim sistemlerinin paket yöneticileri Rust'ın standart kütüphanelerini sunmaya başlayacağı zaman dinamik linkleme daha popüler olacaktır.</p>
<h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p>Java veya Python ile kıyaslarsanız Rust'ın standart kütüphanesi o kadar da büyük değildir, tabii yine de çoğu şeyini işletim sistemi kütüphanelerinden alan C ve C++'dan daha fazla şey bulursunuz.</p>
<p>Bu durumu telafi etmek için <strong>Cargo</strong> aracılığı ile <a href="https://crates.io">crates.io</a>'da yayınlanan topluluk kütüphanelerine ulaşabilirsiniz. Cargo sizin için doğru sürümü arayacak, kaynağı indirecek ve diğer bağımlılıkların kurulduğunu da kontrol edecektir. </p>
<p>JSON okuyan basit bir program yapalım. Bu veri formatı yaygın olarak kullanılır ancak standart kütüphaneye eklenemeyecek kadar da karmaşıktır. Bundan ötürü yeni bir Cargo projesi açıyoruz, &quot;--bin&quot; de ekliyoruz ki çalıştırılabilir bir proje yapalım yoksa kütüphane projesi hazırlar.</p>
<p>Ç.N: Hayır hazırlamaz. Çevrilen belgenin eskiliğinden dolayı böyle bahsetmiş. Varsayılan davranış çalıştırılabilir proje hazırlamaktır, kütüphanesi projesi başlatmak için <code>--lib</code> kullanmanız gerekir. Yine de <code>--bin</code> kullanabilirsiniz ancak buna gerek yoktur. Bu arada bahsi geçen JSON sandığı bu yazının yazıldığı tarihe (8 şubat 2022) iki yıldır güncellenmemiş görünmektedir. Rust'ta kullanılan esas JSON çözümü <a href="https://crates.io/crates/serde_json">serde_json sandığıdır.</a> Yazının devamını okuyabilirsiniz çünkü <code>serde_json</code> ve <code>json</code> sandıkları arasında pratikte pek fark yoktur. Kaldı ki bu bölümün ardından yazar <code>serde_json</code>'u inceliyor.</p>
<pre><code>test$ cargo init --bin test-json
     Created binary (application) project
test$ cd test-json
test$ cat Cargo.toml
[package]
name = &quot;test-json&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.org&gt;&quot;]

[dependencies]
</code></pre>
<p><a href="https://github.com/maciejhirsz/json-rust">JSON sandığını</a> kullanan bir proje yapmak için &quot;Cargo.toml&quot; dosyasını düzenleyin:</p>
<pre><code>[dependencies]
json=&quot;0.11.4&quot;
</code></pre>
<p>Sonra Cargo ile ilk derlememizi yapalım:</p>
<pre><code>test-json$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading json v0.11.4
   Compiling json v0.11.4
   Compiling test-json v0.1.0 (file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s) in 1.75 secs
</code></pre>
<p>Programımızın <code>main</code> dosyası hâlihazırda oluşturdu - &quot;src&quot; dizinindeki &quot;main.rs&quot; dosyasıdır. Şimdilik henüz &quot;hello world&quot; çıktısı vermekten başka bir şeye yaramıyor, hadi onu doğru düzgün bir test programına çevirelim.</p>
<p>&quot;raw&quot; karakter dizesinin nasıl kullanıldığına da dikkat edin - eğer kullanmasaydık kaçış dizelerini kullanmamız gerekirdi ki bu bayağı bir çirkinliğe sebep olurdu:</p>
<pre><pre class="playground"><code class="language-rust">// test-json/src/main.rs
extern crate json;

fn main() {
    let doc = json::parse(r#&quot;
    {
        &quot;code&quot;: 200,
        &quot;success&quot;: true,
        &quot;payload&quot;: {
            &quot;features&quot;: [
                &quot;awesome&quot;,
                &quot;easyAPI&quot;,
                &quot;lowLearningCurve&quot;
            ]
        }
    }
    &quot;#).expect(&quot;parse failed&quot;);

    println!(&quot;debug {:?}&quot;, doc);
    println!(&quot;display {}&quot;, doc);
}</code></pre></pre>
<p>Ç.N: Cargo aracılığıyla kurduğunuz sandıkların &quot;extern crate <em>sandık_adı</em>&quot; şeklinde çağrılmasına gerek yoktur. </p>
<p>Şimdi projeyi inşa edip çalıştırabilir - sadece <code>main.rs</code> değişti.</p>
<pre><code>test-json$ cargo run
   Compiling test-json v0.1.0 (file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s) in 0.21 secs
     Running `target/debug/test-json`
debug Object(Object { store: [(&quot;code&quot;, Number(Number { category: 1, exponent: 0, mantissa: 200 }),
 0, 1), (&quot;success&quot;, Boolean(true), 0, 2), (&quot;payload&quot;, Object(Object { store: [(&quot;features&quot;,
 Array([Short(&quot;awesome&quot;), Short(&quot;easyAPI&quot;), Short(&quot;lowLearningCurve&quot;)]), 0, 0)] }), 0, 0)] })
display {&quot;code&quot;:200,&quot;success&quot;:true,&quot;payload&quot;:{&quot;features&quot;:[&quot;awesome&quot;,&quot;easyAPI&quot;,&quot;lowLearningCurve&quot;]}}
</code></pre>
<p>Hata ayıklama çıktısı JSON belgesi hakkında bazı iç detayları sundu ancak <code>Display</code> özelliğini kullanan sade <code>{}</code> bizim için taranmış JSON'u döner.</p>
<p>Şimdi JSON API'sini keşfe çıkalım. Eğer verileri dışarı çıkartamasaydık bunun pek anlamı olmazdı. <code>as_TİP</code> metotu bize <code>Option&lt;TİP&gt;</code> döner, bunun nedeni belirtilen alanın varlığı kesin değildir ve doğru tipe çevirmeyebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let code = doc[&quot;code&quot;].as_u32().unwrap_or(0);
    let success = doc[&quot;success&quot;].as_bool().unwrap_or(false);

    assert_eq!(code, 200);
    assert_eq!(success, true);

    let features = &amp;doc[&quot;payload&quot;][&quot;features&quot;];
    for v in features.members() {
        println!(&quot;{}&quot;, v.as_str().unwrap()); // MIGHT explode
    }
    // awesome
    // easyAPI
    // lowLearningCurve
<span class="boring">}</span></code></pre></pre>
<p><code>features</code>, <code>JsonValue</code> tipine bir referanstır - referans olması gerekir çünkü <em>veriyi</em> JSON dökümanı dışına taşımış oluruz. Ayrıca bir tür dizi olduğunu bildiğimiz için <code>members()</code> bize <code>&amp;JsonValue</code> üzerinde çalışan dolu bir döngüleyici dönecektir. </p>
<p>Ya eğer &quot;payload&quot;'ın &quot;features&quot; diye bir anahtarı olmasaydı? O zaman <code>features</code> bir <code>Null</code> olurdu, elimizde patlamazdı. Bu yaklaşım biraz serbestlik tanıyor ki bu JSON'un gevşek doğasına da pekâlâ uyuyor. Belgenin yapısını incelemek ve yapı uyuşmazsa hataları idare etmek size kalmış.</p>
<p>Bu yapıları düzenleyebilirsiniz. Eğer <code>let mut doc</code> diye tanımlasaydık pekâlâ bunu yapabilirdik:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let features = &amp;mut doc[&quot;payload&quot;][&quot;features&quot;];
    features.push(&quot;cargo!&quot;).expect(&quot;couldn't push&quot;);
<span class="boring">}</span></code></pre></pre>
<p><code>push</code> başarısız olabilir çünkü <code>features</code> bir dizi olmayabilir, bundan ötürü <code>Result&lt;()&gt;</code> döner.</p>
<p><em>JSON kalıplarını</em> kullanmak için gerçekten şık bir makromuz da var:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let data = object!{
        &quot;name&quot;    =&gt; &quot;John Doe&quot;,
        &quot;age&quot;     =&gt; 30,
        &quot;numbers&quot; =&gt; array![10,53,553]
    };
    assert_eq!(
        data.dump(),
        r#&quot;{&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30,&quot;numbers&quot;:[10,53,553]}&quot;#
    );
<span class="boring">}</span></code></pre></pre>
<p>Bunun çalışabilmesi için makroları JSON sandığından açıkça içe aktarmanız gerekir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate json;
<span class="boring">}</span></code></pre></pre>
<p>Bu sandığın kötü bir tarafı da var, o da JSON'un dengesiz ve dinamik tipli doğasını Rust'ın statik ve yapılandırmış doğası arasında uyumsuzluğu dengeleyememiş olması. (&quot;Readme&quot; dosyasında bu sürtüşmeden (&quot;friction&quot;) söz eder.) Eğer JSON'u Rust'ın veri yapılarına çevirmek isterseniz en sonunda pek çok düzenleme yapmanız gerekir çünkü elde ettiğiniz veriyi yapılarınıza uyacağınızdan emin olamazsınız! Bunun üstesinden gelebilmek için <a href="https://github.com/serde-rs/json">serde_json</a> kullanabilirsiniz, bununla Rust veri yapılarınızı JSON'a <em>serileştirebilir/çevirebilir (serialize)</em> ya da JSON'dan Rust'a <em>serisizleştirebilirsiniz/geri çevirebilirsiniz. (deserialize)</em></p>
<p>Ç.N: &quot;Muvaffakiyetsizleştiricileştiriveremeyebileceklerimizdenmişsinizcesine&quot; gibi bir karmaşa yarattığımın farkındayım. Bundan dolayı bazı yerlerde <em>serialize</em> ve <em>deserialize</em> için <em>çevirmek</em> karşılığını kullanacağım. </p>
<p>Bunun için <code>cargo new --bin test-serde-json</code> ile çalıştırılabilir bir Cargo projesi başlatalım ve <code>test-serde-json</code> dizinine girip <code>Cargo.toml'u</code> değiştirelim. Buna benzer bir şey yapabiliriz:</p>
<pre><code>[dependencies]
serde=&quot;0.9&quot;
serde_derive=&quot;0.9&quot;
serde_json=&quot;0.9&quot;
</code></pre>
<p><code>src/main.rs</code>'yi şu şekilde dolduralım:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate serde_derive;
extern crate serde_json;

#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u8,
    address: Address,
    phones: Vec&lt;String&gt;,
}

#[derive(Serialize, Deserialize, Debug)]
struct Address {
    street: String,
    city: String,
}

fn main() {
    let data = r#&quot; {
     &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 43,
     &quot;address&quot;: {&quot;street&quot;: &quot;main&quot;, &quot;city&quot;:&quot;Downtown&quot;},
     &quot;phones&quot;:[&quot;27726550023&quot;]
    } &quot;#;
    let p: Person = serde_json::from_str(data).expect(&quot;deserialize error&quot;);
    println!(&quot;Please call {} at the number {}&quot;, p.name, p.phones[0]);

    println!(&quot;{:#?}&quot;,p);
}</code></pre></pre>
<p><code>derive</code> özelliğini daha çok görünüz ancak <code>serde_derive</code> sandığı içerisinde <code>Serialize</code> ve <code>Deserialize</code> gibi önemli özellikleri içeren <code>derive</code>lar bulunmaktadır. Sonuç, oluşturulan Rust yapısını gösterecektir:</p>
<pre><code>Please call John Doe at the number 27726550023
Person {
    name: &quot;John Doe&quot;,
    age: 43,
    address: Address {
        street: &quot;main&quot;,
        city: &quot;Downtown&quot;
    },
    phones: [
        &quot;27726550023&quot;
    ]
}
</code></pre>
<p>Eğer bunu <code>json</code> sandığı ile yapsaydınız pek çok satırda çoğu hata yönetimiyle ilişkili birkaç yüz tanecik çeviri kodu yazmanız gerekecekti. Bunaltıcı, batırması bir hataya bakar ve bunun için oturup uğraşmak anlamsız. </p>
<p>Eğer dışarıdan gelen iyi yapılandırılmış JSON'u işleyecekseniz (gerekirse alanları yeniden isimlendirebilirsiniz) ve başka programlarla ağ üzerinden veri paylaşacaksanız (Şu günlerde JSON'u herkes anlıyor) bu bariz en iyi çözümdür. <code>serde</code> (&quot;SERialization DEserialization&quot;) hakkındaki ilgi çeken bir nokta diğer dosya türlerini de desteklemesidir, mesela Cargo'da kullanılan yapılandırması kolay ve popüler <code>toml</code> da bunlardan birisidir. Eğer programınızın .toml dosyalarını yapılara çevirmesi gerekiyorsa bu tıpkı .json dosyalarında yaptığınız gibi bu yapıları hazırlayabilirsiniz.</p>
<p>Serileştirme, Java ve Go'da da benzerleri bulunan önemli bir tekniktir - ancak büyük bir fark vardır. Bu dillerde verinin yapısı çalışma zamanında <em>yansıma (reflection)</em> kullanılarak bulunur. Ancak bu koşulda serileştirme işlemi <em>çalışma zamanında</em> oluşturulur - bu çok daha verimlidir.</p>
<p>Cargo, Rust ekosisteminin ağır toplarından birisidir çünkü bizim için çok fazla işi halleder. Eğer o olmasaydı Github'dan tek tek kütüphaneleri indirmek, statik kütüphaneler olarak inşa etmek ve programa ilişkilendirmemiz gerekirdi. Bunu C++ projelerinde yapmak çiledir ve aynı çile Cargo olmasaydı Rust projelerinde de olacaktır. C++'ın çektirdiği çilenin eşi benzeri de yoktur bu arada, o yüzden diğer dillerin paket yöneticileriyle kıyaslamamız daha doğru olacaktır. (JavaScript için) npm, (Python için) pip sizin için bağımlılıkları kontrol eder ve indirir ancak programı dağıtmak zordur çünkü kullanıcının da sizin yerine NodeJS ve Python kurmuş olması gerekir. Ancak Rust programın bağımlılıkları statik linklenmiştir, ek bir bağımlılık gerekmeksizin istediğiniz kişiye yollayabilirsiniz.</p>
<h1 id="vali-kebabı"><a class="header" href="#vali-kebabı">Vali Kebabı</a></h1>
<p>Basit bir yazının dışında herhangi bir veriyi işleme alacaksanız düzenli ifadeler (<strong>reg</strong>ular <strong>ex</strong>pressions) hayatınızı kolaylaştıracaktır. Bunlar pek çok dilde vardır ve sizin temel regex kalıplarına aşina olduğunuzu varsayıyorum. <a href="https://github.com/rust-lang/regex">regex</a> sandığını kullanmak için Cargo.toml dosyasına &quot;[dependencies]&quot; altına 'regex = &quot;0.2.1&quot;' ifadesini koymanız yererlidir.</p>
<p>Terk eğik çizgilerin özel anlamlar yaratmaması için &quot;çiğ/raw karakter dizilerini&quot; kullanacağım. İnsanın anlayacağı şekilde anlatırsak aşağıdaki düzenli ifade &quot; ':' karakterinden önce iki rakam, sonrasında da herhangi uzunluktaki bir rakamı alın&quot; anlamına gelmektedir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate regex;
use regex::Regex;

let re = Regex::new(r&quot;(\d{2}):(\d+)&quot;).unwrap();
println!(&quot;{:?}&quot;, re.captures(&quot;  10:230&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;[22:2]&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;10:x23&quot;));
// Some(Captures({0: Some(&quot;10:230&quot;), 1: Some(&quot;10&quot;), 2: Some(&quot;230&quot;)}))
// Some(Captures({0: Some(&quot;22:2&quot;), 1: Some(&quot;22&quot;), 2: Some(&quot;2&quot;)}))
// None
<span class="boring">}</span></code></pre></pre>
<p>Başarılı bir çıktı üç parçadan oluşur - bütün eşleşme ile iki parça olarak sayılar. Düzenli ifadeler genel varsayılan olarak <em>mıhlanmamıştır (anchored)</em>, yani <strong>regex</strong> ifademiz ilk eşleşmeyi arayacak ve gerisine bakmayacaktır. (Eğer sadece &quot;()&quot; olarak bir düzenli ifade yazarsanız her şeyle eşleşecektir.)</p>
<p>Bu eşleşmeleri <em>isimlendirebiliriz</em> ve düzenli ifadeleri birden fazla satır hâlinde yazabiliriz, satırları da içine alacak şekilde. Mesela burada sonucu ilişkisel bir dizi olarak kullanabiliriz ve eşleşmeleri isme göre arayabiliriz. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let re = Regex::new(r&quot;(?x)
(?P&lt;year&gt;\d{4})  # the year
-
(?P&lt;month&gt;\d{2}) # the month
-
(?P&lt;day&gt;\d{2})   # the day
&quot;).expect(&quot;bad regex&quot;);
let caps = re.captures(&quot;2010-03-14&quot;).expect(&quot;match failed&quot;);

assert_eq!(&quot;2010&quot;, &amp;caps[&quot;year&quot;]);
assert_eq!(&quot;03&quot;, &amp;caps[&quot;month&quot;]);
assert_eq!(&quot;14&quot;, &amp;caps[&quot;day&quot;]);
<span class="boring">}</span></code></pre></pre>
<p>Düzenli ifadeler karakter dizilerini örüntü eşleştirmelere göre bölebilir ancak ne anlama geldiğini anlayamaz. Mesela ISO-tarzı bir sözdizimini belirtip eşleşeyebilirsiniz, ancak <em>anlamsal</em> olarak saçma sapan şeylere işaret edebilirler. Mesela ki &quot;2014-24-52&quot;.</p>
<p>Bu koşulda ayrıca tarih-zaman işlemeye ihtiyacınız olabilir, bu bize <a href="https://github.com/lifthrasiir/rust-chrono">chrono</a> tarafından sunulur. Tarihleri üretirken zaman dilimini belirtmeniz de gerekebilir:</p>
<pre><pre class="playground"><code class="language-rust">extern crate chrono;
use chrono::*;

fn main() {
    let date = Local.ymd(2010,3,14);
    println!(&quot;date was {}&quot;, date);
}
// date was 2010-03-14+02:00</code></pre></pre>
<p>Ancak bu tarz kullanımda kötü tarihler şuna sebep olabilir: panik! (Mesela sahte bir tarih kullanmayı deneyebilirsiniz.) Esas ihtiyacınız olan metot <code>ymd_opt</code>'dir ki size <code>LocalResult&lt;Date&gt;</code> döner.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let date = Local.ymd_opt(2010,3,14);
    println!(&quot;date was {:?}&quot;, date);
    // date was Single(2010-03-14+02:00)

    let date = Local.ymd_opt(2014,24,52);
    println!(&quot;date was {:?}&quot;, date);
    // date was None
<span class="boring">}</span></code></pre></pre>
<p>Doğrudan tarihi ve zamanı tarayabilirsiniz, standart UTC biçiminde ya da farklı  <a href="https://lifthrasiir.github.io/rust-chrono/chrono/format/strftime/index.html#specifiers">biçimler</a>'da olabilir. Bu hemen hemen aynı formatlar istediğiniz tarzda biçimlendirmenize yardımcı olur.</p>
<p>Bu iki sandıktan özellikle bahsettiğm çünkü normalde bunlar diğer dillerde standart kütüphanenin birer parçasıdır. Ve üstelik bu kütüphanelerin çok çok ilkel bir tipi aslında Rust'ın standart kütüphanesinin parçasıydı, ancak ayrıştırıldı. Bu bilinçli bir karardı, Rust takımı standart kütüphanenin kararlılığını oldukça ciddiye alıyor ve ekleyecekleri yeni özellikleri önce kararsız &quot;nightly&quot; yayınında sonra yarı kararlı &quot;beta&quot; yayınında test ederler ve en sonunda &quot;stable&quot; yayınına alırlar. Pek çok deneyim ve iyileştirme gereken kütüphaneleri bağımsız olarak geliştirmek ve Cargo ile erişilir kılmak çok daha iyidir. Sonuca bakarsak, bu iki sandık standart<em>tır</em> - tekrardan standart kütüphaneye alınmayacaktır ve ortadan kaybolmayacaklardır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standart-kütüphane-konteynırları"><a class="header" href="#standart-kütüphane-konteynırları">Standart Kütüphane Konteynırları</a></h1>
<h1 id="belgeleri-anlamak"><a class="header" href="#belgeleri-anlamak">Belgeleri Anlamak</a></h1>
<p>Bu kısımda kabaca size Rust'ın standart kütüphanesinin bilindik bazı kısımlarını tanıtacağım. Belgelendirme gayet iyi ancak bağlamı tanıtmak ve biraz örneğin kimseye zararı olmaz.</p>
<p>Hepsinden önce Rust belgelerini okumak biraz yorucu gelebilir, bundan dolayı bir örneği inceleyeceğiz ki bu örnek <code>Vec</code> olacak. Kullanışlı bir tavsiye verelim, &quot;[-]&quot; belgeleri açıp kapamaya yarar. (Eğer <code>rustup component add rust-src</code> ile belgeleri indirmişseniz yanında bir de &quot;[src]&quot; bağlantısını göreceksiniz. Metotların bir krokisine buradan ulaşabilirsiniz. </p>
<p>Dikkat etmeniz gereken ilk detay, bütün ilişkili metotların <code>Vec</code>'in kendisinde tanımlanmadığıdır. Bunlar (çoğunlukla) <code>push</code> gibi vektörü değiştiren metotlardır. Bazı metotlar ise sadece vektörlerin içinde tuttuğu tiplere göre değişkenlik gösterir. Mesela, <code>dedup</code>'ı (kopyaları kaldır) sadece eşitliği denetlenebilir tipler üzerinde çalışır. <code>Vec</code> tipinde kullanılan birden fazla <code>impl</code> bloğu vardır ki bunlar içinde bulunduğu tiplerin çeşitliliğine göre şekillenmiştir.</p>
<p><code>Vec&lt;T&gt;</code> ile <code>&amp;[T]</code> arasında da özel bir ilişki olduğunu biliyoruz. Dilimler üzerinde çlışan her bir metot vektörler üzerinde doğrudan çalışacaktır, fazladan <code>as_slice</code> gibi metotlar kullanmanıza hiç gerek yoktur. Bu ilişki <code>Deref&lt;Target=[T]&gt;</code> ile gösterilir. Ayrıca bir vektörü referans olarak göstermek onu bir dilime çevirir - tip dönüşümlerinin nadiren gerçekleştiği nadir yerlerden birisidir. İlk öğeyi geri dönen <code>first</code> gibi dilim metotları, ya da bunun tersini yapan <code>last</code>, vektörler için de kullanılabilir. Metotların pek ciddi bir kısmı karakter dizilerini çağrıştırabilir, mesela <code>split_at</code> dilimi belirli bir indekse göre ayırır, <code>starts_with</code> bir vektörün belirli bir veri silsilesi ile başlayıp başlamadığını belirtir, <code>contains</code> bir vektörün belirli bir veriyi içerip içermediğini belirtir.</p>
<p>Belirli bir verinin indeksini bulmak için Rust'ta <code>search</code> metotu yoktur. Şimdi size size esas olayı anlatayım; eğer konteynırda metotu bulamazsanız, döngüleyici metotlarına bakın:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = vec![10,20,30,40,50];
    assert_eq!(v.iter().position(|&amp;i| i == 30).unwrap(), 2);
<span class="boring">}</span></code></pre></pre>
<p>( <code>&amp;</code> kullanmamızın sebebi döngüleyicinin referanslar üzerinde çalışmasıdır - alternatif olarak kıyaslamak için <code>*i == 30</code> kullanabilirsiniz.)</p>
<p>Benzer şekilde vektörler üzerinde <code>map</code> metotu yoktur çünkü <code>iter().map(...).collect</code> ile aynı pekâlâ işi yapabilirsiniz. Rust, gerekmedikçe bellek tahsis etmeyi sevmez - çoğu zaman hâlihazırda bellekte yer tutan <code>map</code>'ın bütün sonuçlarına ihtiyacınız olmaz. </p>
<p>Döngüleyici (<code>iterator</code>) metotlarına aşina olmanızı tavsiye ederim çünkü iç içe girmiş döngülerle boğuşmadığınız iyi bir Rust kodu yazmak için elzemdirler. Her zaman olduğu gibi, büyük bir program yazarken bir anda onlarla güreşmek yerine döngüleyici metotlarını keşfetmek için minik programlar yazın.</p>
<p><code>Vec&lt;T&gt;</code> ve <code>&amp;[T]</code> metotları birbirleriyle ortak özellikleri (trait) paylaşırlar: vektörler kendi hata ayıklama bilgilerinin nasıl gösteirlebilirler. (Eğer bütün öğeler <code>Debug</code> özelliğine sahipse.) Aynı şekilde, eğer bütün öğeleri klonlanabilirlerse kendileri de klonlanabilirler. <code>Drop</code> özelliğine sahiptirler, bir vektör düşürüldüğü zaman bellekteki yerleri boşaltılır ve tek tek bütün öğeleri de düşürülür.</p>
<p><code>Extend</code> özelliği döngüleyicilerdeki değerlerin bir döngü içerisine herhangi bir döngü kurmadan eklenebileceğini ifade eder.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>v.extend([60,70,80].iter());
let mut strings = vec![&quot;hello&quot;.to_string(), &quot;dolly&quot;.to_string()];
strings.extend([&quot;you&quot;,&quot;are&quot;,&quot;fine&quot;].iter().map(|s| s.to_string()));
<span class="boring">}</span></code></pre></pre>
<p>Aynı zamanda <code>FromIterator</code> özelliği de vektörlerin döngüleyicilerden <em>inşa edilebileceğini</em> ifade eder. (Döngülerin <code>collect</code> metotu bunu kullanır.)</p>
<p>Her konteynır döngülenebilir olmalıdır. <a href="5-stdlib-containers.html#">Üç tarz-ı döngüleyiciyi</a> hatırlayın.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for x in v {...} // returns T, consumes v
for x in &amp;v {...} // returns &amp;T
for x in &amp;mut v {...} // returns &amp;mut T
<span class="boring">}</span></code></pre></pre>
<p><code>for</code> deyimi <code>IntoIterator</code> üzerinde iş yapar ve buna bağlı olarak üç farklı kullanımı vardır.</p>
<p>Bir de <code>Index</code> (Bir vektörden okurken çalışan) bir de <code>IndexMut</code> (Bir vektörü düzenlerken çalışan) ile kontrol edilen indekslememiz vardır. Pek çok şey yapabiliriz çünkü <code>v[0..2]</code> gibi ifadelerle dilimlere indeksleyebilir ve dönebiliriz ya da sadece <code>v[0]</code> ile ilk elemana referans alabiliriz.</p>
<p><code>From</code> özelliğinin de birtakım kullanımları vardır. Mesela <code>Vec::from(&quot;hello&quot;.to_string())</code> size karakter dizelerinin özündeki <code>Vec&lt;u8&gt;</code> tipindeki vektörü verecektir. Ancak şunu düşünebilirsiniz, zaten <code>String</code> tipi için <code>into_bytes</code> diye bir vektör varken bunun ne özelliği var? Bir işi yapmanın birden çok yolu olması saçma değil mi? Ancak bu, özelliklerin (traits) genellenen metotlar oluşturması için gerekliliktir. </p>
<p>Bazen Rust'ın tip sisteminin kısıtlamalarından illallah edebilirsiniz. Mesela <code>PartialEq</code> boyutu 32'den az olan diziler için <em>ayrıca</em> tanımlanmıştır. (Bunu iyileştirecekler.) Bu vektörlerle dizileri doğrudan rahatça kıyaslamanızı sağlar ancak boyut sınırına dikkat etmelisiniz. </p>
<p>Belgelendirmenin diplerinde bazı <a href="https://www.youtube.com/watch?v=j6K5IblbBzE">gizli hazinelerle</a> karşılaşabilirsiniz. Tıpkı Karol Kuczmarski'nin dediği gibi; &quot;Kimse bu kadar arayıp taramaz.&quot;. Bir döngüleyicideki hataları nasıl yönetmelisiniz? Mesela bir döngüleyici üzerinde <code>map</code> kullandığınızda bazı öğeler sorun çıkarabilir ve size <code>Result</code> dönebilirler, böyle bir döngüleyici ile çalışacağınızı düşünün:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = [&quot;5&quot;,&quot;52&quot;,&quot;65&quot;];
    let iter = nums.iter().map(|s| s.parse::&lt;i32&gt;());
    let converted: Vec&lt;_&gt; = iter.collect();
    println!(&quot;{:?}&quot;,converted);
}
//[Ok(5), Ok(52), Ok(65)]</code></pre></pre>
<p>Yeterince iyi, ama tek tek bütün hataları kontrol etmeniz gerekiyor - dikkatlice! Ancak Rust bu işin doğrusunu yapar, eğer vektörün <code>Result</code> içerisinde barındırılmasını isterseniz - hepsi bu, eğer bir hata varsa bütün vektörü hatalı kabul edebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let converted: Result&lt;Vec&lt;_&gt;,_&gt; = iter.collect();
//Ok([5, 52, 65])
<span class="boring">}</span></code></pre></pre>
<p>Ya dönüşüm başarısız olursa? İlk hatada işi fazla uzatmadan hemen <code>Err</code> döner. <code>collect</code>'in nasıl da esnek olduğuna dair iyi bir örnek olduğunu düşünebiliriz. (Tip bildirimini tuhaf bulabilirsiniz. <code>Vec&lt;_&gt;</code> kabaca bu bir vektör, <code>Result&lt;Vec&lt;_&gt;,_&gt;</code> herhangi bir vektörün <code>Result</code> tipi demektir. Siz ne istediğini belirttikten sonra Rust sizin yerinize işi çözer.)</p>
<p>Belgelendirmede <em>epeyce</em> detay var ancak ne olursa olsun C++'ın <code>std::vector</code> hakkındaki bilgilendirmesinden çok daha anlaşılır ve net.</p>
<blockquote>
<p>Öğelerin gerektiği gereksinimler konteynırın üzerinde yapılan işlemlere dayanır. Çoğunlukla elemanın tipinin karşılanması ve düşürülebilir olması (drop) yeterlidir ancak bazı fonksiyonların katı gereksinimleri vardır.</p>
</blockquote>
<p>C++'da kendi başınızın çaresine bakmanız gerekir. Rust'ın ilk başta her şeyi aleni olarak beklemesi sizi ürkütebilir ancak kısıtlamaları anlarken herhangi bir <code>Vec</code> metotunun gereksinimlerini de anlayacaksınız. </p>
<p>Kaynak kodlarını <code>rustup component add rust-src</code> ile okumanızı tavsiye ederim, standart kütüphanenin kodları oldukça okunaklıdır ve metotların içeriği tanımlarından çok daha anlaşılırdır.</p>
<h1 id="sözlükler-maps"><a class="header" href="#sözlükler-maps">Sözlükler (Maps)</a></h1>
<p><em>Sözlükler (HashMap)</em> dilediğiniz veriye bir <em>anahtar</em> ile ulaşabilmenizi sağlar. Aman aman bir fikir değil ve dilerseniz aynı şeyi demet dizisi ile yapabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let entries = [(&quot;one&quot;,&quot;eins&quot;),(&quot;two&quot;,&quot;zwei&quot;),(&quot;three&quot;,&quot;drei&quot;)];

    if let Some(val) = entries.iter().find(|t| t.0 == &quot;two&quot;) {
        assert_eq!(val.1,&quot;zwei&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>Küçük sözlükler ve sadece anahtar denkliği gerektiren durumlar için üstteki örnek iş görür, ancak içerisinde bir şey aramanın süresi doğru orantıya tabidir - sözlüğün büyüklüğü ile doğru orantılı. </p>
<p>Pek çok <em>anahtar/veri çifti</em> gerektiği zaman bir <code>HashMap</code> ile çalışmak çok çok daha verimlidir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;one&quot;,&quot;eins&quot;);
map.insert(&quot;two&quot;,&quot;zwei&quot;);
map.insert(&quot;three&quot;,&quot;drei&quot;);

assert_eq! (map.contains_key(&quot;two&quot;), true);
assert_eq! (map.get(&quot;two&quot;), Some(&amp;&quot;zwei&quot;));
<span class="boring">}</span></code></pre></pre>
<p><code>&amp;&quot;zwei&quot;</code> mı? <code>get</code> ile verinin kendisini değil de <em>referansını</em> döndüğü için böyle bir şey görüyoruz. Eğer verinin tipi <code>&amp;str</code> ise pekâlâ <code>&amp;&amp;str</code> alabiliriz. Alacağımız verinin <em>referans</em> olması gerekir çünkü çoğu zaman sahipli tiplerin değerlerini <em>taşımak</em> istemeyiz.</p>
<p><code>get_mut</code> tıpkı <code>get</code> gibi çalışır ancak değişebilir bir referans döner. Şimdi karakter dizilerini sayılara çeviren bir sözlüğü inceleyelim ve &quot;two&quot; değerini güncellemeye çalışalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut map = HashMap::new();
map.insert(&quot;one&quot;,1);
map.insert(&quot;two&quot;,2);
map.insert(&quot;three&quot;,3);

println!(&quot;before {}&quot;, map.get(&quot;two&quot;).unwrap());

{
    let mut mref = map.get_mut(&quot;two&quot;).unwrap();
    *mref = 20;
}

println!(&quot;after {}&quot;, map.get(&quot;two&quot;).unwrap());
// before 2
// after 20
<span class="boring">}</span></code></pre></pre>
<p>Referansı farklı bir bloğa aldığımıza dikkat edin - aksi taktirde sonuna kadar değişebilir bir referansımız olurdu ve Rust <code>map</code>, <code>map.get(&quot;two&quot;)</code> ile hiçbir şeyi ödünç almamıza izin vermezdi; değişebilir bir referans varken değişmez referanslara izin verilmez. (Eğer izin verilseydi, değişmez referansların geçerliliği şaibeli olurdu.) Bundan dolayı değişebilir referansı erkenden aradan çıkararak işi çözmüş oluyoruz.</p>
<p>Elbette bunun çok zarif bir API olduğunu söyleyemeyiz ama hatalara karşı daha dikkatli davranırız. Python olsa ters bir durumda hemen ekrana hata mesajları dizer ve C++ ise bize varsayılan veri dönerdi. (Aslında güzel bir çözüm ancak bazı sorunları var. Mesela <code>a_map[&quot;two&quot;]</code> 0 döndüğü zaman &quot;bulunamadı&quot; mesajı ile gerçek sıfırın arasındaki farkı anlayamayız. <em>Üstüne de</em> fazladan bir girdi atanmış olur.)</p>
<p>Kimse <code>unwrap</code> kullanmaz, örneklerde öyle değil tabii. Gördüğünüz çoğu Rust kodu da bağımsız örneklerden oluştuğu için yaygın olarak kullanıldığı kanısına kapılabilirsiniz. Ancak çoğu zaman bir eşleşmenin kullanılması daha olasıdır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(v) = map.get(&quot;two&quot;) {
    let res = v + 1;
    assert_eq!(res, 3);
}
...
match map.get_mut(&quot;two&quot;) {
    Some(mref) =&gt; *mref = 20,
    None =&gt; panic!(&quot;_now_ we can panic!&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>Dilenirse anahtar/veri ikilileri üzerinde döngü kurabilirsiniz ancak belli bir sırası yoktur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (k,v) in map.iter() {
    println!(&quot;key {} value {}&quot;, k,v);
}
// key one value eins
// key three value drei
// key two value zwei
<span class="boring">}</span></code></pre></pre>
<p>Ek olarak <code>keys</code> ve <code>values</code>'un döngüleyici dönen metotları vardır ki bu değerlerden vektör kullanmayı epeyce kolaylaştırır.</p>
<h1 id="Örnek-kelimeleri-saymak"><a class="header" href="#Örnek-kelimeleri-saymak">Örnek: Kelimeleri saymak</a></h1>
<p>Metinleri anlamak için yapabileceğiniz keyifli işlerden birisi bir metinde kaç farklı kelime olduğunu sayabilmektir. Bir metni kelimelere bölmek <code>split_whitespace</code>  ile oldukça kolaydır ancak noktalama işaretlerine özen göstermemiz gerekir. Bundan dolayı kelimeler sadece alfabetik karakterden oluşacak şekilde bölünmelidir. Üstelik kelimeler işleme tamamen küçük harfli olarak alınmalıdır.</p>
<p>Bir sözlükte içeriği değiştirecek tarzdan bir şey aramak kolaydır ancak arama başarısız olduğu zaman ne yapacağını belirtmek biraz tuhaf kaçabilir. Neyse ki hata koşulunu kontrol etmek için gayet zarif bir çözümümüz var:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut map = HashMap::new();

for s in text.split(|c: char| !c.is_alphabetic()) {
    let word = s.to_lowercase();
    let mut count = map.entry(word).or_insert(0);
    *count += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>Eğer aradığımız kelime sözlükte yoksa sözlüğe sıfır içeren yeni bir girdi yaratıyoruz ve onu sözlüğe sokuyoruz (<em>insert</em>). C++'daki sözlükler de aynen böyle çalışır tek fark burada varsayılan veri kendiliğinden gelmez ve net bir şekilde belirtilir. </p>
<p>Bu kapamada (<em>closure</em>) net bir tip belirttik ve tip de <code>char</code> oluyor. Bunun nedeni <code>split</code> tarafından kullanılan karakter dizilerinin <code>Pattern</code> özelliğinin tuhaflığıdır. Ancak Rust burada sözlüğün anahtar tipinin <code>String</code>, sözlüğün veri tipinin de <code>i32</code> olduğunu çıkarabilir. </p>
<p>Gutenberg projesinden <a href="http://www.gutenberg.org/cache/epub/1661/pg1661.txt">Sherlock Holmes'un maceraları'nı (The Adventures of Sherlock Holmes)</a> kullanarak bunu güzelce test edebiliriz. (<code>map.len()</code> ile) Öğreniyoruz ki birbirinden farklı toplam 8071 kelime kullanılmış. </p>
<p>Peki ya en çok kullanılan yirmi kelimeyi nasıl öğrenebiliriz? Öncelikle sözlüğümüzü bir (anahtar, veri) formatında demetlerle dolu bir vektöre çevirebiliriz. (Bu <code>map</code>ı yok edecektir, çünkü <code>into_iter</code> kullandık)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut entries: Vec&lt;_&gt; = map.into_iter().collect();
<span class="boring">}</span></code></pre></pre>
<p>Sonra bunları azalacak şekilde dizelim. <code>sort_by</code>, <code>cmp</code> metotunun sonuçlarını bekleyecektir ki bu metot sayı tiplerinde bulunur. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    entries.sort_by(|a,b| b.1.cmp(&amp;a.1));
<span class="boring">}</span></code></pre></pre>
<p>Ve bu sayıları ilk yirmi çıktıyı ekrana yazdıralım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for e in entries.iter().take(20) {
        println!(&quot;{} {}&quot;, e.0, e.1);
    }
<span class="boring">}</span></code></pre></pre>
<p>(Sadece <code>0..20</code> üzerinde bir döngü <em>kurabilirdiniz</em> - bu kabul edilebilir ancak Rust'ın kendisine özgü tarzının dışına çıkmış olurduk - üstelik büyük döngüler için daha maliyetli olurdu.)</p>
<pre><code> 38765
the 5810
and 3088
i 3038
to 2823
of 2778
a 2701
in 1823
that 1767
it 1749
you 1572
he 1486
was 1411
his 1159
is 1150
my 1007
have 929
with 877
as 863
had 830
</code></pre>
<p>Listenin başında bir tuhaflık sezdiniz mi? O aslında boş bir kelime. <code>split</code> metotu tek karaktere göre parçaladığı için iki noktalama işaretinin arasındaki boşlukklar da kelimeden sayılmış oldu.</p>
<h1 id="kümeler-setshashsets"><a class="header" href="#kümeler-setshashsets">Kümeler (Sets/HashSets)</a></h1>
<p>Kümeleri sadece anahtarlarını umursadığınız sözlükler olarak düşünebilirsiniz, anahtarların karşılığı yoktur. Bundan dolayı <code>insert</code> sadece tek bir veri alır ve dilerseniz <code>contains</code> kullabilirsiniz. </p>
<p>Ç.N: Teknik olarak doğru olsa da buradaki tanımı karmaşık buldum. Kümeleri basitçe her verisi özgün olan, aynı veriyi ikinci kez almayan sırasız bir vektör gibi düşünebilirsiniz.</p>
<p>Diğer konteynırlar gibi bir döngüleyiciden <code>HashSet</code> oluşturabilirsiniz. <code>collect</code> ile bu işi yapabilirsiniz, tipi bildirdiğiniz sürece.</p>
<pre><pre class="playground"><code class="language-rust">// set1.rs
use std::collections::HashSet;

fn make_set(words: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    words.split_whitespace().collect()
}

fn main() {
    let fruit = make_set(&quot;apple orange pear orange&quot;);

    println!(&quot;{:?}&quot;, fruit);
}
// {&quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot;}</code></pre></pre>
<p>Aynı anahtarın tekrar girmiş olmanız (beklenildiği gibi) hiçbir etki oluşturmaz ve bir verideki sıralaması önemli değildir. </p>
<p>Matematikteki setlerle yaptığınız işlemleri pekâlâ Rust ile de yapabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fruit = make_set(&quot;apple orange pear&quot;);
let colours = make_set(&quot;brown purple orange yellow&quot;);

for c in fruit.intersection(&amp;colours) {
    println!(&quot;{:?}&quot;,c);
}
// &quot;orange&quot;
<span class="boring">}</span></code></pre></pre>
<p>Bütün işlemler döngüleyici döner ve <code>collect</code> kullanarak onları tekrardan sete çevirebilirsiniz.</p>
<p>İşte bir kısayol, vektörleri nasıl kullanıyorsak aynı şekilde kullanabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::Hash;

trait ToSet&lt;T&gt; {
    fn to_set(self) -&gt; HashSet&lt;T&gt;;
}

impl &lt;T,I&gt; ToSet&lt;T&gt; for I
where T: Eq + Hash, I: Iterator&lt;Item=T&gt; {

    fn to_set(self) -&gt; HashSet&lt;T&gt; {
       self.collect()
    }
}

...

let intersect = fruit.intersection(&amp;colours).to_set();
<span class="boring">}</span></code></pre></pre>
<p>Bütün Rust jeneriklerinde olduğu gibi burada da tipleri özelliklerle kısıtlamanız gereklidir - yukarıdaki kod sadece eşitliği (<code>Eq</code>) ve &quot;hash fonksiyonu&quot; (<code>Hash</code>) bulunan tipler için çalışır. <code>Iterator</code> diye bir tip bulunmadığını ve <code>I</code>'nın <code>Iterator</code> özelliğine sahip bir tip olması gerektiğini belirtiyoruz.</p>
<p>Standart kütüphane tiplerinine kendi metotlarımızı eklemek gözünüze biraz abartılı görünebilir ancak unutmayın ki kurallar var. Bunu sadece kendi özelliklerimize (<em>trait</em>) uygulayabiliriz. Eğer özelliğin ve yapının (<em>struct</em>) ikisi de aynı sandıktan geliyorsa (Mesela ki standart kütüphaneyi sunan &quot;stdlib&quot;) bu tarz bir kullanıma izin verilmeyecektir. Bu şekilde bir dikkat dağınıklığından kurtulabiliyoruz.</p>
<p>Kendimizi bu zekice ve uygun kısayolu bulduğumuz için övmeye başlamadan önce yaratabileceği sonuçlara dikkat etmelisiniz. Eğer <code>make_set</code> aşağıdaki gibi kullanılırsa, ki burada sahipli bir tip olan <code>String</code>'in kümesi vardır, <code>intersect</code>'in tipi sizi epeyce bir şaşırtabilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_set(words: &amp;str) -&gt; HashSet&lt;String&gt; {
    words.split_whitespace().map(|s| s.to_string()).collect()
}
...
// intersect is HashSet&lt;&amp;String&gt;!
let intersect = fruit.intersection(&amp;colours).to_set();
<span class="boring">}</span></code></pre></pre>
<p>Rust sahipli karakter dizilerinin kopyalarını oluşturmadığı için aksi olamaz. <code>intersect</code>'in içerisinde <code>fruit</code>ten ödünç alınmış tek bir <code>&amp;String</code> bulunmakta. Bunun daha sonra size zorluk çıkaracağına yemin edebilirim, mesela ki yaşam sürelerini belirtmeye başalrken. Daha iyi bir çözüm, döngüleyicinin <code>cloned</code> metotunu kullanarak kesişim için kendi sahipli tiplerinizi üretmenizdir. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// intersect is HashSet&lt;String&gt; - much better
let intersect = fruit.intersection(&amp;colours).cloned().to_set();
<span class="boring">}</span></code></pre></pre>
<p><code>to_set</code>'in daha iyi bir tanımı, <code>self.cloned().collect()</code> ile hazırlanabilir ki bir de bunu böyle denemenizi tavsiye ediyorum.</p>
<h1 id="Örnek-İnteraktif-olarak-komut-İşleme"><a class="header" href="#Örnek-İnteraktif-olarak-komut-İşleme">Örnek: İnteraktif Olarak Komut İşleme</a></h1>
<p>Bir programın interaktif bir oturumu olması oldukça kullanışlı olabilir. Her bir satır kendi başına işleme alınır ve içindeki kelimelere bölünür; komut ilk bölümde yer alır ve geri kalan kelimeler ise komutun argümanları olur.</p>
<p>Bunun en akla yatan çözümlerinden birisi komut isimlerinden kapamalara (closure) ulaşılabilen bir sözlük inşa etmek olur. Peki ya nasıl kapamaları bir yerde barındıracağız? Hepsinin farklı boyutları olduğunu düşününce kulağa daha zor geliyor. En uygun çözüm, onların kopyalarını <code>heap</code>'a kutulamaktır (box):</p>
<p>Hadi deneyelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v = Vec::new();
    v.push(Box::new(|x| x * x));
    v.push(Box::new(|x| x / 2.0));

    for f in v.iter() {
        let res = f(1.0);
        println!(&quot;res {}&quot;, res);
    }
<span class="boring">}</span></code></pre></pre>
<p>İkinci <code>push</code> kullanımında çok net bir hata alacağız:</p>
<pre><code>  = note: expected type `[closure@closure4.rs:4:21: 4:28]`
  = note:    found type `[closure@closure4.rs:5:21: 5:28]`
note: no two closures, even if identical, have the same type
</code></pre>
<p>Ç.N: Aynı görünseler bile iki kapama asla aynı tipte olmayacaktır. </p>
<p><code>rustc</code> gereğinden fazla spesifik bir tip çıkarımında bulundu, bundan dolayı vektörün içindeki tipi kendimiz <em>kutulanmış özellik tipi (boxed trait type)</em> olarak belirtmeliyiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v: Vec&lt;Box&lt;Fn(f64)-&gt;f64&gt;&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>Şimdi kutulanmış kapamaları <code>HashMap</code> (sözlük) tipi için de kullanabiliriz. Kapamalar bulundukları ortamlardan veri çekebildikleri için yaşam sürelerini takip etmeliyiz.</p>
<p><code>FnMut</code>u kullanmayı düşünebilirsiniz - çünkü yakaladıkları her türlü değişkenleri düzenleyebilirler. Ancak bir kapamaya tekabül eden birden fazla komutumuz bulunacağı için tekrar tekrar değişebilir referanslar alamazsınız.</p>
<p>Böylece kapamalar argümanlara <em>değişebilir referanslar</em> olarak erişir, karakter dizilerinin dilimleri de (<code>&amp;[&amp;str]</code>) satırdaki argümanları alır. Tasarladığımız yapıda geri dönüşü <code>Result</code> ile paketleyeceğiz - hata olarak en önce <code>String</code> kullanacağız.</p>
<p><code>D</code> boyutu belli olan herhangi bir tipi gösterir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type CliResult = Result&lt;String,String&gt;;

struct Cli&lt;'a,D&gt; {
    data: D,
    callbacks: HashMap&lt;String, Box&lt;Fn(&amp;mut D,&amp;[&amp;str])-&gt;CliResult + 'a&gt;&gt;
}

impl&lt;'a,D: Sized&gt; Cli&lt;'a,D&gt; {
    fn new(data: D) -&gt; Cli&lt;'a,D&gt; {
        Cli{data: data, callbacks: HashMap::new()}
    }

    fn cmd&lt;F&gt;(&amp;mut self, name: &amp;str, callback: F)
    where F: Fn(&amp;mut D, &amp;[&amp;str])-&gt;CliResult + 'a {
        self.callbacks.insert(name.to_string(),Box::new(callback));
    }
<span class="boring">}</span></code></pre></pre>
<p><code>cmd</code> imzaya göre bir isim ve bir kapama alır, kapama kutulanmış ve sözlüğe girmiş olmalıdır. <code>Fn</code> ise çevreden verileri ödünç alabilir ancak düzenleyemez demektir. Bu tarz genelleme metotları en kötüsüdür, imzasına bakarken kafanız karışık ancak içeriği pirüpak anlaşılırdır! Yaşam ömrünü belirtmeyi unutmak burada en sık yapılan hatalardandır - Rust, çevresine kısıtlanmış kapamaların yaşam ömürlerini unutmanızı hoş görmeyecektir!</p>
<p>Şimdi komutları inceleyelim ve çalıştıralım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn process(&amp;mut self,line: &amp;str) -&gt; CliResult {
        let parts: Vec&lt;_&gt; = line.split_whitespace().collect();
        if parts.len() == 0 {
            return Ok(&quot;&quot;.to_string());
        }
        match self.callbacks.get(parts[0]) {
            Some(callback) =&gt; callback(&amp;mut self.data,&amp;parts[1..]),
            None =&gt; Err(&quot;no such command&quot;.to_string())
        }
    }

    fn go(&amp;mut self) {
        let mut buff = String::new();
        while io::stdin().read_line(&amp;mut buff).expect(&quot;error&quot;) &gt; 0 {
            {
                let line = buff.trim_left();
                let res = self.process(line);
                println!(&quot;{:?}&quot;, res);

            }
            buff.clear();
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Gayet anlaşılır - satırları kelimelere ayırıp bir vektörde topluyoruz, ardından sözlükte ilk kelimeyi aratıyoruz ve sözlüğün döndüğü kapamayı değişebilir verilerimizle ve kelimenin geri kalanlarıyla çağırıyoruz. Boş satırlar görmezden gelinir ve hata olarak değerlendirilmez.</p>
<p>Şimdi kapamalarımızın olumlu ve olumsuz sonuçlar dönmesini kolaylaştırmak için yardımcı fonksiyonlar tanımlayalım. Burada zekice <em>ufak</em> bir detay var; 
tanımladığımız genellenen fonksiyonların çalıştığı tipleri &quot;<code>String</code>&quot;e çevirebilir. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ok&lt;T: ToString&gt;(s: T) -&gt; CliResult {
   Ok(s.to_string())
}

fn err&lt;T: ToString&gt;(s: T) -&gt; CliResult {
   Err(s.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>İşte karşımızda ana programımız var. &quot;<code>ok(answer)</code>&quot;ın nasıl çalıştığına dikkat edin - çünkü sayılar kendilerini nasıl karakter dizilerine çevrileceğini iyi bilirler!</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;

fn main() {
    println!(&quot;Welcome to the Interactive Prompt! &quot;);

    struct Data {
        answer: i32
    }

    let mut cli = Cli::new(Data{answer: 42});

    cli.cmd(&quot;go&quot;,|data,args| {
        if args.len() == 0 { return err(&quot;need 1 argument&quot;); }
        data.answer = match args[0].parse::&lt;i32&gt;() {
            Ok(n) =&gt; n,
            Err(e) =&gt; return err(e.description())
        };
        println!(&quot;got {:?}&quot;, args);
        ok(data.answer)
    });

    cli.cmd(&quot;show&quot;,|data,_| {
        ok(data.answer)
    });

    cli.go();
}</code></pre></pre>
<p>Hataları biraz uyduruk bir yoldan ele aldık ve bu tarz durumlarda soru işareti operatörünün nasıl çalıştığının inceleyeceğiz. Basitçe <code>std::num::ParseIntError</code> hatası <code>std::errror::Errır</code> özelliğini (<em>trait</em>) içeriyor ki bu bulunduğumuz bloğa <code>description</code> metotunu getiriyor - Rust özellikler erişilebilir olmadan üzerinde işlem yapmamıza izin vermez.</p>
<p>Ve çalıştıralım:</p>
<pre><code>Welcome to the Interactive Prompt!
go 32
got [&quot;32&quot;]
Ok(&quot;32&quot;)
show
Ok(&quot;32&quot;)
goop one two three
Err(&quot;no such command&quot;)
go 42 one two three
got [&quot;42&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
Ok(&quot;42&quot;)
go boo!
Err(&quot;invalid digit found in string&quot;)
</code></pre>
<p>Denemek isteyeceğiniz pek çok iyileştirme olabilir. Mesela <code>cmd</code> komutuna yardım satırını içeren üçüncü bir argüman ekleyebilir, <code>help</code> komutuna bu üçüncü argümanla cevap verebilirdik. Ya da Cargo ile <a href="https://crates.io/crates/rustyline">rustyline</a> sandığını kullanarak komut düzenleme ve geçmişe dönmek konularını daha akılcı bir yoldan halledebiliriz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hataları-yönetmek"><a class="header" href="#hataları-yönetmek">Hataları Yönetmek</a></h1>
<h1 id="hataları-yönetmenin-temelleri"><a class="header" href="#hataları-yönetmenin-temelleri">Hataları Yönetmenin Temelleri</a></h1>
<p>Eğer soru işareti operatörünü kullanmazsanız Rust'ta hata yönetimi epey sıkıcı olabilir. Ancak bunu yapabilmek için bazen herhangi bir hatayı barındırabilecek bir <code>Result</code> tipi oluşturabilmemiz gerekir. Bütün hatalar <code>std::error::Error</code> dönebildiğine göre herhangi bir hatayı <code>Box&lt;Error&gt;</code> ile gösterebiliriz. </p>
<p>Düşünün ki hem girdi/çıktı işlemlerinden gelen hatayı hem de karakter dizisini sayıya çevirmekten gelen hatayı aynı fonksiyon içinde dönmek istiyoruz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// box-error.rs
use std::fs::File;
use std::io::prelude::*;
use std::error::Error;

fn run(file: &amp;str) -&gt; Result&lt;i32,Box&lt;Error&gt;&gt; {
    let mut file = File::open(file)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents.trim().parse()?)
}
<span class="boring">}</span></code></pre></pre>
<p>Burada girdi/çıktı işlemleri için iki farklı soru işareti operatörü kullanılıyor (Ya dosya açılamazsa? Ya <code>String</code>e çevrilemezse?) ve bir de çeviri için ayrıca bir soru işareti operatörü kullanıyoruz. En sonunda da sonucu <code>Ok</code> ile dönüyoruz. Rust, <code>parse</code> üzerinden dönen <code>i32</code> tipi ile çalışabilir. </p>
<p><code>Result</code> tipi için bir kısayolu oluşturmak da oldukça olaydır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type BoxResult&lt;T&gt; = Result&lt;T,Box&lt;Error&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Ancak bizim programımızın kendisine özgü hata tipleri olacağı için kendi hata tiplerimizi hazırlamamız gerekecek. Bunun için gereken malzemeler:</p>
<ul>
<li>Tercihen <code>Debug</code></li>
<li>Bir tutam <code>Display</code></li>
<li>Ve son olarak, olmazsa olmazımız <code>Error</code></li>
</ul>
<p>Eğer bunlar olmazsa hata tipiniz kafası nasıl eserse öyle çalışabilir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error1.rs
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct MyError {
    details: String
}

impl MyError {
    fn new(msg: &amp;str) -&gt; MyError {
        MyError{details: msg.to_string()}
    }
}

impl fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f,&quot;{}&quot;,self.details)
    }
}

impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.details
    }
}

// a test function that returns our error result
fn raises_my_error(yes: bool) -&gt; Result&lt;(),MyError&gt; {
    if yes {
        Err(MyError::new(&quot;borked&quot;))
    } else {
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<p>Sürekli sürekli <code>Result&lt;T, MyError&gt;</code> yazmak biraz yorucu olduğu için çeşitli Rust modüllerinin kendi <code>Result</code> tipleri vardır. Mesela <code>Result&lt;T,io::Error&gt;</code> yazmak yerine <code>io::Result&lt;T&gt;</code> yazabilirsiniz.</p>
<p>Sonraki örneğimizde çevrilemeyecek bir karakter dizisini ondalıklı sayıya çevirirken karşımıza çıkan hatayı kontrol etmemiz gerekecek.</p>
<p>Şimdiye kadar <code>?</code> ile elimizdeki ifadenin bir hata dönüp dönemeyeceğine bakarak çalıştı. Bunu belirleyen özellik (trait), <code>From</code> özelliğidir. <code>Box&lt;Error&gt;</code> ise <code>From</code>'a sahip bütün <code>Error</code> tiplerini kabul eder. </p>
<p>Devam etmeden önce kendi yarattığınız <code>BoxResult</code> isimlendirmesini kullanabilir ve her şeyi tek elde toplayabilirsiniz, bu kendi yarattığımız hata tipini <code>Box&lt;Error&gt;</code>'a döndürecektir. Ufak uygulamalar için pekâlâ iyi bir tercih olabilir. Ancak ben size diğer hata türlerini kendi hata türümüze dâhil edebileceğiniz daha iyi bir örnek göstereceğim.</p>
<p><code>ParseFloatError</code>, <code>Error</code>'u içerdiğinden dolayı kendi içinde <code>description()</code>'un da tanımlanmış olması gerek.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::num::ParseFloatError;

impl From&lt;ParseFloatError&gt; for MyError {
    fn from(err: ParseFloatError) -&gt; Self {
        MyError::new(err.description())
    }
}

// and test!
fn parse_f64(s: &amp;str, yes: bool) -&gt; Result&lt;f64,MyError&gt; {
    raises_my_error(yes)?;
    let x: f64 = s.parse()?;
    Ok(x)
}
<span class="boring">}</span></code></pre></pre>
<p>İlk <code>?</code> için pek bir olay yok. (<code>From</code> ile her tip kendisine dönüştürülür.) İkinci <code>?</code> ise <code>ParseFloatError</code> hatasını <code>MyError</code>'a çevirir.</p>
<p>Ve sonuç:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,false));
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,true));
    println!(&quot; {:?}&quot;, parse_f64(&quot;?42&quot;,false));
}
//  Ok(42)
//  Err(MyError { details: &quot;borked&quot; })
//  Err(MyError { details: &quot;invalid float literal&quot; })</code></pre></pre>
<p>Birazcık işi yokuşa sürse de hiç de karmaşık değil. İşin tadını kaçıran kısım yazdığımız <code>From</code> dönüşümleri yazdığımız hataların bizim <code>MyError</code> ile iyi anlaşması gerektiği - ya da bunları hiç düşünmeyin <code>Box&lt;Error&gt;</code> kullanın olsun bitsin. Yeni başlayanlar tek bir şeyi birden fazla yapabilmenin yolunu görünce kafaları karışır. Bir avakadoyu soymanın (ya da yeterince manyaksanız bir kediyi yüzmenin) her zaman başka bir yolu vardır. Bu esnekliğin bedeli birden çok seçeneğe sahip olmaktır. Hata kontrolü 200 satırlık bir program için büyük bir programdan daha basit olabilir. Ve eğer bu kıymetli kod atıklarınızı bir Cargo paketine dönüştürmek isterseniz hata işleme çok daha kıymetli bir hâle gelir.</p>
<p>Şu an için soru işareti operatörü yalnızca <code>Result</code> için çalışmakta, <code>Option</code> için değil, ve bu bir özelliktir, bir kısıtlama değil. <code>Option</code> tipinin <code>ok_or_else</code> isminde kendisini <code>Result</code>'a dönüştüren bir metotu vardır. Mesela, düşünün ki bir <code>HashMap</code>'ta aradığımız anahtar bulunmuyor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = map.get(&quot;my_key&quot;).ok_or_else(|| MyError::new(&quot;my_key not defined&quot;))?;
<span class="boring">}</span></code></pre></pre>
<p>Şimdi hatamız gayet anlaşılır bir şekilde dönmüş oldu! (Bu form içerisinde bir kapama kullanılıyor, böylece buradaki hata ancak gerekirse yaratılırsa olacak.) </p>
<p><strong>Çeviri Notu:</strong> Yazarın dediğine karşın, daha sonra soru işareti operatörü <code>Option</code> tipine dönüşebilir bir şekilde güncellendi. Yani artık şu kullanım geçerlidir:</p>
<pre><code class="language-Rust">let val = map.get(&quot;my_key&quot;)?
</code></pre>
<p><code>get</code> metotundan dönen <code>None</code> değerini olduğu gibi ya da bir hata dönmek size kalmış. İki durumunda kendince artıları ve eksileri var. Yazarın bahsettiği gibi, Rust'ta bir şeyi yapmanın birden fazla yolu var. Daha fazla bilgi için Rust'ın <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">referans kitabını</a> ya da <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">kutsal kitabı</a> inceleyebilirsiniz.</p>
<h1 id="error-chain-ve-hatalarla-baş-etme-sanatı"><a class="header" href="#error-chain-ve-hatalarla-baş-etme-sanatı">error-chain ve hatalarla baş etme sanatı</a></h1>
<p><strong>Çeviri notu</strong>: Acı bir şekilde bahsetmeliyim ki, error-chain isimli sandık <a href="https://users.rust-lang.org/t/error-chain-is-no-longer-maintained/27561/2">2019 gibi</a> tedavülden kaldırıldı. Bunun yerine <code>failure</code> isminde alternatif bir sandığa kişiler yönlendirilmiş ancak o da <a href="https://github.com/rust-lang-deprecated/failure/pull/347">2020 yılı gibi</a> tedavülden kaldırılmış. Benzer konseptleri sağlayan iki sandık var:</p>
<ul>
<li><a href="https://github.com/dtolnay/anyhow">Anyhow</a>: Kabaca hataların tipi ne olursa olsun yönlendirebileceğiniz bir tip sunuyor.</li>
<li><a href="https://github.com/dtolnay/thiserror">thiserror</a>: Bir yapıyı <code>derive(Error)</code> gibi basit bir şekilde hata tipine dönüştürmeye yarar.</li>
</ul>
<p>Yazının gerisini hem orijinal metni korumak hem belli başlı konseptleri tanıtmak hem de hata yönetiminin geçmişini göstermek için çeviriyorum.</p>
<p>Önemsiz olmayan uygulamalar için <a href="http://brson.github.io/2016/11/30/starting-with-error-chain"><code>error_chain</code></a> sandığına göz atmalısınız. Minik bir makro bu kadar faydalı olabilir.</p>
<p><code>cargo new test-error-chain</code> komutuyla çalıştırılabilir bir sandık oluşturun ve oluşturulan dizinin içine girin. <code>Cargo.toml</code>'un sonuna <code>error-chain=&quot;0.8.1&quot;</code>'i ekleyin.</p>
<p><code>error-chain</code>'in olayı elle tek tek yazmanız gereken hata tiplerinin tanımlarını sizin yerinize yazmaktır; yapılar oluşturmak ve <code>Display</code>, <code>Debug</code>, <code>Error</code> gibi bir hata tipi yaratmak için kullanılan özellikleri eklemek. Aynı zamanda öntanımlı olarak <code>From</code> özelliği de dâhil edilir ki normal karakter dizileri de hatalara dönüştürülebilirler.</p>
<p>İlk <code>src/main.rs</code> dosyamız alttakine benzeyecektir. <code>Main</code> içerisinden <code>run</code> fonksiyonu çağrılıyor, hataları satır satır yazıyor ve programı sıfır olmayan bir çıkış kodu ile program sonlandırılıyor. Hepsi bu. <code>error_chain</code> makrosu ile bütün gerekli tanımlar üretilmiş olacaktır, <code>errors</code> modülünü gerekirse daha büyük programlarda kendi dosyasına yerleştirebilirsiniz. <code>errors</code> modülünü global kapsama dağıtmamız gerekti çünkü kodumuzun üretilmiş özellikleri (trait) görebilmesi gerekliydi. Varsayılan olarak, bir adet <code>Error</code> yapısı ve bu hatayla birlikte <code>Result</code> tanımlanacaktır.</p>
<p>Burada <code>foreign_links</code> kullanarak <code>std::io::Error</code>'ün <code>From</code> kullanarak bizim istediğimiz hata tipine dönüşmesini sağlıyoruz</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }
    }
}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::fs::File;

    File::open(&quot;file&quot;)?;

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error: {}&quot;, e);

        std::process::exit(1);
    }
}
// error: No such file or directory (os error 2)</code></pre></pre>
<p><code>foreign_links</code> hayatımızı oldukça kolaylaştırdı zira soru işareti operatörü artık <code>std::io::Error</code>'u nasıl <code>error::Error</code>'a dönüştüreceğini biliyor. (Kaputun altında tam da gerektiği gibi makromuz <code>Form&lt;std::io::Error&gt;</code> dönüşümü tanımlıyor.)</p>
<p>Bütün olay <code>run</code> içerisinde dönüyor; şimdi programa ilk argüman olarak verilen dosyanın ilk on satırını yazdırmayı deneyelim. Ortada verilmiş herhangi bir argüman olmayabilir, bunu bilemeyiz. Tek gereken şey <code>Option&lt;String&gt;</code>'i bir <code>Result&lt;String&gt;</code>'e dönüştürebilmek. Bunu yapabilmek için iki <code>Option</code> metotumuz var ve ben en basit olanını seçtim. <code>Error</code> tipimiz <code>&amp;str</code> için <code>From</code>'u içerdiğinden basitçe bir karakter dizisiyle yeni bir hata oluşturabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;provide a file&quot;))?;

    let f = File::open(&amp;file)?;
    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><code>bail!</code> isminde hata &quot;fırlatmak&quot; için kullanılan küçük ama etkili makromuzu da görelim. Bunun yerine <code>ok_or</code> kullanabilirdiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let file = match args().skip(1).next() {
       Some(s) =&gt; s,
       None =&gt; bail!(&quot;provide a file&quot;)
   };
<span class="boring">}</span></code></pre></pre>
<p>Tıpkı <code>?</code> gibi <em>fonksiyondan erken döner. (early return)</em></p>
<p>Dönen hata içeriğinde <code>ErrorKind</code> isimli bir enum barındırır, bu bizi farklı türlü hataları seçebilmemizi sağlar. (<code>Error::from(str)</code> şeklinde oluşturduğunuz) her hata <code>Msg</code> isimli varyantla eşleşir. <code>Foreign_links</code> ile tanımladığımız <code>Io</code> ise Girdi/Çıktı hatalarıyla eşleşir:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;,s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;,s),
        }
        std::process::exit(1);
    }
}
// $ cargo run
// msg provide a file
// $ cargo run foo
// io No such file or directory (os error 2)</code></pre></pre>
<p>Yeni tür hatalar eklemek de oldukça basittir. <code>error_chain</code> içerisine <code>errors</code> isimli bir kısım ekleyin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }

        errors {
            NoArgument(t: String) {
                display(&quot;no argument provided: '{}'&quot;, t)
            }
        }

    }
<span class="boring">}</span></code></pre></pre>
<p>Bu oluşturduğumuz yeni tür hata için <code>Display</code>'ın nasıl çalışacağını tanımlar. Ve şimdi &quot;argüman yok&quot; tarzı hataları daha spesifik bir şekilde tanımlamış olduk, <code>ErrorKind::NoArgument</code>'e bir <code>String</code> değeri verebiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let file = args().skip(1).next()
        .ok_or(ErrorKind::NoArgument(&quot;filename needed&quot;.to_string()))?;
<span class="boring">}</span></code></pre></pre>
<p>Şimdi eşleştirmeniz gereken yeni bir <code>ErrorKind</code> daha var:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;,e);
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;, s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;, s),
            &amp;ErrorKind::NoArgument(ref s) =&gt; println!(&quot;no argument {:?}&quot;, s),
        }
        std::process::exit(1);
    }
}
// cargo run
// error no argument provided: 'filename needed'
// no argument &quot;filename needed&quot;</code></pre></pre>
<p>Genellikle mümkün olduğunca hataları spesifikleştirmek daha kullanışlıdır, <em>bilhassa</em> bu bir kütüphane fonksiyonuysa! Bu türe göre eşleştirme tekniği geleneksel hata yönetimine oldukça benzer, sadece burada <code>except</code> ya da <code>catch</code> blokları yerine eşleştirme yöntemlerini kullanıyoruz.</p>
<p>Sonuç olarak, <strong>error-chain</strong> sizin yerinize bir <code>Error</code> tipi oluşturur ve <code>Result&lt;T&gt;</code>'i <code>std::result::Result&lt;T, Error&gt;</code> olarak tanımlar. <code>Error</code> ise içeriğinde <code>ErrorKind</code> isimli bir enum barındırır ve varsayılan olarak karakter dizilerinden oluşan hatalarla eşleşen <code>Msg</code>'i barındırır. Harici hataları da iki farklı iş yapan <code>foregin_links</code> ile tanımlayabilirsiniz. Birincisi, yeni bir <code>ErrorKind</code> varyantı oluşturabilirsiniz. İkincisi dış hataları kendi hatamıza çeviren <code>From</code> tanımlarını hazırlar. Böylece kolaylıkla çeşitli hata türleri eklenebilir hâle gelir. Böylece artık kalıplaşmış olan pek çok koddan kurtulmuş oluyoruz.</p>
<h1 id="hataları-zincirlemek"><a class="header" href="#hataları-zincirlemek">Hataları Zincirlemek</a></h1>
<p>Bu sandığın esas güzelliği <em>hataları zincirlemek</em>.</p>
<p>Bir <em>kütüphane kullanıcısı</em> olarak sadece gelişigüzel bir girdi/çıktı almak biraz can sıkar. Tamam, bir dosyayı açamadık. Ama hangi dosya? En basitinden, benim için önemli olan nokta nedir?</p>
<p><code>error_chain</code> (Tr: Hata zinciri) bu tarz aşırı genelleme sorununa karşı <em>hata zincirleme</em> çözümünü sunar. Dosyayı açmak istediğimiz zaman tembelce <code>?</code> kullanma alışkanlığımıza devam edebilir ve <code>io::Error</code>'a dönüştürebiliriz, ya da hatayı <em>zincirleyebiliriz.</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// non-specific error
let f = File::open(&amp;file)?;

// a specific chained error
let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;
<span class="boring">}</span></code></pre></pre>
<p>Şimdi programımızın <code>foreign_links</code> kullanmadan yazılan yeni bir versiyonuna bakalım.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
    }

}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;filename needed&quot;))?;

    ///////// chain explicitly! ///////////
    let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;

    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line.chain_err(|| &quot;cannot read a line&quot;)?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;, e);

        /////// look at the chain of errors... ///////
        for e in e.iter().skip(1) {
            println!(&quot;caused by: {}&quot;, e);
        }

        std::process::exit(1);
    }
}
// $ cargo run foo
// error unable to read the damn file
// caused by: No such file or directory (os error 2)</code></pre></pre>
<p>Görmüş olduğunuz üzere <code>chain_err</code> metotu orijinal hatayı alıyor ve orijinal hatayı barındıran yeni bir hata yaratıyor - bu böyle sonsuza kadar gider. İlgili kapamalar hataya <em>dönüştürülebilen</em> herhangi bir veri dönebilir.</p>
<p>Rust makroları sizi pek çok şey yazmaktan kurtarabilir. <code>error-chain</code>'in <code>main</code> yerine geçebilecek ayrı bir makrosu bile vardır:</p>
<pre><pre class="playground"><code class="language-rust">quick_main!(run);</code></pre></pre>
<p>(Zaten <code>run</code>  bütün olayın gerçekleştiği yerdir.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sistem-süreçleri-ağlar-and-paylaşım"><a class="header" href="#sistem-süreçleri-ağlar-and-paylaşım">Sistem Süreçleri, Ağlar and Paylaşım</a></h1>
<h2 id="değişemez-olanı-değiştirmek"><a class="header" href="#değişemez-olanı-değiştirmek">Değişemez olanı Değiştirmek</a></h2>
<p>Eğer biraz dik kafalıysanız (anladığım kadarıyla) ve ödünç alma kurallarını nasıl es geçebilmenin bir yolu olup olmadığını kara kara düşünüyor olabilirsiniz. </p>
<p>Bu minik programı bir inceleyin, derlenecek ve hiçbir hata vermeyecektir.</p>
<pre><pre class="playground"><code class="language-rust">// cell.rs
use std::cell::Cell;

fn main() {
    let answer = Cell::new(42);

    assert_eq!(answer.get(), 42);

    answer.set(77);

    assert_eq!(answer.get(), 77);
}</code></pre></pre>
<p>Evet, <code>answer</code> değişkeni değişebilir olarak belirtilmemesine rağmen içeriği değişti! </p>
<p>Bu gayet emniyetli, çünkü içeriğindeki <code>Cell</code> içindeki veri yalnızca <code>set</code> veya <code>get</code> ile erişilebilir. Bunun adı <em>iç değişebilirliktir (interior mutability)</em>: Eğer bir <code>v</code> isminde bir yapı (struct) tanımladıysam <code>v</code> isimli yapı değiştirilebilirse <code>v.a</code> da değiştirilebilir olur. <code>Cell</code>, biraz bu kuralı rahatlatıyor çünkü <code>set</code> aracılığıyla içeriğindeki değeri değiştirebiliyoruz.</p>
<p>Fakat, <code>Cell</code> sadece <code>Copy</code> özelliğine sahip tiplerle çalışır. (Mesela kullanıcının tanımadığı <code>Copy</code> özelliğine sahip tiplerle veyahut ilkel tiplerle)</p>
<p>Farklı türden verilerle çalışmak için referansa ihtiyaç duyarız, değişebilir ya da değişemez olması fark etmeksizin. İşte bize <code>RefCell</code> bize bu konuda yarımcı olur - içerideki veriye açıkça bir şekilde referanslarla erişirsiniz.</p>
<pre><pre class="playground"><code class="language-rust">// refcell.rs
use std::cell::RefCell;

fn main() {
    let greeting = RefCell::new(&quot;hello&quot;.to_string());

    assert_eq!(*greeting.borrow(), &quot;hello&quot;);
    assert_eq!(greeting.borrow().len(), 5);

    *greeting.borrow_mut() = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;);
}</code></pre></pre>
<p>Dikkat edin, <code>greeting</code> değişebilir bir değişken olarak bildirilmedi!</p>
<p>Rust'ın dereferans operatörü bir tık kafa karıştırıcı olabilir, çünkü çoğu zaman buna ihtiyaç duymazsınız - mesela <code>greeting.borrow().len()</code> diye çağırsaydık metot kendiliğinden dereferans edeceği için sorun olmazdı. Ancak içeriden gelen <code>greeting.borrow()</code> üzerinden gelen <code>&amp;String</code> veya <code>greeting.borrow_mut()</code> üzerinden gelen <code>&amp;mut String</code> ile çalışmaya devam edebilmek adına <code>*</code> eklemeniz gerekecektir. </p>
<p><code>RefCell</code> kullanmak her zaman emniyetli değildir, hâlen daha geri dönen metotların temel kurallara riayet etmesi gerekmektedir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut gr = greeting.borrow_mut(); // gr is a mutable borrow
    *gr = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;); // &lt;== we blow up here!
....
thread 'main' panicked at 'already mutably borrowed: BorrowError'
<span class="boring">}</span></code></pre></pre>
<p>Eğer değişebilir bir referansınız hâlihazırda varsa tekrardan değişebilir referans oluşturamazsınız. Fakat bu sefer bu kural ihlali derleme zamanında değil <em>çalışma zamanında</em> anlaşılabilir. Çözüm, her zaman olduğu gibi, değişebilir referansları mümkün olduğunca az sayıda tutmaktır - örneğimizdeki kod için değişebilir referansımız <code>gr</code>'ı kod blokları içerisinde tutmayı düşünebilirsiniz böylece referansımız tekrar ödünç almadan önce düşürülmüş olur. </p>
<p>Bu özellik iyi bir sebebiniz olmadan kullanmak isteyeceğiniz bir şey değil çünkü hatalarınızı derleme zamanında al<em>ma</em>yacaksınız. Bu tipler, olağan kuralların sizin işinizi engellediği ama doğrusunu ypatığınız durumlarda size <code>dinamik ödünç alma</code>  sunmak için vardır.</p>
<h2 id="paylaşılan-referanslar"><a class="header" href="#paylaşılan-referanslar">Paylaşılan Referanslar</a></h2>
<p>Şimdiye dek, değer ve ödünç alınmış referanslar derleme zamanında açıkça biliniyordu. Veri sahiptir, referanslar ise onsuz var olamaz. Fakat her şey bu düzgün desen tasarımına uygun değildir, mesela düşünelim ki <code>Rol</code> ve <code>Oyuncu</code> diye iki yapımız (struct) var. <code>Oyuncu</code>, <code>Rol</code> objelerine referanslar bulunan bir vektör tutuyor. Burada veriler arasında net bir şekilde birebir eşleşme yok ve <code>rustc</code>'yi buna ikna etmek işleri epeyce karmaşıklaştıracaktır.</p>
<p><code>Rc</code> tıpkı <code>Box</code> gibi çalışır - heap belleği tahsis edilir ve veri bunun içine taşınır. Eğer bir <code>Box</code> klonlarsanız, içindeki klonlanmış veriyi de beraberinde tutan bir bellek alanı tahsis eder. Fakat bir <code>Rc</code> klonlamak bilgisayar için daha kolaydır, çünkü her klonlama yapacağınız zaman sadece verinin referans sayısını arttırır. Bu, bellek yönetimi için eski ve bilindik bir yöntemdir; mesela iOS ve MacOSlarda kullanılan Objective C'nin çalışma zamanında kullanılır. (Ç.N: Eğer ilgiliyseniz &quot;Automatic Referance Counting&quot; diye bir araştırma yapabilirsiniz.) Modern C++'da bu özellike <code>str::shared_ptr</code> aracılığıyla bulunabilir.</p>
<p>Bir <code>Rc</code>nin içinde bulunduğu kapsam sona erdiği zaman referans sayımı da bir azaltılır. Eğer bu sayı sıfır olursa bellek boşaltılır ve sahiplenilmiş olan veri de düşürülür.</p>
<pre><pre class="playground"><code class="language-rust">// rc1.rs
use std::rc::Rc;

fn main() {
    let s = &quot;hello dolly&quot;.to_string();
    let rs1 = Rc::new(s); // s moves to heap; ref count 1
    let rs2 = rs1.clone(); // ref count 2

    println!(&quot;len {}, {}&quot;, rs1.len(), rs2.len());
} // both rs1 and rs2 drop, string dies.</code></pre></pre>
<p>Orijinal veriye istediğiniz kadar çok referans alabilirsiniz - bu daha önce bahsettiğimiz <code>dinamik ödünç alma</code>dır. <code>T</code> verisi ve onun referansları olan <code>&amp;T</code>'yi dikkatlice takip etmek zorunda değilsiniz. Bunun karşılığında makine çalışma zamanında biraz daha yorulmuş olur, bu yüzden <code>ilk</code> seçiminiz bu olmamalıdır; fakat bu şekilde ödünç alma mekanizmasının sert kurallarına ters düşebilecek paylaşım tasarıları kurgulayabilirsiniz. Dikkat edin ki <code>Rc</code> size değiştirilemez referanslar sağlayacaktır, aksi taktirde en basit ödünç alma kuralını ihlal ediyor olurduk. Bilirsiniz, huylu huyundan vazgeçmez.</p>
<p><code>Oyuncu</code> örneğinde, rollerimizi <code>Vec&lt;Rc&lt;Rol&gt;&gt;</code> olarak tutabiliriz ve böylece rol ekleyip çıkartabiliriz ancak oluşturulduktan sonra rolleri değiştiremeyiz.</p>
<p>Fakat, ya <code>Oyuncu</code> başka bir takıma referanslar bulunduruyorsa ve takım oyuncu referanslarını tek bir vektör içinde tutuyorsa? Her şey değiştirilemez olur çünkü <code>Oyuncu</code> verilerinin <code>Rc</code> olarak depolanması gerekir! Bu durumda <code>RefCell</code> gerekli olur. Bu sefer bütün takım <code>Vec&lt;Rc&lt;RefCell&lt;Oyuncu&gt;&gt;&gt;</code> içinde tutulabilir. Oyuncuyu <code>borrow_mut</code>, aynı anda birden çok değişebilir referans tutmayacağımızdan emin olarak değiştirebiliriz. Mesela oyuncuya özel bir şeyler olursa bütün takımın güçleneceğine dair güçlü bir kuralımız var:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for p in &amp;self.team {
        p.borrow_mut().make_stronger();
    }
<span class="boring">}</span></code></pre></pre>
<p>Kod fena değil, ancak tipler biraz ürkünç görünebilir. Her zaman <code>type</code> ile onlara daha basit isimler atayabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PlayerRef = Rc&lt;RefCell&lt;Player&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<h2 id="Çoklu-sistem-süreçleri"><a class="header" href="#Çoklu-sistem-süreçleri">Çoklu Sistem Süreçleri</a></h2>
<p>Yaklaşık bir yirmi yıldır, saf işlem hızından çoklu çekirdeklere bir geçiş var. Son teknoloji bilgisayarlarımızdan tamamen verim almak için bütün çekirdekleri kullanmalıyız. Bunun en iyi yolu arkaplanda alt süreçler oluşturmaktır, tıpkı daha önceden gördüğümüz <code>Command</code> ancak bu sefer bir senkranizasyon sorunumuz var; bu alt süreçleri beklemeden onların tamamlanıp tamamlanmadığından emin değiliz.</p>
<p>Ayrı iş süreçlerine ihtiyaç duymamızın tek sebebi bu değil elbette, bütün programı sırf bir girdi almak için bekletemezsiniz, mesela. </p>
<p>Alt süreçler üretmek oldukça basit, sadece arkaplanda işletilecek <code>spawn</code> için bir kapama hazırlayın. </p>
<pre><pre class="playground"><code class="language-rust">// thread1.rs
use std::thread;
use std::time;

fn main() {
    thread::spawn(|| println!(&quot;hello&quot;));
    thread::spawn(|| println!(&quot;dolly&quot;));

    println!(&quot;so fine&quot;);
    // wait a little bit
    thread::sleep(time::Duration::from_millis(100));
}
// so fine
// hello
// dolly</code></pre></pre>
<p>Kod satırında gördüğünüz &quot;wait a little bit&quot;, &quot;az bekle&quot; demektir ve pek de mantıklı bir çözüme benzemiyor. Bize dönen nesnelerin üzerinde <code>join</code> çağırmak biraz daha mantıklı, ana süreç bu süreçlerin tamamlanmasını bekleyecektir.</p>
<pre><pre class="playground"><code class="language-rust">// thread2.rs
use std::thread;

fn main() {
    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}
// hello
// wait Ok(())</code></pre></pre>
<p>İşte başka bir tür acayiplik: Alt süreci paniklemeye zorlayalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
        panic!(&quot;I give up!&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());
<span class="boring">}</span></code></pre></pre>
<p>Beklediğimiz gibi panikledi, ancak sadece panikleyen süreç öldü! Ekrana hata mesajını <code>join</code> ile yazabiliyoruz, yani evet her paniğin sonu programın kapatılması değildir; ancak süreçler bilgisayar için yorucu bir işlemdir ve bu süreçleri kontrol etmenin bir yolu olarak görülmelidir.</p>
<pre><code>hello
thread '&lt;unnamed&gt;' panicked at 'I give up!', thread2.rs:7
note: Run with `RUST_BACKTRACE=1` for a backtrace.
wait Err(Any)
</code></pre>
<p>Dönen objeler çeşitli alt süreçlerini takip için etmek için kullanılabilir.</p>
<pre><pre class="playground"><code class="language-rust">// thread4.rs
use std::thread;

fn main() {
    let mut threads = Vec::new();

    for i in 0..5 {
        let t = thread::spawn(move || {
            println!(&quot;hello {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}
// hello 0
// hello 2
// hello 4
// hello 3
// hello 1
</code></pre></pre>
<p>Rust <code>join</code>den dönen sonucu ele almamız için bize ısrar eder, mesela alt süreç panikleyebilir. (Bu gerçekleştiği zaman genelde programın tamamını durdurmazsınız, sadece hataları not edersiniz, yeniden denersiniz vs.)</p>
<p>Alt süreçlerin işleyişi için belirli bir sıra yoktur (Program her çalışmada farklı bir sıra verir), ve buna esas noktadır - onlar gerçekten <em>bağımsız yürütme süreçleridir (independent threads of execution</em>. Çoklu süreçler kolaydır, esas olay <em>eşzamanlılıktır</em> (concurrency) - birden çok sürecin süreci senkronize etmek ve yönetmek. </p>
<h2 id="süreçler-Ödünç-almaz"><a class="header" href="#süreçler-Ödünç-almaz">Süreçler Ödünç Almaz</a></h2>
<p>Süreç kapamaları dışarıdan veri alabilir, ancak <em>taşıyarak</em>, <em>ödünç alarak</em> değil!</p>
<pre><pre class="playground"><code class="language-rust">// thread3.rs
use std::thread;

fn main() {
    let name = &quot;dolly&quot;.to_string();
    let t = thread::spawn(|| {
        println!(&quot;hello {}&quot;, name);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}</code></pre></pre>
<p>Ve işte karşınızda size yardımcı olan hata mesajı: </p>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `name`, which is owned by the current function
 --&gt; thread3.rs:6:27
  |
6 |     let t = thread::spawn(|| {
  |                           ^^ may outlive borrowed value `name`
7 |         println!(&quot;hello {}&quot;, name);
  |                             ---- `name` is borrowed here
  |
help: to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keyword, as shown:
  |     let t = thread::spawn(move || {
</code></pre>
<p>Anlaşılabilir! Bir fonksiyon içerisinde üretilen süreci düşünün - fonksiyon çağrısı sona erdikten sonra bile çalışmaya devam eder ve <code>name</code> dürüşürülebilir. Kapamamıza <code>move</code> eklemek bu sorunu çözecektir.</p>
<p>Fakat bu bir <em>taşımadır</em>, yani <code>name</code> sadece bir süreçte var olabilr! Referansları paylaşmanın mümkün olduğunu vurgulamak istiyorum, ancak <code>static</code> ömre sahip olmalıdırlar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;dolly&quot;;
let t1 = thread::spawn(move || {
    println!(&quot;hello {}&quot;, name);
});
let t2 = thread::spawn(move || {
    println!(&quot;goodbye {}&quot;, name);
});
<span class="boring">}</span></code></pre></pre>
<p><code>name</code>, bütün programın çalışma süresince var olacaktır (<code>static</code>), bu yüzden <code>rustc</code> kapama çalıştığı sürece <code>name</code> değerinin de varlığından emin olacaktır. Ancak, havalı referansların <code>static</code> ömürleri yoktur!</p>
<p>Alt süreçler ortak bir ortamı paylaşamazlar - bu Rust'ın kendi tarzıdır. Biraz detay girersek, olağan referansları paylaşamazlar çünkü kapamalar yakaladıkları verileri taşırlar.</p>
<p>Yine de <em>Paylaşılan referanslar</em> fena değil çünkü yaşam ömürleri &quot;gerektiği kadardır&quot; - ama bunun için <code>Rc</code> kullanamazsınız. Çünkü <code>Rc</code> <em>alt süreçler arası emniyete</em> sahip değildir (<em>thread safe</em>) - sadece süreçlerin olmadığı anlar için hızlı olmaya optimize edilmiştir. Neyse ki <code>Rc</code> kullanırsanız derleme zamanında bir hata alırsınız, derleyici sizin arkanızı kollar.</p>
<p>Alt süreçler için <code>std::sync::Arc</code> kullanmalısınız - &quot;Arc&quot;ın açılımı &quot;Atomic Referance Counting&quot; yani &quot;Atomik Referans Sayımıdır&quot;. Hepsi bu, bu dost her şeyin tek bir işlemde değiştirileceğini garanti eder. Bu garantiyi sağlamak için de işlem gerçekleştirilirken kilitlenir ve o an sadece bir sürecin erişimine izin verilir. <code>clone</code> kullanmak, bir kopya üretmekten bilgisayar için daha zahmetsizdir. (Ç.N: Buradaki <code>clone</code>, baştan aşağıya bellekte veri kopyalayan <code>std::clone</code> değil, referans klonlayan <code>std::sync::Arc::clone</code> metotudur.)</p>
<pre><pre class="playground"><code class="language-rust">// thread5.rs
use std::thread;
use std::sync::Arc;

struct MyString(String);

impl MyString {
    fn new(s: &amp;str) -&gt; MyString {
        MyString(s.to_string())
    }
}

fn main() {
    let mut threads = Vec::new();
    let name = Arc::new(MyString::new(&quot;dolly&quot;));

    for i in 0..5 {
        let tname = name.clone();
        let t = thread::spawn(move || {
            println!(&quot;hello {} count {}&quot;, tname.0, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}</code></pre></pre>
<p>Bilinçli olarak <code>String</code> barındıran bir tip oluşturdum, (&quot;newtype&quot; ya da yenitür) çünkü <code>MyString</code>, <code>Clone</code> özelliğini taşımayacak. Fakat paylaşılan referanslar klonlanabilir!</p>
<p><code>name</code>'e ait paylaşılan referanslar her yeni alt sürece <code>clone</code> ile oluşturulan yeni referanslar olarak iletilir ve kapama içerisine taşınır. Biraz fazla kod yazdırıyor, ancak bu emniyetli bir örüntüdür. Emniyet, eşzamanlılık için epey önemlidir çünkü sorunlar pek öngörülebilir değildir. Program sizin bilgisayarınızda düzgünce çalışsa bile bir sunucuda patlayabilir, mesela haftasonu keyif yaparken. Daha da kötüsü, problemi semptomları bir tanı koymanıza yardımcı olmayabilir. </p>
<h2 id="kanallar"><a class="header" href="#kanallar">Kanallar</a></h2>
<p>Süreçler arasında veri paylaşmanın çeşitli yolları var. Rust içerisinde, bunlardan birisi <em>kanalları</em> kullanmaktır. <code>std::sync::mpsc::channel()</code>, <em>alıcı</em> kanal ve <em>verici</em> kanal olmak üzere bize iki veri tutan bir demet sunar. Her bir alt sürece verici <code>clone</code> ile yollanır, ve referans üzerinde <code>send</code> çağrılır. Ana süreç ise bu esnada alıcı üzerinde <code>recv</code>i çağırır.</p>
<p><code>MPSC</code>'nin açılımı &quot;Multiple Producer Single Consumer&quot;dır, yani &quot;Çoklu üretici, tek tüketici&quot;. Kanala veri yollamaya teşebbüs eden birden çok altsüreç oluşturacağız, ana sürecimiz de kanalı &quot;tüketecek&quot;.</p>
<pre><pre class="playground"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::mpsc;

fn main() {
    let nthreads = 5;
    let (tx, rx) = mpsc::channel();

    for i in 0..nthreads {
        let tx = tx.clone();
        thread::spawn(move || {
            let response = format!(&quot;hello {}&quot;, i);
            tx.send(response).unwrap();
        });
    }

    for _ in 0..nthreads {
        println!(&quot;got {:?}&quot;, rx.recv());
    }
}
// got Ok(&quot;hello 0&quot;)
// got Ok(&quot;hello 1&quot;)
// got Ok(&quot;hello 3&quot;)
// got Ok(&quot;hello 4&quot;)
// got Ok(&quot;hello 2&quot;)</code></pre></pre>
<p>Bu sefer <code>join</code> kullanmaya ihtiyacımız yok çünkü alt süreçler kendilerini sonlandırmasından sonra cevaplarını dönecektir, fakat bu her an gerçekleşebilir. <code>recv</code> süreci kilitleyecektir ve eğer yollayıcı kanal devredışı kalacaksa bir hata dönecektir. <code>recv_timeout</code> ise belli bir süre boyunca bloklayacaktır ve ek olarak bir de zamanaşımı hatası dönebilecektir.</p>
<p><code>send</code> ise süreci kilitlemeyecektir, bu faydalıdır çünkü süreçler mesajın alınmasını beklemeye gerek duymaksızın bir veriyi kanala atıp devam edecektir. Ek olarak, kanalın bir belleği vardır, böylece birden çok <code>send</code> metodu çalışabilir ve alıcıya sırasıyla mesaj iletilecektir. </p>
<p>Fakat, sürecin engellenmemesi aynı zamanda <code>Ok</code> değerinin mesajın başarıyla iletildiği anlamına gelmediğini de işaret eder.</p>
<p><code>sync_channel</code> ise kanala veri yollarken süreci kilitler. Argüman sıfır olursa, alıcı mesajı <code>recv</code> ile alana kadar süreç kilitlenir. Süreçler ya buluşmalıdır ya da randevulaşmalıdır. (Her zaman yabancı kökenli kelimeler kulağa bir tık daha teknik ve doğru gelir.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (tx, rx) = mpsc::sync_channel(0);

    let t1 = thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
        }
    });

    for _ in 0..5 {
        let res = rx.recv().unwrap();
        println!(&quot;{}&quot;,res);
    }
    t1.join().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Burada <code>send</code> kullanılmamışken <code>recv</code> kullanarak bir hataya kolayca sebep olabilir, mesela döngüyü <code>for i in 0..5</code> ile kurmak yerine <code>for i in 0..4</code> kullanarak. Süreç sona erer, <code>tx</code> düşer ve <code>recv</code> başarısız olur. Bu aynı zamanda bir süreç paniklediği zaman da gerçekleşir, stack yavaşça çözülür ve bütün veriler düşürülür.</p>
<p>Eğer <code>sync_channel</code> sıfır olmayan bir argümanla oluşturulursa, buna <code>n</code> diyelim, bu sefer en fazla <code>n</code> değeri alan bir sıra (queue) gibi davranır, <code>send</code> sadece sırada bekleyen <code>n</code>den fazla değer varsa süreci kilitleyecektir.</p>
<p>Kanallar güçlü tip (strongly type) mantığına uygundur, bu örnekte kanalın tipi <code>i32</code>dir, ancak tip çıkarımı bunu biraz gizler. Eğer farklı türden verilere ihtiyacınız varsa, numaralandırmalar (enum) bunu ifade etmek için uygundur. </p>
<h2 id="senkronizasyon"><a class="header" href="#senkronizasyon">Senkronizasyon</a></h2>
<p>Senkranizasyona bakalım. <code>join</code> oldukça basit, tek işi bir iş parçacığı bitene kadar beklemek. <code>sync_channel</code> ise iki kanalı birbirine senkronize ediyor - son örneğimizde üretilen alt süreç ve ana süreç tamamen birbirine kilitlenmişti.</p>
<p>Bariyer senkronizasyonu, bütün süreçlerin bir noktaya geldiği zaman diğer süreçlerin beklemesini içerir, sonra yollarına devam ederler. Bariyer, beklemesini istediğimiz süreçlerin toplam sayısıyla oluşturulur. Daha önce olduğu gibi <code>Arc</code> aracılığıyla bu bariyeri diğer altsüreçlerle paylaşabilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust">// thread7.rs
use std::thread;
use std::sync::Arc;
use std::sync::Barrier;

fn main() {
    let nthreads = 5;
    let mut threads = Vec::new();
    let barrier = Arc::new(Barrier::new(nthreads));

    for i in 0..nthreads {
        let barrier = barrier.clone();
        let t = thread::spawn(move || {
            println!(&quot;before wait {}&quot;, i);
            barrier.wait();
            println!(&quot;after wait {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().unwrap();
    }
}
// before wait 2
// before wait 0
// before wait 1
// before wait 3
// before wait 4
// after wait 4
// after wait 2
// after wait 3
// after wait 0
// after wait 1</code></pre></pre>
<p>Süreçler yine yarı-rastgele çalışırken bir anda birleşiyorlar ve sonra tekrar devam ediyorlar. Bu, devam ettirilebilir bir <code>join</code> gibidir ve bütün süreçlerin belli bir işi yaptıktan sonra o işle devam etmesini istediğinizde kullanışlı olabilir. </p>
<h2 id="paylaşılmış-durumlar"><a class="header" href="#paylaşılmış-durumlar">Paylaşılmış Durumlar</a></h2>
<p>Süreçler, kendi paylaşılmış durum bilgisini nasıl <em>düzenler</em>?</p>
<p>Aklınıza <em>dinamik</em> olarak paylaşılan değişebilir referans almak için kullandığımız  <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> stratejisini getirin. <code>RefCell</code>in süreçlerde kullanılan muadili ise <code>Mutex</code>  - değişken referansı <code>lock</code> kullanarak alabilirsiniz. Referans var olduğu müddetçe diğer süreçler veriye erişemeyecektir. <code>mutex</code>'in açılımı &quot;Mutual Exclusion&quot; yani &quot;Karşılıklı Hariciyet&quot; - bir sürecin erişmesi için kodun ilgili kısmını kilitliyoruz ve ardından kilidini açıyoruz. <code>lock</code> ile kilitlersiniz ve referans düşünce de kilit kalkar.</p>
<pre><pre class="playground"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

fn main() {
    let answer = Arc::new(Mutex::new(42));

    let answer_ref = answer.clone();
    let t = thread::spawn(move || {
        let mut answer = answer_ref.lock().unwrap();
        *answer = 55;
    });

    t.join().unwrap();

    let ar = answer.lock().unwrap();
    assert_eq!(*ar, 55);

}</code></pre></pre>
<p><code>RefCell</code> kadar kolay değil çünkü eğer kilidin olduğu bir süreç paniklerse <code>mutex</code> daima kilitli kalabilir. (Böyle bir durumda, dokümentasyon açıkça süreci <code>unwrap</code> ile terk etmeniz gerektiğini söyler çünkü bir şeyler çok yanlış gitmiştir.)</p>
<p>Bu sefer değişebilir referansları mümkün olduğunca az tutmak çok daha önemli; çünkü bu <code>mutex</code> kapalı kaldıkça diğer süreçler de bloklanacaktır. Bu, kilitleyip bilgisayar için zor hesaplamaların yapmanın yeri bu değil! Yani, muhtemelen kodunuz şuna benzeyecek:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ... do something in the thread
// get a locked reference and use it briefly!
{
    let mut data = data_ref.lock().unwrap();
    // modify data
}
//... continue with the thread
<span class="boring">}</span></code></pre></pre>
<h2 id="yüksek-seviyeli-İşlem"><a class="header" href="#yüksek-seviyeli-İşlem">Yüksek Seviyeli İşlem</a></h2>
<p>Belki de süreçleri yönetmenin daha yüksek seviyeli bir yolunu bulmak, süreçleri tek tek elle kontrol etmekten daha iyidir. Bunun bir örneği hesaplamaları paralel olarak yaptırmak ve sonuçları toplamak olabilir. Epey enteresan bir sandık olarak <a href="https://docs.rs/pipeliner/0.1.1/pipeliner/">pipeliner</a><sup class="footnote-reference"><a href="#old">1</a></sup> sandığına bakabilirsiniz ki çok anlaşılır bir API'ya sahiptir. Deneysel bir &quot;Merhaba Dünya&quot;ye ne dersiniz? - bize çıktılar veren bir döngüleyici kurgulayalım ve <code>n</code> adet işlemi paralel olarak çalıştıralım:
<sup class="footnote-reference"><a href="#old">1</a></sup>: Görünüşe göre pipeliner sandığı Şubat 2020'den beri güncelleme almamış</p>
<pre><pre class="playground"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

fn main() {
    for result in (0..10).with_threads(4).map(|x| x + 1) {
        println!(&quot;result: {}&quot;, result);
    }
}
// result: 1
// result: 2
// result: 5
// result: 3
// result: 6
// result: 7
// result: 8
// result: 9
// result: 10
// result: 4</code></pre></pre>
<p>Salakça bir örnek olduğunun farkındayız, çünkü ilgili operasyon zaten bilgisayar için zahmetsiz ancak paralel işlemler gerçekleştirmenin ne derece kolay olabileceğini göstermiş oldum.</p>
<p>Daha kullanışlı bir şey yapalım. Ağ işlemlerini paralel olarak gerçekleştirmek faydalı olabilir, çünkü genellikle uzun zaman alırlar ve işe başlamak için hepsinin tamamlanmasını beklemeyi istemezsiniz.</p>
<p>Örneğimiz biraz kötü (emin olun yapmanın çok daha iyi yolları var) ancak ne işe odaklanın. 4. Bölümde tanımladığımız <code>shell</code> fonksiyonunu belli bir aralıktaki IP4 adreslerine <code>ping</code> atmak için tekrar kullanacağız:</p>
<pre><pre class="playground"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::process::Command;

fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let output = Command::new(&quot;/bin/sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;ping -c1 192.168.0.{}&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| shell(&amp;s)) {
        if result.1 {
            println!(&quot;got: {}&quot;, result.0);
        }
    }

}</code></pre></pre>
<p>Kendi ev ağımda sonuç şöyle bir şey:</p>
<pre><code>got: PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=43.2 ms

--- 192.168.0.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 43.284/43.284/43.284/0.000 ms
got: PING 192.168.0.18 (192.168.0.18) 56(84) bytes of data.
64 bytes from 192.168.0.18: icmp_seq=1 ttl=64 time=0.029 ms

--- 192.168.0.18 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.029/0.029/0.029/0.000 ms
got: PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=110 ms

--- 192.168.0.3 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 110.008/110.008/110.008/0.000 ms
got: PING 192.168.0.5 (192.168.0.5) 56(84) bytes of data.
64 bytes from 192.168.0.5: icmp_seq=1 ttl=64 time=207 ms
...
</code></pre>
<p>Aktif adresler hızlıca bize bir saniyenin yarısı kadar bir sürede bize cevap verebiliyor, gerisi de olumsuz cevapları beklemek oluyor. Eğer paralel olarak çalıştırmasaydık, yaklaşık bir dakika boyunca sonuçları beklemek zorunda kalırdık! Ping zamanı gibi çıktıdan analiz ederek bulmayı düşünebilirsiniz, ancak bu sadece Linux üzerinde işe yarabilirdi. <code>ping</code> her sistemde vardır ancak çıktı her platform için değişiklik gösterebilir. Eğer Rust ile çalışacak evrensel br ağ API hizmeti tasarlamak isterseniz, ağlar kısmına geçiş yapabiliriz. </p>
<h2 id="adresleri-Çözümlemenin-daha-İyi-bir-yolu"><a class="header" href="#adresleri-Çözümlemenin-daha-İyi-bir-yolu">Adresleri Çözümlemenin Daha İyi Bir Yolu</a></h2>
<p>Eğer <em>sadece</em> neyin aktif olduğu bilmek istiyorsanız ve gelişmiş ping istatistikleri ilginizi çekmiyorsa, <code>std::net::ToSocketAddrs</code> özelliği sizin için DNS çözümlemesi yapacaktır.</p>
<pre><pre class="playground"><code class="language-rust">use std::net::*;

fn main() {
    for res in &quot;google.com:80&quot;.to_socket_addrs().expect(&quot;bad&quot;) {
        println!(&quot;got {:?}&quot;, res);
    }
}
// got V4(216.58.223.14:80)
// got V6([2c0f:fb50:4002:803::200e]:80)</code></pre></pre>
<p>Bu bir döngüleyicidir çünkü genellikle bir alan adına birden çok arayüz bağlıdır, ikisi de Google'un arayüzleridir; birisi IPv4 ve diğeri IPv6 olmak üzere. </p>
<p>Şimdi <code>pipeliner</code> örneğimizi masumca bu metotu yeniden yazmak için kullanabiliriz. Çoğu ağ protokolü hem bir adres hem de bir port kullanır:</p>
<pre><pre class="playground"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::net::*;

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;192.168.0.{}:0&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| s.to_socket_addrs()) {
        println!(&quot;got: {:?}&quot;, result);
    }
}
// got: Ok(IntoIter([V4(192.168.0.1:0)]))
// got: Ok(IntoIter([V4(192.168.0.39:0)]))
// got: Ok(IntoIter([V4(192.168.0.2:0)]))
// got: Ok(IntoIter([V4(192.168.0.3:0)]))
// got: Ok(IntoIter([V4(192.168.0.5:0)]))
// ....</code></pre></pre>
<p>Bu, <code>ping</code> yollamaktan çok daha hızlıdır çünkü sadece bir IP adresinin geçerli olup olmadığını ölçüyoruz, eğer bir gerçek alan adlarının bir listesini kullansaydık DNS araştırması epey vakit alabilirdi ve bu paralleliğin nasıl önemli olabileceğini bize gösteriyor.</p>
<p>İlginç bir şekilde, bu &quot;çalıştır ve unut&quot; mantığında işliyor. Standart kütüphanede bulunan ve <code>Debug</code> barındıran her şey, hata ayıklamak için de müthiş keşifler sunar. Dönngüleyici <code>Result</code> (hâliyle <code>Ok</code>) dönüyor ve bu <code>Result</code>, IPv4 veyahut IPv6 varyantları olan bir numalandırma olan <code>SocketAddr</code> barındıran bir <code>IntoIter</code> içeriyor. Peki neden <code>IntoIter</code>? Çünkü bir soketin birden çok adresi olabilir, (hem IPv4 hem de IPv6 adresi olması gibi.) </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for result in addresses.with_threads(n)
        .map(|s| s.to_socket_addrs().unwrap().next().unwrap())
    {
        println!(&quot;got: {:?}&quot;, result);
    }
// got: V4(192.168.0.1:0)
// got: V4(192.168.0.39:0)
// got: V4(192.168.0.3:0)
<span class="boring">}</span></code></pre></pre>
<p>Bu da çalışıyor, ilginç olarak, bizim basit örneğimiz kadar işe yarıyor. İlk <code>unwrap</code> <code>Result</code>'tan kurtuluyor ve döngüleyiciden ilk çıkan değeri dışarı çıkartıyor. <code>Result</code> genellikle bu durumda anlamsız adreslerde tetiklenir. (Mesela portu olmayan adres isimleri gibi.)</p>
<h2 id="tcp-İstemci-sunucusu"><a class="header" href="#tcp-İstemci-sunucusu">TCP İstemci Sunucusu</a></h2>
<p>Rust, en çok kullanılan ve en yaygın ağ protokolü için gayet makul bir atayüz de sunar; TCP. TCP, hatalara karşı oldukça dayanıklıdır ve ağlarla örülü dünyamızın temel taşıdır - <em>paketler</em> onaylanarak gönderilir ve onaylanarak alınır. Bunun tersi olarak UDP ise paketleri hiçbir onay olmadan yollar. Bunun hakkında şöyle garabet bir espri vardır: &quot;Sana UDP hakkında bir fıkra anlatabilirim ama muhtemelen kafan almayacak.&quot; (Ağlar hakkındaki espriler komiktir, sizin komikten ne anladığınıza göre değişir tabii.)</p>
<p>Fakat, hata kontrolü ağlarla uğraşırken <em>çok</em> önemlidir çünkü her an her şey bir anlığına oluşabilir.</p>
<p>TCP, bir istemci/sunucu modeliyle çalışır; sunucu adresi belli bir <em>ağ portundan</em> dinler ve istemci de sunucuya bağlanır. Bağlantı oluşturulduğunda ise istemci ve sunucu bir soket üzerinden haberleşebilir.</p>
<p><code>TcpStream::connect</code>, <code>SoccetAddr</code>'a dönüştürülebilecek her şeyi kabul eder, kullandığımız düz karakter dizilerini de.</p>
<p>Rust'ta basit bir TCP istemcisi yazmak oldukça kolaydır - <code>TcpStream</code> yapısı hem yazılabilir hem de okunabilirdir. Her zaman olduğu gibi, özellikleri kullanmak için, <code>Read</code>, <code>Write</code> ve diğer <code>std::io</code> özelliklerini kapsamda görünür kılmalıyız.</p>
<pre><pre class="playground"><code class="language-rust">// client.rs
use std::net::TcpStream;
use std::io::prelude::*;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);

    write!(stream,&quot;hello from the client!\n&quot;).expect(&quot;write failed&quot;);
 }</code></pre></pre>
<p>Sunucumuz pek karmaşık değil, bir dinleyici kuruyoruz ve bağlantıları bekliyoruz. Eğer bir istemci bağlanırsa, sunucu tarafında <code>TcpStream</code> elde ederiz. Bu örnekte sunucuya gelen her şey bir karakter dizisine yazılmış olur.</p>
<pre><pre class="playground"><code class="language-rust">// server.rs
use std::net::TcpListener;
use std::io::prelude::*;

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(mut stream) =&gt; {
                let mut text = String::new();
                stream.read_to_string(&amp;mut text).expect(&quot;read failed&quot;);
                println!(&quot;got '{}'&quot;, text);
            }
            Err(e) =&gt; { println!(&quot;connection failed {}&quot;, e); }
        }
    }
}</code></pre></pre>
<p>Port numarasını aşağı yukarı rastgele geçtim, ancak pek çok <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">port</a> özel anlamlar barındırır.</p>
<p>İki tarafında protokol üzerinde uzlaştığına dikkat edin. İstemci akışa yazı yazabileceğini düşünür ve sunucu da akıştan yazıyı okuyabileceğini umar. Eğer oyunu aynı kurallarla oynamazlarsa, bir tarafın engellendiği ve hiç gelmeyecek bir cevabı beklediği durumlar oluşur. </p>
<p>Hataların kontrolü önemlidir - ağ girdi çıktıları çeşitli sebeplerden aksayabilir ve hatalar dolunayda dosya sisteminin kurtadama dönüşmesi gibi acayip sebeplerlerl de geçerkleşebilir. Birileri kablolarla ip atlayabilir, öbür tarafın bilgisayarı çökebilir, falan fistan. Yazdığımız ufak sunucu çok da sağlam değil, çünkü ilk hata çökecektir.</p>
<p>Hataları düzgünce ele alan güçlü bir sunucu aşağıda bulunmaktadır. Akıştan bir satırı bir <code>io::BufRead</code> üreten bir <code>io::BufReader</code> aracılığıyla okur ve böylece çıktı üzerinde <code>read_line</code> çağırabiliriz.</p>
<pre><pre class="playground"><code class="language-rust">// server2.rs
use std::net::{TcpListener, TcpStream};
use std::io::prelude::*;
use std::io;

fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    println!(&quot;got '{}'&quot;, text.trim_right());
    Ok(())
}

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(stream) =&gt; {
                if let Err(e) = handle_connection(stream) {
                    println!(&quot;error {:?}&quot;, e);
                }
            }
            Err(e) =&gt; { print!(&quot;connection failed {}\n&quot;, e); }
        }
    }
}</code></pre></pre>
<p><code>handle_connection</code> içindeki <code>read_line</code> çökebilir ancak sonuçta hata emniyetli bir şekilde kontrol edilmiş olur.</p>
<p>Bu tarz tek yönlü iletişimler bazen kullanışlı olabilir - bu örnekte olduğu gibi. Ağda bulunan servislerin durumlarını, merkezi bir yerde toplamış oluyoruz. Fakat kibarca bir şekilde geri dönüş yapsak iyi olur, en azından &quot;ok&quot; deyip geçelim.</p>
<p>İşte bir &quot;eko&quot; sunucusu. İstemci, sonunda satır sonu işareti olan bir metni sunucuya yollar ve sunucuda ek bir satır sonu ekleyerek geri yollar - akış okunabilir ve yazılabilirdir. </p>
<pre><pre class="playground"><code class="language-rust">// client_echo.rs
use std::io::prelude::*;
use std::net::TcpStream;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);
    let msg = &quot;hello from the client!&quot;;

    write!(stream,&quot;{}\n&quot;, msg).expect(&quot;write failed&quot;);

    let mut resp = String::new();
    stream.read_to_string(&amp;mut resp).expect(&quot;read failed&quot;);
    let text = resp.trim_right();
    assert_eq!(msg,text);
}</code></pre></pre>
<p>Sunucu şimdi ilginç bir hâl aldı. Sadece <code>handle_connection</code>u değiştirelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut ostream = stream.try_clone()?;
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    ostream.write_all(text.as_bytes())?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Bu yaygın olarak kullanılan yaygın br çift taraflı soket iletişimidir; <code>BufReader</code>'a yollamak için bir satır istiyoruz - fakat &quot;BufReader&quot; akışı <em>tüketiyor</em>! Bu yüzden akışı klonlamalıyız ve aynı soketi işaret eden yeni bir yapı oluşturmalıyız. Böylece nihayet huzuru elde ediyoruz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-ve-nesne-yönelimli-programlama"><a class="header" href="#rust-ve-nesne-yönelimli-programlama">Rust ve Nesne Yönelimli Programlama</a></h2>
<p>Her disiplinden birileri geliyor ve Nesne Yönelimli bir dilden gelmeniz olasılığınız oldukça yüksektir:</p>
<ul>
<li>&quot;Sınıf&quot;lar nesne (kimi zaman <em>örnek</em> (instance) deriz) üreten fabrikalar gibi çalışırlar.</li>
<li>Sınılar diğer sınıfların (<em>üst sınıf/ebeveyn</em>) alanlarını (<em>field</em>) ve davranışlarını (<em>metotlar</em>) <em>miras (inheritance)</em> alabilir.</li>
<li>Eğer B, A'dan miras alıyorsa, o zaman B aynı zamanda A olarak kabul edilebilir. (<em>alttip/subtyping</em>)</li>
<li>Nesne kendi verilerini gizlemelidir (<em>kapsülleme/encapsulation</em>), sadece metotlarıyla etkileşime geçmelidir.
Nesne yönelimli <em>tasarım</em> sınıfların (yani isimleri) ve yöntemlerin (yani sıfatları) tanımlandığı anlayıştır. Aynı zamanda nesne yönelimli tasarımda bunlar arasındaki ilişkiler de tanımlanır ve bu ilişkiler <em>sahip olmak (has-a</em>) ve <em>onun türünden olmak (is-a)</em> olarak tanımlanır.</li>
</ul>
<p>Eski Star Trek serilerinde doktorun kaptana &quot;Bu bir yaşam Jim, sadece bizim bildiğimiz yaşam değil&quot; (It's Life, Jim, just not Life as we know it) dediği bir an vardır. Bu deyim aynen olduğu gibi Rust'taki nesne yönelimi anlayışını da açıklıyor: Önce &quot;Bu ne ya?&quot; diyorsunuz, çünkü Rust'taki veri yapıları (yapılar, numaralandırmalar ve demetler) pek de uçan kaçan tarzda değiller. Onlara metot tanımlayabilirsiniz, verinin kendisini gizleyebilirsiniz ve bütün kapsülleme yöntemlerini kullanabilirsiniz ancak her birisi <em>birbiriyle alakasız tiplerdir.</em> Alt tipler yoktur, miras alma yöntemi yoktur. (Sadece <code>Deref</code> zorlamaları miras olarak kabul edilebilir <sup class="footnote-reference"><a href="#yorum">1</a></sup>)</p>
<div class="footnote-definition" id="yorum"><sup class="footnote-definition-label">1</sup>
<p>Çevirmenin yorumu: Nesne yönelimli programlamada miras alan tip, doğal olarak miras aldığı tip olduğu kabul edilir. Rust'ta bir literatür farklılığı vardır, o da tipin aslında o olmadığı ancak zorlanarak dönüştürüldüğü vurgusudur. Yani bu bir miras alma mıdır? Evet, belki de. Ancak Rust, &quot;coercion&quot; kelimesi ile Rust'ın bir tipi başka bir tipe zorla dönüştürdüğünü vurgulamaktadır.</p>
</div>
<p>Çeşitli tipler arasındaki ilişkiler <em>özellikler (trait)</em> ile inşa edilir. Rust öğrenme sürecinin büyük bir kısmı standart kütüphanede bulunan özelliklerin nasıl çalıştığını anlamaktan geçer çünkü bu bütün verileri birbiriyle çalışmasına izin veren ve onlara anlamlar yükleyen bir sistemdir.</p>
<p>Özellik sistemi ilginçtir çünkü ana akım programlama dillerinde birebir benzeri yoktur.  Tabii, bu dinamiklik ya da statiklik arasındaki farklı düşünürsek. Dinamik olarak Java ve Go arayüzlerine (interface) benzerler.</p>
<h3 id="Özellik-nesneleri"><a class="header" href="#Özellik-nesneleri">Özellik Nesneleri</a></h3>
<p>Özellikleri anlatırken kullandığımız ilk örneği düşünün:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Show {
fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
fn show(&amp;self) -&gt; String {
format!(&quot;four-byte signed {}&quot;, self)
}
}

impl Show for f64 {
fn show(&amp;self) -&gt; String {
format!(&quot;eight-byte float {}&quot;, self)
}
}
<span class="boring">}</span></code></pre></pre>
<p>Bu da büyük <code>impl</code> bloklarıyla beraber ufak bir program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Show {
</span><span class="boring">    fn show(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Show for i32 {
</span><span class="boring">    fn show(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;four-byte signed {}&quot;, self)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Show for f64 {
</span><span class="boring">    fn show(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;eight-byte float {}&quot;, self)
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn main() {
let answer = 42;
let maybe_pi = 3.14;
let v: Vec&lt;&amp;Show&gt; = vec![&amp;answer,&amp;maybe_pi];
for d in v.iter() {
println!(&quot;show {}&quot;,d.show());
}
}
// show four-byte signed 42
// show eight-byte float 3.14</code></pre></pre>
<p>Burası Rust'ın tip bildirimi gerektirdiği bazı nadir noktalardan birisi - <code>Show</code> özelliğini içeren herhangi bir vektörü açıkça istemek durumundayım. <code>i32</code> ve <code>f64</code> arasında hiçbir şey bağlantı olmadığına dikkat edin, fakat ikisi de <code>show</code> metotuna sahip çünkü ikisi de aynı özelliğe sahip. Bu <em>sanal (virtual)</em> bir metottur, çünkü bu metot her tip için farklı bir kod çalıştırır ve çalışma zamanındaki duruma göre doğru yöntem çağrılır. Bu referanslara <a href="https://doc.rust-lang.org/stable/book/trait-objects.html">özellik nesneleri</a> denir.</p>
<p>Ve <em>bu</em> farklı tipleri nasıl aynı vektöre koyabileceğinizin yoludur. Eğer Java veyahut Go temeliniz varsa, <code>Show</code>'u bir arayüz (interface) olarak düşünebilirsiniz.</p>
<p>Biraz daha kurcalayalım ve değerleri bir <code>Box</code> işaretçisi içine koyalım. <code>Box</code>, heapta tahsis edilmiş alana yerleştirilen verinin referansını referansını temsil eder ve bir ödünç alma gibi çalışır - bu bir <em>akıllı işaretçidir (smart pointer)</em>. <code>Box</code> ortadan kalktığı zaman <code>Drop</code> devreye girer ve bellek serbest bırakır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Show {
</span><span class="boring">    fn show(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Show for i32 {
</span><span class="boring">    fn show(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;four-byte signed {}&quot;, self)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Show for f64 {
</span><span class="boring">    fn show(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;eight-byte float {}&quot;, self)
</span><span class="boring">    }
</span><span class="boring">}
</span>
let answer = Box::new(42);
let maybe_pi = Box::new(3.14);

let show_list: Vec&lt;Box&lt;Show&gt;&gt; = vec![answer,maybe_pi];
for d in &amp;show_list {
println!(&quot;show {}&quot;,d.show());
}
// show four-byte signed 42
// show eight-byte float 3.14
<span class="boring">}</span></code></pre></pre>
<p>Buradaki fark, bu şekilde bu vektörü alıp bir yere referans takibi yapmaksızın başka yerlere ödünç verebilirsiniz. Vektör düşürüldüğü zaman, <code>Box</code> nesneleri de düşürülür ve bellek yeniden tahsis edilebilir.</p>
<h2 id="hayvanat-bahçesi"><a class="header" href="#hayvanat-bahçesi">Hayvanat Bahçesi</a></h2>
<p>Nesne yönelimli programlamadan ve miras alma işleminden bahsettiğimiz ilk andan itibaren hayvanlardan konuşmaya başlarız. Kulağa da fena gelmez, &quot;Bak işte, kedi bir etoburdur ve etoburlar bir hayvandır&quot;. Ruby evreninden klasik bir sloganı analım: &quot;Eğer vaklıyorsa, o bir ördektir&quot;. <code>quack</code> (vak!) metotuna sahip bütün nesneler ördek olarak tanımlanabilir, biraz kulağa tuhaf gelse de.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>trait Quack {
fn quack(&amp;self);
}

struct Duck ();

impl Quack for Duck {
fn quack(&amp;self) {
println!(&quot;quack!&quot;);
}
}

struct RandomBird {
is_a_parrot: bool
}

impl Quack for RandomBird {
fn quack(&amp;self) {
if !self.is_a_parrot {
println!(&quot;quack!&quot;);
} else {
println!(&quot;squawk!&quot;);
}
}
}

let duck1 = Duck();
let duck2 = RandomBird{is_a_parrot: false};
let parrot = RandomBird{is_a_parrot: true};

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot];

for d in &amp;ducks {
d.quack();
}
// quack!
// quack!
// squawk!
<span class="boring">}</span></code></pre></pre>
<p>Elimizde iki farklı tip var (o kadar işlevsiz ki hiçbir veri tutmuyorlar), ve evet, hepsinin <code>quack()</code> metotu var. Bir tanesinin davranışı bir ördek için azıcık tuhaf, ancak yine de hepsi ortak bir metot ismini paylaşıyor ve Rust hepsini tip emniyetli bir şekilde bir araya getiriyor.</p>
<p>Tip emniyeti müthiş bir şey. Eğer tip emniyeti olmasaydı, ortalığı çalışma zamanında darmaduman edecek bir <em>kediyi</em> vakvak kardeşlerin arasına sokabilirdik.</p>
<p>Şimdi saçma bir şey yapalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// and why the hell not!
impl Quack for i32 {
fn quack(&amp;self) {
for i in 0..*self {
print!(&quot;quack {} &quot;,i);
}
println!(&quot;&quot;);
}
}

let int = 4;

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot,&amp;int];
...
// quack!
// quack!
// squawk!
// quack 0 quack 1 quack 2 quack 3
<span class="boring">}</span></code></pre></pre>
<p>Ne diyebilirim ki? Vaklıyorsa ördektir. İlginç olan şey, özellikleri herhangi bir şeye ekleyebilirsiniz, sadece &quot;nesnelere&quot; değil. (<code>quack</code> bir referans olarak iletildiği için, defererans operatörü ile sayıyı alabilirsiniz.)</p>
<p>Yine de bunu sadece kendi sandığınızda tanımladığınız tipler üzerinde veya o sandıkta tanımlanmış özelliklerle yapabilirsiniz. Yani standart kütüphaneyi yamalı bohçaya (monkey patch) çeviremezsini, ki bu da Ruby vatandaşlarının başka bir alışkanlığı. (Çok da bayılan bir şey değildir doğrusu.)</p>
<p>Şimdiye kadar <code>Quack</code> bir Java arayüzü gibi davrandı ve isterseniz modern Java tipleri arayüzleri gibi çeşitli uygulamaları eğer gereken metotları sağladıysanız tipinize ekleyebilirsiniz. (<code>Iterator</code> özelliğini hatırlayın.)</p>
<p>Şimdiye kadar, özellikler bir tip <em>tanımının</em> parçası değildi ve isterseniz özellikleri istediğiniz tipe ekleyebilirsiniz,  ancak aynı sandık kısıtlamasını gözden kaçırmayın.</p>
<p><code>Quack</code> özelliğine sahip bütün nesneleri referans olarak da görebilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quack_ref (q: &amp;Quack) {
q.quack();
}

quack_ref(&amp;d);
<span class="boring">}</span></code></pre></pre>
<p>İşte bu Rust'ın anladığı şekilde alttiplemedir.</p>
<p>Burada &quot;Programlama Dilleri Kapıştırmaca Dersleri&quot; verdiğimiz için, Go'nun ilginç vaklama yaklaşımını da not etmek istiyorum. Eğer Go'da tanımlanmış bir <code>Quack</code> arayüzü varsa ve bir tipin <code>quack</code> metotu varsa, o tip <code>Quack</code> arayüzünü açık bir tanıma gerek duymadan kendisine implement eder. Bu Java'nın &quot;Her şey tek tek tanımlanacak!&quot; yaklaşımına ters düşer ve tip emnyetini biraz tehlikeye soksa da &quot;ördek tiplemeye&quot; izin verir. (Duck-typing)</p>
<p>Fakat ördek tipleme ile alakalı bir sorun var. Kötü bir nesne yönelimli programlamanın ilk işaretçisi çok fazla metotun <code>run</code> gibi her kalıba girebilecek isimlere sahip olmasıdır. &quot;Eğer <code>run()</code> (Çalıştır) metotu varsa, o zaman <code>Runnable</code> (Çalıştırılabilir) olmalıdır&quot; vaklıyorsa o ördektir kadar zarif gelmiyor. Yani <em>istemeden</em> bir <code>Go</code> arayüzü o tipte tanımlı olabilir. Rust için mesela, <code>Debug</code> ve <code>Display</code> aynı anda <code>fmt</code> metotunu barındırır, fakar iki özelliğin çok farklı anlamları vardır.</p>
<p>Yani, Rust özellikleri bildiğimiz anlamda çok biçimli nesne yönelimli programlamaya izin verir. Peki ya miras? İnsanlar genellikle &quot;Miras alma&quot;yı kastederken Rust genellikle &quot;Arayüz mirasından&quot; bahseder. <code>extend</code> yerine her zaman <code>implements</code> kullanmayı tercih eden bir Java programcısı gibi. Ve bu aslında Alan Jolub tarafından <a href="http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html">tavsiye edilen bir alışkanlıktır.</a> Der ki:</p>
<blockquote>
<p>James Gosling'in (Java'nın yaratıcısı) sunduğu bir Java kullanıcıları gurubu konferansında bir keresinde bulunmuştum. O akılda kalıcı soru - cevap kısmında birisi şöyle bir soru sordu: &quot;Eğer Java'yı yeniden tasarlasaydınız, neyi değiştirirdiniz?&quot;. O da şöyle bir cevap verdi: &quot;Sınıf anlayışını terk ederdim&quot;. İnsanların kahkahası sona erdikten sonra sorunun sınıflar olmadığını ancak &quot;miras alma&quot; işleminden ziyade (<em>extends</em> ilişkisi) olduğundan bahsetti. &quot;Arayüz mirası&quot; (<em>implements</em> ilişkisi) çok daha tercih edilesi. Miras almayı mümkün olduğunca az yapmanız faydanıza olur.</p>
</blockquote>
<p>Java gibi bir dilde bile, çok fazla sınıf üretiyor olabilirsiniz!</p>
<p>Miras alma anlayışının çok ciddi sorunları var, fakat oldukça <em>akla yatkın</em> görünüyor. Aşırı geniş bir sınıf olan <code>Animal</code>ı tasarlıyoruz ve içerisine çok faydalı şeyler ekliyoruz (tehlikeli olsa bile), ve bizim <code>Cat</code> sınıfımız da bu faydalı şeyleri kullanabiliyor. Hepsi bu, kodları tekrar kullanmanın bir yolu. Ancak kodun yeniden kullanımı aslında başka bir konudur.</p>
<p>Miras alma ve arayüz mirası arasındaki farkı anlamak Rust'ı anlarken oldukça önemlidir.</p>
<p>Özelliklerin size başka metotlar <em>sağladığını</em> unutmayın. <code>Iterator</code> özelliğini düşünün, <code>next</code> metotunu tanımladıktan sonra başka metotları zahmetsizce tipinize eklemiş olursunuz. Modern Java arayüzlerindeki &quot;varsayılan&quot; metotlar gibi. Alttaki örnekte <code>name</code> kısmını tanımlıyoruz ve <code>upper_case</code> bizim yerimize tanımlanmış oluyor. <em>İstersek</em> <code>upper_case</code> metotunu yeniden yazabiliriz, ama bu <em>gerekli</em> değildir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Named {
fn name(&amp;self) -&gt; String;

fn upper_case(&amp;self) -&gt; String {
self.name().to_uppercase()
}
}

struct Boo();

impl Named for Boo {
fn name(&amp;self) -&gt; String {
&quot;boo&quot;.to_string()
}
}

let f = Boo();

assert_eq!(f.name(),&quot;boo&quot;.to_string());
assert_eq!(f.upper_case(),&quot;BOO&quot;.to_string());
<span class="boring">}</span></code></pre></pre>
<p>Bu da bir <em>çeşit</em> kodu tekrar kullanma yöntemi, evet, ama bunun verinin kendisinde geçerli olmadığını sadece arayüzde tanımlı olduğuna dikkat edin.</p>
<h2 id="Ördekler-ve-genellemeler"><a class="header" href="#Ördekler-ve-genellemeler">Ördekler ve Genellemeler</a></h2>
<p>Burada Rustla yazılmış, genelleme kullanılarak yazılan &quot;ördek&quot; fonksiyonu gözünüze anlamsız gelmiş olabilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quack&lt;Q&gt; (q: &amp;Q)
where Q: Quack {
q.quack();
}

let d = Duck();
quack(&amp;d);
<span class="boring">}</span></code></pre></pre>
<p>Tip parametresi, <code>Quack</code> özelliğini barındıran herhangi bir şeyi işaret eder. Buradaki <code>quack</code> ve önceki bölümde tanımladığımız <code>quack_ref</code> arasında önemli bir fark var. Fonksiyonun içeriği, çağıran her bir tip için ayrıca oluşturulur ve sanal metotlara ihtiyacımız yok, bu tarz fonksiyonlar tamamen &quot;satır içi&quot; (inline) olabilir. Burada <code>Quack</code> tipi genellenen tip üzerinde bir kısıtlama olarak kullanılır.</p>
<p>Bu da genellenen <code>quack</code> metotumuzun C++ muadili (<code>const</code>a dikkat edin):</p>
<pre><code class="language-cpp">template &lt;class Q&gt;
void quack(const Q&amp; q) {
q.quack();
}
</code></pre>
<p>Tip parametresinin herhangi bir şeyle kısıtlanmadığına dikkat edin.</p>
<p>Bu daha çok derleme zamanında çalışan bir ördek tiplemeye benziyor - vaklamayan bir tipi iletirsek derleyici <code>quack</code> diye bir metot olmadığından bahsedecektir. En azından sonra derleme zamanında keşfediliyor. Go'da direkt bütün tipin <code>Quackable</code> arayüzüne sahip olması daha da kötü şeylere sebep olabilir. Daha karmaşık <code>template</code> fonksiyonları ve sınıfları berbat hata mesajlarına yol açacaktır çünkü bu sefer genellenen tipler üzerinde <code>hiçbir</code> kısıtlama olmayacaktır.</p>
<p>Vaklayan nesne üzerindeki işaretçilerle bir döngü tanımlamayı düşünebilirsiniz:</p>
<pre><code class="language-cpp">template &lt;class It&gt;
void quack_everyone (It start, It finish) {
    for (It i = start; i != finish; i++) {
        (*i)-&gt;quack();
    }
}
</code></pre>
<p>Bu, her <code>It</code> döngüleyici türü için çalışacaktır. Rust muadili az biraz daha ilginçtir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quack_everyone &lt;I&gt; (iter: I)
where I: Iterator&lt;Item=Box&lt;Quack&gt;&gt; {
for d in iter {
d.quack();
}
}

let ducks: Vec&lt;Box&lt;Quack&gt;&gt; = vec![Box::new(duck1),Box::new(duck2),Box::new(parrot),Box::new(int)];

quack_everyone(ducks.into_iter());
<span class="boring">}</span></code></pre></pre>
<p>Rust'taki döngüleyiciler ördek tipli değildir ancak ilişkili tipler <code>Iterator</code> özelliğini barındırmalıdır ve ilgili örneğimizde <code>Box&lt;Quack&gt;</code> için döngüleyici tanımlanıyor. Hangi tiple çalışacağı hakkında bir belirsizlik yoktur ve ilişkili veriler muhakkak <code>Quack</code>'ı tanımlamalıdır. Bazen bir Rust fonksiyonu yazarken fonksiyon imzası yazmaktan Rust'tan bıkabilirsiniz, bu yüzden standart kütüphanenin kaynak kodlarını dikkatlice okumanızı şiddetle öneririm - ancak fonksiyon yazmak fonksiyon yazmaktan daha kolaydır! Örneğimizdeki tek tip parametresi döngüleyici tipidir, yani bu sadece vektör döngüleyicisiyle değil, <code>Box&lt;Duck&gt;</code> dizisi olan her şeyle çalışacaktır. </p>
<h2 id="miras-alma"><a class="header" href="#miras-alma">Miras Alma</a></h2>
<p>Nesne yönelimli tasarımlı ilişkili en yaygın sorun nesnelerin bir &quot;onun türünden olma&quot; <em>(is-a)</em> ilişkisiyle tanımlanmasıdır, sahip olma ilişkileri <em>(has-a)</em> genellikle ihmal edilir. <a href="https://en.wikipedia.org/wiki/Design_Patterns">GoF</a>, &quot;Design Patterns&quot; (Dizayn örüntüleri) kitabında yirmi iki yıl önce &quot;Birleşkeleri mirasa tercih edin&quot; demiş.</p>
<p>İşte size iyi bir örnek: Bir şirketin çalışanlarını modellemek istiyorsunuz ve <code>Calisan</code> sizin için iyi bir sınıf ismi gibi görünüyor. Sonra, &quot;Yönetici&quot; bir çalışan türüdür (yani doğru) ve kendi hiyerarşimizi <code>Yonetici</code>'yi <code>Calisan</code>ın alt sınıfı olarak inşa ediyoruz kurguluyoruz. Zekice görünse de değil. İsimleri belirlemeye kendimizi kaptırmışken çalışanların ve yöneticilerin aslında birbirinden farklı canlılar olduğunu düşündük aslında. Belki de <code>Calisan</code> sınıfı sadece bir <code>Roller</code> dizisine sahip olmalıdır ve yöneticiyi daha fazla yetkiye sahip bir çalışan olarak tanımlamalıyız?</p>
<p>Taşıtları düşünelim, bisikletten damperli kamyonlara kadar geniş bir skalası var. Araçları kategorize etmenin çok farklı yolları var, üzerinde gittiği yoldan (şehir içinde, tarlada, rayda), kullandığı enerji türüne (dizel, hibrit, elektrikli vs), insan mı yoksa yük taşımacılığında mı kullanıldığı gibi. Sınıfların sabit bir hiyerarşisi, tek bir bakış açısı dışında diğer bakış açılarının görmezden gelindiği anlamına gelir. Gördüğünüz gibi, araçları çok farklı şekillerde sınıflandırabilirsiniz!</p>
<p>Rust için birleşkeler çok daha önemlidir çünkü başka bir sınıftan işlevleri olduğu gibi devrealmak tembelce bir yöntemdir.</p>
<p>Ödünç alma denetimi açısından da birleşkeler önemlidir çünkü çeşitli yapıların (struct) hangi alanlarının kullandıldığının takibi yapılabilir. Bir alanın değişken referansı alınırken diğer alanın değişmez referası ödünç alınabilir; bu yüzden yapılar kullanım rahatlığı için kendi metotlarına sahip olmalıdır. (Yapının <em>dışsal</em> arayüzü ise özellikler üzerinden sağlanabilir.)</p>
<p>Ayrık referansların net bir örneği bunu daha anlaşılır kılacaktır. Kendi <code>String</code> alanları olan bir yapı tanımladık ve tek bir <code>String</code>'in değişken referansını aldık.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    one: String,
    two: String
}

impl Foo {
    fn borrow_one_mut(&amp;mut self) -&gt; &amp;mut String {
        &amp;mut self.one
    }
    ....
}
<span class="boring">}</span></code></pre></pre>
<p>(Rust'ın isimlendirme anlayışının da aynı zamanda bir öneğidir - bu tarz metot isimleri <code>_mut</code> ile sona ermelidir.)</p>
<p>Şimdi ilk metotu tekrar kullanarak iki <code>String</code> alanını da ödünç alan bir yapı tanımlayalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (self.borrow_one_mut(), &amp;self.two)
    }
<span class="boring">}</span></code></pre></pre>
<p>Çalışamaz! <code>self</code>'in değişmez referansını aldık ve aynı zamanda <code>self</code>'in değişebilir referansını almaya çalışıyoruz. Eğer Rust bu tarz durumlara izin verseydi değişmez referansın değişemeyeceğini garanti edemeyebilirdi.</p>
<p>Çözüm basit:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (&amp;self.one, &amp;self.two)
    }
<span class="boring">}</span></code></pre></pre>
<p>Bunda bir sorun yok çünkü bunların ikisini ödünç alma denetçisi bunların ikisini de bağımsız ödünç almalar olarak tanımlar. Alanların gelişigüzel yapılar olduğunu düşünün, rastgele çağırdığınız metotlar bu alanlar üzerinde çalışırken bir hataya sebep olmayacaktır.</p>
<p>Miras almanın sınırlandırılmış ancak önemli bir türü <a href="https://rust-lang.github.io/book/second-edition/ch15-02-deref.html">Deref</a> özelliğidir, ismi &quot;Dereferans&quot; operatörü olan <code>*</code> ile gelir. <code>String</code> tipi <code>Deref&lt;Target=str&gt;</code> özelliğine sahiptir ve <code>&amp;str</code> tipi için çalışacak bütün metotlar aynı zamanda <code>String</code> ile de çalışabilir! Benzer şekilde, <code>Foo</code> ile çalışan bütün metotlar aynı <code>Box&lt;Foo&gt;</code> üzerinden de doğruca çalışabilir. Başta biraz... kontrolsüz bir şekilde pratik görünse de aslında epey kullanışlıdır. Rust'ın içerisinde basit bir mantık var, ancak kullanımı o kadar da akılcı görünmüyor. Sadece değişken bir türün ödünç alındığı zaman daha basit davranması gerketiği zaman kullanılmalıdır.</p>
<p>Rust'ta <em>özellikler birbirini miras alabilir</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Show {
    fn show(&amp;self) -&gt; String;
}

trait Location {
    fn location(&amp;self) -&gt; String;
}

trait ShowTell: Show + Location {}
<span class="boring">}</span></code></pre></pre>
<p>Son özellik iki ayrıksı özelliği de barındırıyor, istenirse kendi içine metotlar tanımlanabilir. </p>
<p>Şimdi alıştığımız şeye geri döndük:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Foo {
    name: String,
    location: String
}

impl Foo {
    fn new(name: &amp;str, location: &amp;str) -&gt; Foo {
        Foo{
            name: name.to_string(),
            location: location.to_string()
        }
    }
}

impl Show for Foo {
    fn show(&amp;self) -&gt; String {
        self.name.clone()
    }
}

impl Location for Foo {
    fn location(&amp;self) -&gt; String {
        self.location.clone()
    }
}

impl ShowTell for Foo {}

<span class="boring">}</span></code></pre></pre>
<p>Eğer <code>Foo</code> türünden <code>foo</code> diye bir değerim varsa, bu türün değişkeni <code>&amp;Show</code> ve <code>&amp;Location</code>'u karşıladığı gibi (ikisini de barındıran) <code>&amp;ShowTell</code>'i de karşılayacak.</p>
<p>İşte işimize yaracak ufak bir makro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! dbg {
    ($x:expr) =&gt; {
        println!(&quot;{} = {:?}&quot;,stringify!($x),$x);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>$x</code> ile gösterilen) tek bir argümanı alıyor ve bu argüman bir &quot;ifade&quot; olmalıdır. Bu değeri ekrana yazdırıyoruz ve veriyi ve metinin metinleştirilmiş hâlini ekrana yazdırıyoruz. C programcıları burada bıyık altından gülebilir, ancak eğer <code>1 + 2</code> (bir ifade) değerini verirsem <code>stringify!(1 + 2)</code> bize &quot;1 + 2&quot; şeklinde karakter dizisi verecektir. Bu, bize biraz kodları incelemek için yardımcı olacaktır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Foo::new(&quot;Pete&quot;,&quot;bathroom&quot;);
dbg!(foo.show());
dbg!(foo.location());

let st: &amp;ShowTell = &amp;foo;

dbg!(st.show());
dbg!(st.location());

fn show_it_all(r: &amp;ShowTell) {
    dbg!(r.show());
    dbg!(r.location());
}

let boo = Foo::new(&quot;Alice&quot;,&quot;cupboard&quot;);
show_it_all(&amp;boo);

fn show(s: &amp;Show) {
    dbg!(s.show());
}

show(&amp;boo);

// foo.show() = &quot;Pete&quot;
// foo.location() = &quot;bathroom&quot;
// st.show() = &quot;Pete&quot;
// st.location() = &quot;bathroom&quot;
// r.show() = &quot;Alice&quot;
// r.location() = &quot;cupboard&quot;
// s.show() = &quot;Alice&quot;
<span class="boring">}</span></code></pre></pre>
<p>İşte <em>bu</em> nesne yönelimli programlamadır, sadece alıştığınız türden değil.</p>
<p><code>Show</code> referansına iletilen <code>show</code> değerinin <em>dinamik olarak</em> <code>ShowTell</code> olmayacağına dikkat edin! Daha dinamik sınıf sistemlerine sahip dillerin size objenin bir sınıfın nesnesi olup olmadığını denetleme imkanı verdiğine ve bu dinamik türe göre çağrı yapma izni verdiğine dikkat edin! Aslında bu pek de iyi bir fikir değildir ve Rust'ta bunu yapmanın bir yol yoktur çünkü Rust <code>Show</code> referansının aslında <code>ShowTell</code> referansı olduğunu unutmuştur bile.</p>
<p>Her zaman seçimleriniz vardır; özellik nesneleri aracılığıyla çok biçimlilik ya da özellik kısıtlamaları ile biçimlendirilmiş genelleme tanımlarıyla tek biçimlilik. Modern C++ ve Rust standart kütüphanesi genelleme yolunu tercih eder, ancak çok biçimlilik yolu da hâlen daha tercih edilebilir. Her zaman neyin karşılığında neyi aldığınızı bilmeniz gerekir - genellemeler daha hızlı kod üretir ve satır içi (inline) kullanılabilirler. Bunun neticesinde kodunuz şişebilir. (code bloat) Fakat her şeyin <em>mümkün olduğunca hızlı olmasına</em> da gerek yoktur - olağan bir program akışında birkaç defa bu gerçekleşebilir.</p>
<p>Sonuç olarak:</p>
<ul>
<li>Sınıfların rolü veri ve özellikler (trait) arasında paylaştırılmıştır.</li>
<li>Yapılar ve numaralandırmalar veri gizlemesine ve metot tanımlanabilmesine rağmen fazla işleve sahip değildir.</li>
<li>Alttiplemenin <em>sınırlandırılmış</em> bir türü <code>Deref</code> özelliği ile sağlanabilir.</li>
<li>Özellikler bir veri tutmaz ancak her tipe uygunlanabilirler. (Yalnızca yapılara değil.)</li>
<li>Özellikler, başka özellikleri miras alabilir.</li>
<li>Özellikler metotlar sunabilir, kodların tekrar kullanımını mümkün kılarlar</li>
<li>Özellikler size sanal metotlar (çok biçimlilik) ve genelleme sınırlamaları (tek biçimlilik) sunabilirler.</li>
</ul>
<h2 id="Ördek-windows-api"><a class="header" href="#Ördek-windows-api">Ördek: Windows API</a></h2>
<p>Geleneksel nesne yönetimli programlamanın en çok kullanıldığı yerlerden birisi GUI (Ç.N: düğmeli menüyü arayüzler işte) kütüphaneleridir. <code>EditControl</code> ve <code>ListWindow</code>, <code>Window</code> türünden sınıflardır falan filan. Bu, GUI kütüphanelerine Rust bağlantıları yazmayı biraz daha zorlaştırır.</p>
<p>Rust'ta Win32 programlaması <a href="https://www.codeproject.com/Tips/1053658/Win-GUI-Programming-In-Rust-Language">direkt</a> yapılabilir, ve orijinal C'den daha az gariptir. C'den C++'a geçer geçmez daha sade bir şey yapmak istedim ve kendi nesne tabanlı kodlarımı yazdım.</p>
<p>Tipik bir Win32 API fonksiyonu <a href="https://docs.rs/user32-sys/0.0.9/i686-pc-windows-gnu/user32_sys/fn.ShowWindow.html">ShowWindow'dur</a> ve bir pencerenin görünüp görünmediğini denetlemek için kullanılır. Şimdi, <code>EditControl</code>'ün kendisine özgü nitelikleri bulunur fakat hepsi Win32'nin <code>HWND</code> (&quot;pencere yönetimi&quot;) opak değeriyle yapılır. <code>EditControl</code>'ün aynı zamanda <code>show</code> metotu olmasını isteyebilirsiniz, genelde miras alma yöntemiyle halledilir. Fakat bu tipin her işlevi miras almasını istemeyebilirsiniz! Rust size güzel bir çözüm sunar, <code>Window</code> özelliğini düşünelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Window {
    // you need to define this!
    fn get_hwnd(&amp;self) -&gt; HWND;

    // and all these will be provided
    fn show(&amp;self, visible: bool) {
        unsafe {
         user32_sys::ShowWindow(self.get_hwnd(), if visible {1} else {0})
        }
    }

    // ..... oodles of methods operating on Windows

}
<span class="boring">}</span></code></pre></pre>
<p>Şimdi <code>EditControl</code> yapısı sadece bir <code>HWHD</code>'ye sahip olabilir ve <code>Window</code>'u eklemek tek bir metotu tanımlayarak mümkün olabilir. <code>EditControl</code> ise <code>Window</code> özelliğini miras alan bir yapıdır ve daha geniş bir arayüz tanımlar. <code>ComboBox</code> gibi düşünün - <code>EditControl</code> gibi davranır ve bir <code>ListWindow</code> da özellik mirası aracılığıyla eklenebilir.</p>
<p>Win32 API'sı (&quot;32&quot; artık &quot;32-bit&quot; anlamına gelmiyor) özünde nesne yönelimlidir, ancak daha eski bir şekilde, Alan Key'in tanımından etkilenmiş bir şekilde: nesneler gizli veriler tutar ve <em>mesajlar</em> üzerinden işlenir. Yani Windows uygulamalarının kalbi bir mesaj döngüsüdür ve çeşitli pencereler (pencere sınıfları da denir) kendi metotlarını kendi anahtar ifadeleriyle uygularlar. <code>WM_SETTEXT</code> diye bir mesaj vardır fakat bunun koda dökülüş hâli biraz daha farklıdır: bir etiketin yazısı değişebilir ya pencere başlığı değişir.</p>
<p><a href="https://gabdube.github.io/native-windows-gui/book_20.html">Burada</a> daha anlaşılır ve minimal bir Windows GUI frameworkü görebilirsiniz. Bana göre çok fazla <code>unwrap</code> öğeleri var ve bunların çoğu hata bile değil.  Bu, &quot;NWG&quot;nin mesajlaşmanın dinamik doğasına ters düşmesiyle alakalı. Daha tip güvenli bir arayüz sunmak için, hatalar derleme zamanında sunuluyor.</p>
<p><a href="https://doc.rust-lang.org/stable/book/ch17-00-oop.html">Rust programlama kitabında &quot;Nesne yönelimli nedir?&quot;</a> üzerine güzel bir tartışma mevcuttur.</p>
<blockquote>
<p>Çeviri notu: Bu bölümün sonlarına doğru bir dolu hata yapmış olabilirim, çünkü bu son kısımları yazarken saat gecenin üçüne yaklaşıyor ve kafa olarak biraz yorgundum. :)</p>
<p>Türk yazılımcısı çoğunlukla nesne yönelimli kavramını C# ve Java aracılığıyla öğrendiği için nesne yönelimi kavramı dilde <code>class</code> kelimesinin sunulmasıyla bağdaştırılıyor ve bu epeyce bir kafa karışıklığı yaratıyor. Nesne tabanlı programlama, kendi özünde verilerin soyutlanıp yazılımcıya daha çok anlam ifade eden &quot;bütünlere&quot; dönüştürülmesiyle alakalı bir tekniktir ve bu tekniğin uygulanması için verinin gizlenmesi, yalnızca metotlarla erişim gibi ilkeler vardır. <code>class</code> ile tanımlanan yaplar, bu ilkeleri otomatik olarak inşa etmeye yarar. Ortada <code>class</code> adı hiç geçmese bile nesne tabanlı programlama yapılabilir ve Lua, Nim, Nix gibi diller buna iyi bir örnek oluşturur. İşin özü, JavaScript da bu sınıfların listesindeydi ancak sonradan <code>class</code> kelimesi bazı prototip işlemlerini otomatikleştirmek için eklendi. Eklenene dek, JavaScript her zaman nesne tabanlıydı ancak &quot;fonksiyonel&quot; ve &quot;nesne tabanlı&quot; olmak arasında kalmış bir dil gibi düşünüldü; aslında JavaScript her zaman &quot;prototip&quot; üzerinden işleyen nesne yönelimli bir dildi.</p>
<p>Bir literatür hatası olarak, saf fonksiyonel diller aynı zamanda nesne yönelimli olamayacağı için fonksiyonel programlama ve nesne yönelimli programlama arasında bir zıtlık varmış gibi anlaşıldı. Sonradan Go, Rust gibi klasik nesne yönelimli diller sınıfına uymayan diller &quot;fonksiyonel&quot; diller olarak anlaşıldı. Rust'ta fonksiyonel esintiler bulunmasına rağmen Rust saf bir fonksiyonel dil değildir, nesne yönelimi ile Rust'ın alakası neyse fonksiyonel programlama ile Rust'ın alakası o seviyede diyebilirim. Ha, fonksiyonel programlama &quot;işlevsel, işe yarayan programlama&quot; demek değildir diye not edelim.</p>
<p>Peki, neden Rust'ta sınıflar yok? Bu bölümde bahsedildiği gibi sınıflar çok fazla işi bir anda halleder ve bu kesinlikle Rust'ın doğasına uymaz. Rust'ta her şey açık, belirgin ve bilindiktir. Rust, sınıfların yaptığı şeyleri yapmanıza izin verecek araçları size sunar ancak kolaylık olsun diye gizlice bir şeyler hazırlamaz. Bu yüzden, Rust nesne yönelimli bir dil gibi görünmese de aslında nesne yönelimini size sunar.</p>
<p>Eğer nesne yönelimli programlamaya karşı bakış açınızı gözden geçirmek ve nesne yönelimli programlamanın yaratıcısından da neyin ne olduğunu öğrenmek isterseniz, <a href="https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">bu bağlantıya tıklayabilirsiniz.</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yazıları-nom-ile-ayrıştırmak"><a class="header" href="#yazıları-nom-ile-ayrıştırmak">Yazıları Nom ile Ayrıştırmak</a></h2>
<p><a href="https://github.com/Geal/nom">Nom</a>, <a href="https://docs.rs/nom">(burada anlatıldığı şekilde)</a> öğrenmeye değer bir metin ayrıştırma için kullanılan bir Rust kütüphanesidir.</p>
<p>Eğer CSV veya JSON gibi türü bilinen bir veri türünü ayrıştırmak istiyorsanız bu işin özelleşmiş kütüphanelerden birisi olan <a href="https://github.com/BurntSushi/rust-csv">Rust CSV</a> veya [Bölüm 4'te] bahsedilen JavaScript kütüphanelerinden birisine bakmak isteyebilirsiniz. </p>
<p>Aynı şekilde, <a href="https://docs.rs/rust-ini/0.10.0/ini/">ini</a> veya <a href="http://alexcrichton.com/toml-rs/toml/index.html">toml</a>. gibi yapılandırma dosyaları için onlara özel kendisine özgü kütüphanelere göz atabilirsiniz. (<a href="https://docs.rs/serde_json">serde_json</a>'den bildiğimiz Serde Frameworkü ile uyumlu çalıştığı için Toml için hazırlanan kütüphane ayrıca hoştur.)</p>
<p>Fakat belli bir standarda ait olmayan, keyfe keder bir şekilde hazırlanmış verilerı taramak karakter dizileriyle geçireceğiniz sıkıcı saatlere işaret ediyor da olabilir. İlk fikir <a href="https://github.com/rust-lang/regex">regex</a> olur, ancak regex bir yerden sonra alabildiğine mantıksız bir şeye dönüşebilir. Nom, metin ayrılmanın güçlü ve sadece basit araçları birleştirmekten ibaret olduğu güzel bir yol sunar. Aynı zamanda regexlerin bir sınırı vardır, mesela <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags">HTML taramak için regex kullanamazsınız.</a>, fakat Nom ile HTML ayrıştırabilirsiniz. Hatta kendi programlama dilinizi yazmayı düşündüyseniz, Nom öğrenmek bu zorlu yolculuğun ilk adımı olabilir.</p>
<p>Nom öğrenmek için müthiş rehberler var, ancak ben biraz sindirerek gitmek istediğim için en basit yerden başlamak istiyorum. Bilmeniz gereken ilk şey, Nom baştan aşağıya makrolardan oluşur, ikincisi Nom karakter dizileri yerine bayt dilimleriyle çalışmayı tercih eder. Birinci şey, Nom'u kullanırken dikkatli olmanız gerektiğine işaret eder çünkü hata mesajlarından hiçbir şey anlamayabilirsiniz. İkincisi Nom'u <em>herhangi</em> bir veri türüyle kullanabileceğinizi işaret eder, sadece &quot;metin&quot; ayıklamak için değil. Nom kullanmış kişiler ikili biçimleri deşifre etmek veya dosya başlıklarını anlamak için kullandı. &quot;UTF-8&quot; ile kodlanmamış metinlerle de çalışabilirsiniz.</p>
<p>Nom'un son versiyonları karakter dizileriyle de çalışabilmeyi başladı, fakat karakter dizileriyle çalışabilen makroların sonunda <code>_s</code> bulunur.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate nom;

named!(get_greeting&lt;&amp;str,&amp;str&gt;,
    tag_s!(&quot;hi&quot;)
);

fn main() {
    let res = get_greeting(&quot;hi there&quot;);
    println!(&quot;{:?}&quot;,res);
}
// Done(&quot; there&quot;, &quot;hi&quot;)
</code></pre></pre>
<p><code>named!</code> isimli makro (varsayılan olarak <code>&amp;[u8]</code> tipinden) girdi alıp ve sivri parantezlerin ikinci argümanının tipinden geri dönen fonksiyonlar oluşturur. <code>tag_s!</code> ise kendisine iletilen karakter dizisi ile eşleşir, ve değer genellikle verilenin türünden olur. (Eğer <code>&amp;[u8]</code> ile çalışmak isterseniz, bunun yerine <code>tag!</code> kullanabilirsiniz.) </p>
<p>Tanımladığımız <code>get_greeting</code> ayrıştırıcısını bir <code>&amp;str</code> ile çağırabiliriz ve bize <a href="http://rust.unhandledexpression.com/nom/enum.IResult.html">IResult</a> dönecektir, bir de elbette ki eşleşen veriyi.</p>
<p>Boşlukları görmezden gelmek isteyebiliriz, <code>tag!</code> makrosunu <code>ws!</code> ile sarmalarsak aradığımız &quot;hi&quot; kelimesini eşleştirirken bütün boşluklar görmezden gelinecektir:</p>
<pre><pre class="playground"><code class="language-rust">named!(get_greeting&lt;&amp;str,&amp;str&gt;,
    ws!(tag_s!(&quot;hi&quot;))
);

fn main() {
    let res = get_greeting(&quot;hi there&quot;);
    println!(&quot;{:?}&quot;,res);
}
// Done(&quot;there&quot;, &quot;hi&quot;)</code></pre></pre>
<p>Sonuç daha önce olduğu gibi &quot;hi&quot; olacaktır, ardında kalan karakter dizisi boşlukları kaldırılmış bir şekilde &quot;there&quot; olacaktır!</p>
<p>Tamam, &quot;hi&quot; eşleşmesi tıkırında çalışıyor ama bir şey yaramıyor. Hadi sadece &quot;hi&quot; yerine <em>hem</em> &quot;hi&quot;  <em>hem de</em> &quot;bye&quot; kısmını eşleştirelim.  <code>alt!</code> makrosu (&quot;alternatif&quot;) <code>|</code> ile ayrılmış ayrıştırıcılardan <em>birisiyle</em> eşleşir. Aynı şekilde burada boşlukları okunaklı olması için kullanabilirsiniz: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>named!(get_greeting&lt;&amp;str&gt;,
    ws!(alt!(tag_s!(&quot;hi&quot;) | tag_s!(&quot;bye&quot;)))
);
println!(&quot;{:?}&quot;, get_greeting(&quot; hi &quot;));
println!(&quot;{:?}&quot;, get_greeting(&quot; bye &quot;));
println!(&quot;{:?}&quot;, get_greeting(&quot;  hola &quot;));
// Done(&quot;&quot;, &quot;hi&quot;)
// Done(&quot;&quot;, &quot;bye&quot;)
// Error(Alt)
<span class="boring">}</span></code></pre></pre>
<p>Sonuncu hatalı, çünkü &quot;hola&quot; ile eşleşen bir metnimiz yok.</p>
<p>Doğrusu <code>IResult</code> tipini iyice anlamamız gerekiyor ki daha ileriye gidebilelim; fakat neden bunu bir &quot;regex&quot; ifadesiyle kıyaslamıyoruz?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let greetings = Regex::new(r&quot;\s*(hi|bye)\s*&quot;).expect(&quot;bad regex&quot;);
    let caps = greetings.captures(&quot; hi &quot;).expect(&quot;match failed&quot;);
    println!(&quot;{:?}&quot;,caps);
// Captures({0: Some(&quot; hi &quot;), 1: Some(&quot;hi&quot;)})
<span class="boring">}</span></code></pre></pre>
<p>Doğrusu Regex göze daha <em>sade</em> görünüyor! Sadece parantez içine <code>|</code> koyduk ve bir tarafına &quot;hi&quot; diğer tarafına &quot;bye&quot; yerleştirdik. İlk sonuç girdi olarak aldığımız karakter dizisi, ikincisi de eşleşen ifade. (<code>|</code> regex için sözde &quot;çeşitlilik (alternation)&quot; operatörüdür, <code>alt!</code> makrosuna ilham vermiştir.)</p>
<p>Fakat bu basit bir regex olsa bile bir anda herkes karmaşıklaşabilir. İşin ilginci metinlerde sıkça kullanılan <code>*</code> ve <code>(</code> gibi karakterlerden kaçınmanız gerekir ve <code>(hi)</code> veya <code>(bye)</code> ile eşleşen bir regex ifadesi yazmak isterseniz sevimli regeximix <code>\s*((hi | bye))\s*</code> gibi ucube bir hâl alacaktır. Bunun Nom muadili, gayet anlaşılır bir biçimde <code>alt!(tag_s!(&quot;(hi)&quot;) | tag_s!(&quot;(bye)&quot;))</code> şeklindedir.</p>
<p>İşin kötüsü <code>regex</code> kütüphanesi ağır bir bağımlılıktır. Ananıza babanıza ancak verebileceğiniz bu i5 işlemcili laptota &quot;Merhaba Dünya&quot; seviyesi Nom örneklerinin derlenmesi sadece 0.55 saniye sürüyor. Fakat aynı şey regex için 0.90 saniye sürüyor. Aynı şekilde <code>strip</code> komutu uygulanmış ikili programın boyutu 0.3Mb tutarken (Statik linklenmiş bir Rust programının tutabileceği en küçük boyut) Regex örneği için 0.3Mb tutmaktadır. (Ç.N: Gözünüze bunlar anlamsız salt istatiksel veriler gibi görünebilir, ancak program büyüdükçe bu kütüphaneler kullanıldıkça bu farkın nasıl da katlanarak artacağını gözünüzde canlandırın.)</p>
<h2 id="nom-ayrıştırıcısı-bize-ne-döner"><a class="header" href="#nom-ayrıştırıcısı-bize-ne-döner">Nom Ayrıştırıcısı Bize Ne Döner?</a></h2>
<p><a href="http://rust.unhandledexpression.com/nom/enum.IResult.html">IResult</a> tipi standart <code>Result</code> tipinden daha çok şey döner. Üç ihtimal var:</p>
<ul>
<li><code>Done</code> - başarılı - sonucu ve geri kalan baytları alırsınız.</li>
<li><code>Error</code> - ayrıştırma başarısız - bir hata alırsınız.</li>
<li><code>Imcomplete</code> - (tamamlanmadı) daha fazla veriye ihtiyaç vardır.</li>
</ul>
<p>Hata ayrışma çıktısını bize dönebilen herhangi bir veriyi argüman olarak alan genellenen bir <code>dump</code> fonksiyonu yazabiliriz. Bu örnek aynı zamanda bize bildiğimiz <code>Result</code>'u dönen <code>to_result</code> metodununu nasıl kullanılabileceğini de gösterir - bu metodu veriyi ya da hatayı istediğiniz durumların çoğunda sıkça kullanacaksınızdır.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate nom;
use nom::IResult;
use std::str::from_utf8;
use std::fmt::Debug;

fn dump&lt;T: Debug&gt;(res: IResult&lt;&amp;str,T&gt;) {
    match res {
      IResult::Done(rest, value) =&gt; {println!(&quot;Done {:?} {:?}&quot;,rest,value)},
      IResult::Error(err) =&gt; {println!(&quot;Err {:?}&quot;,err)},
      IResult::Incomplete(needed) =&gt; {println!(&quot;Needed {:?}&quot;,needed)}
    }
}


fn main() {
    named!(get_greeting&lt;&amp;str,&amp;str&gt;,
        ws!(
            alt!( tag_s!(&quot;hi&quot;) | tag_s!(&quot;bye&quot;))
        )
    );

    dump(get_greeting(&quot; hi &quot;));
    dump(get_greeting(&quot; bye hi&quot;));
    dump(get_greeting(&quot;  hola &quot;));

    println!(&quot;result {:?}&quot;, get_greeting(&quot; bye  &quot;).to_result());
}
// Done &quot;&quot; &quot;hi&quot;
// Done &quot;hi&quot; &quot;bye&quot;
// Err Alt
// result Ok(&quot;bye&quot;)</code></pre></pre>
<p>Ayrıştırıcılar bize ayrıştırılmamış verileri de dönüyor ve yeterince girdi almadıklarını da ortaya çıakrırlar, fakat genellikle <code>to_result</code>'u tercih edeceksiniz.</p>
<h2 id="ayrıştırıcıları-birleştirmek"><a class="header" href="#ayrıştırıcıları-birleştirmek">Ayrıştırıcıları Birleştirmek</a></h2>
<p>Selamlama örneğimizle devam edelim ve &quot;hi&quot; veya &quot;bye&quot;, artı bir isimden oluşan bir selamlama tasarlayalım. <code>nom::alpha</code> alfabetik karakter serileriyle eşleşecek <code>pair!</code> ise iki ayrıştırıcıyı tek bir demekte birleştirecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(full_greeting&lt;&amp;str,(&amp;str,&amp;str)&gt;,
        pair!(
            get_greeting,
            nom::alpha
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; hi Bob  &quot;).to_result());
// result Ok((&quot;hi&quot;, &quot;Bob&quot;))
<span class="boring">}</span></code></pre></pre>
<p>Şimdi, selamlayıcımızın pek sosyal olduğunu veya kimsenin adını bilmediğini de hesaba katalım, ismi opsiyonel yapalım. Doğal olarak demetteki ikinci veri bir <code>Option</code> olacaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(full_greeting&lt;&amp;str, (&amp;str,Option&lt;&amp;str&gt;)&gt;,
        pair!(
            get_greeting,
            opt!(nom::alpha)
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; hi Bob  &quot;).to_result());
    println!(&quot;result {:?}&quot;, full_greeting(&quot; bye ?&quot;).to_result());
// result Ok((&quot;hi&quot;, Some(&quot;Bob&quot;)))
// result Ok((&quot;bye&quot;, None))
<span class="boring">}</span></code></pre></pre>
<p>Selamlama için kullandığımız ayrıştırıcı ile isimleri yakalayan ayrıştırıcıyı birleştirmenin ve isim yakalamayı opsiyonel yapmanın ne seviye kolay olduğuna dikkat edin. Bu Nom'un geldiği gücün kaynağıdır ve bu yüzden ona &quot;ayrıştırıcıları birleştiren kütüphane&quot; (parse combinator library) denir. Basit ayrıştırıcılardan birleşerek inşa olan karmaşık ayrıştırıcılar inşa edebilir ve bunları teker teker test edebilirsiniz. (Buna eşdeğer bir regex bir Perl programı gibi görünmeye başlardı: çünkü regexlerin birleşmesi pek hayra alamet değildir.)</p>
<p>Fakat, henüz istediğimiz noktaya varamadık! <code>full_greeting(&quot; bye &quot;)</code> bize bir <code>Incomplete</code> hatası olarak dönecektir. Nom için &quot;bye&quot;dan sonra isim gelmelidir ve bu yüzden bizden isim namına bir şeyler isteyecektir. Bu bir <em>akış ayrıştırıcısının (streaming parser)</em> çalışmasının nasıl çalışması gerektiğidir, bu sayede dosyaları parça parça iletebilirsiniz; ancak burada Nom'a girdinin yetersiz olacağını bildirmemiz gerekir. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(full_greeting&lt;&amp;str,(&amp;str,Option&lt;&amp;str&gt;)&gt;,
        pair!(
            get_greeting,
            opt!(complete!(nom::alpha))
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; bye &quot;).to_result());
// result Ok((&quot;bye&quot;, None))
<span class="boring">}</span></code></pre></pre>
<h2 id="numaraları-ayrıştırmak"><a class="header" href="#numaraları-ayrıştırmak">Numaraları Ayrıştırmak</a></h2>
<p>Nom bir dizi rakam serisini taramaya yarayan  <code>digit</code> fonksiyonuna sahiptir. <code>map!</code> kullanarak bir yazıyı bir sayıya dönüştürebilir ve bir <code>Result</code> tipi içinde geri dönebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::digit;
use std::str::FromStr;
use std::num::ParseIntError;

named!(int8 &lt;&amp;str, Result&lt;i8,ParseIntError&gt;&gt;,
    map!(digit, FromStr::from_str)
);

named!(int32 &lt;&amp;str, Result&lt;i32,ParseIntError&gt;&gt;,
    map!(digit, FromStr::from_str)
);

println!(&quot;{:?}&quot;, int8(&quot;120&quot;));
println!(&quot;{:?}&quot;, int8(&quot;1200&quot;));
println!(&quot;{:?}&quot;, int8(&quot;x120&quot;));
println!(&quot;{:?}&quot;, int32(&quot;1202&quot;));

// Done(&quot;&quot;, Ok(120))
// Done(&quot;&quot;, Err(ParseIntError { kind: Overflow }))
// Error(Digit)
// Done(&quot;&quot;, Ok(1202))
<span class="boring">}</span></code></pre></pre>
<p>Burada <code>Result</code>'a dönüşebilen bir <code>IResult</code> ayrıştırıcısı elde ederiz - ve  elbette ki, burada mümkün olan birden çok hata vardır. Fonksiyonların içeriklerinin aynı olduğuna dikkat edin, esas dönüşüm fonksiyonun döndüğü tipe bağlıdır.</p>
<p>Sayıların işareti olabilir. Sayıları bir çift parça hâlinde yakabilirsiniz; önce bir işaret gelir ardından rakam gelir.</p>
<p>Mesela: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>named!(signed_digits&lt;&amp;str, (Option&lt;&amp;str&gt;,&amp;str)&gt;,
    pair!(
        opt!(alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;))),  // maybe sign?
        digit
    )
);

println!(&quot;signed {:?}&quot;, signed_digits(&quot;4&quot;));
println!(&quot;signed {:?}&quot;, signed_digits(&quot;+12&quot;));
// signed Done(&quot;&quot;, (None, &quot;4&quot;))
// signed Done(&quot;&quot;, (Some(&quot;+&quot;), &quot;12&quot;))
<span class="boring">}</span></code></pre></pre>
<p>Eğer hedefe odaklıysanız ve ara sonuçları atlamak istiyorsanız, <code>recognize!</code> istediğiniz şeyi verebilir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>named!(maybe_signed_digits&lt;&amp;str,&amp;str&gt;,
    recognize!(signed_digits)
);

println!(&quot;signed {:?}&quot;, maybe_signed_digits(&quot;+12&quot;));
// signed Done(&quot;&quot;, &quot;+12&quot;)
<span class="boring">}</span></code></pre></pre>
<p>Bu teknikle noktalı sayıları da yakalayabiliriz. Bu eşleşmeler üzerinden bayt dilimlerinden karakter dizilerine ulaşıyoruz.  <code>tuple!</code>, <code>pair!</code>'in oluşturulan demetle ilgilenmediğimiz türünden bir muadili. <code>complete!</code> ise &quot;yarım kalan selamlama&quot;da yaşadığımız sorunu çözmek için kullandığımız bir araç - &quot;12&quot;, noktalı olmasa da aslında geçerli bir sayıdır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>named!(floating_point&lt;&amp;str,&amp;str&gt;,
    recognize!(
        tuple!(
            maybe_signed_digits,
            opt!(complete!(pair!(
                tag_s!(&quot;.&quot;),
                digit
            ))),
            opt!(complete!(pair!(
                alt!(tag_s!(&quot;e&quot;) | tag_s!(&quot;E&quot;)),
                maybe_signed_digits
            )))
        )
    )
);
<span class="boring">}</span></code></pre></pre>
<p>Yardımcı olacak minik bir makro tanımlayarak bazı geçerli testler üretebilriz. Bu testler, <code>floating _point</code> verilen metinden sayı yakalayabildiyse geçerli sonuç verecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! nom_eq {
    ($p:expr,$e:expr) =&gt; (
        assert_eq!($p($e).to_result().unwrap(), $e)
    )
}

nom_eq!(floating_point, &quot;+2343&quot;);
nom_eq!(floating_point, &quot;-2343&quot;);
nom_eq!(floating_point, &quot;2343&quot;);
nom_eq!(floating_point, &quot;2343.23&quot;);
nom_eq!(floating_point, &quot;2e20&quot;);
nom_eq!(floating_point, &quot;2.0e-6&quot;);
<span class="boring">}</span></code></pre></pre>
<p>(Makrolar kodu <em>biraz</em> kirletilmiş gösterse de, testlerinizi hazırlamak faydalı bir şeydir.)</p>
<p>Ve metinleri ayrıştırıp noktalı sayılara çevirebilirsiniz. Burada akışa odaklanacağım ve hatayı uzaklaştıracağım: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(float64&lt;f64&gt;,
        map_res!(floating_point, FromStr::from_str)
    );
<span class="boring">}</span></code></pre></pre>
<p>Lütfen birbirinden karmaşık testler ayrıştırıcılar oluşturmanın adım adım nasıl mümkün olduğuna dikkat edin, her bir parçayı ayrıca test edebilirsiniz. Bu, birleştirilmiş ayrıştırıcıların regexler üzerinde güçlü bir avantajıdır. Bu gayet klasik bir programlama taktiği olan &quot;böl ve yönettir&quot;. </p>
<h2 id="Çeşitli-eşlemeler-üzerinde-işlemler"><a class="header" href="#Çeşitli-eşlemeler-üzerinde-işlemler">Çeşitli eşlemeler üzerinde işlemler</a></h2>
<p>Sabit bir sayıda örüntüyü yakalayan ve bir Rust demeti dönen <code>pairs!</code> ve <code>tuple!</code> ile tanıştık.</p>
<p>Bir de <code>many0</code> ve <code>many1</code> var - ikisi de değişken sayıda örüntüyü bir vektör içerisinde tanımlar. İkisi artasındaki fark birisinin &quot;sıfır veya daha fazla&quot;, diğerinin ise &quot;bir veya daha fazla&quot; şeyi yakalalıyor olmasıdır. (regexteki <code>*</code> ve <code>+</code> karakterini düşünün) Yani, <code>many1!(ws(float64))</code>, &quot;1 2 3&quot; şeklinde bir karakter dizisi bize <code>vec![1.0, 2.0, 3.0]</code> olarak dönmeyi tercih edecek ancak boş bir karakter dizisinde hata verecektir.</p>
<p><code>fold_many0</code> ise bir <em>azaltma (reduce)</em> işlemidir. Ayrıştırılan değerler tek bir değerde bir ikili operatör kullanılarak tek bir değerde toplanır. Mesela, Rust programcıları döngüleyicilerin içeriğini toplamak kullanmak için <code>sum</code> gelmeden önce ne yapıyorsa bu da ona benzer; aşağıdaki <code>fold</code> <em>işleyici (accumulator)</em> için bir başlangıç değerine (burada sıfır) sahiptir ve işleyicinin ne yapacağını bildirmesi için <code>+</code> operatörünü kullanır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let res = [1,2,3].iter().fold(0,|acc,v| acc + v);
    println!(&quot;{}&quot;,res);
    // 6
<span class="boring">}</span></code></pre></pre>
<p>Nom muadili şöyledir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(fold_sum&lt;&amp;str,f64&gt;,
        fold_many1!(
            ws!(float64),
            0.0,
            |acc, v| acc + v
        )
    );

    println!(&quot;fold {}&quot;, fold_sum(&quot;1 2 3&quot;).to_result().unwrap());
    //fold 6
<span class="boring">}</span></code></pre></pre>
<p>Şimdiye dek bütün ifadeleri yakalamaya çalıştık veya eşleşen baytları <code>recognize!</code> ile aldık:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(pointf&lt;(f64,&amp;[u8],f64)&gt;,
        tuple!(
            float64,
            tag_s!(&quot;,&quot;),
            float64
        )
    );

    println!(&quot;got {:?}&quot;, nom_res!(pointf,&quot;20,52.2&quot;).unwrap());
 //got (20, &quot;,&quot;, 52.2)
<span class="boring">}</span></code></pre></pre>
<p>Karmaşık ifadeler için, ayrıştırıcıların bütün sonuçlarını almış olmak bizi dağınık bir çalışma prensibine sokar! Daha iyisini yapabiliriz.</p>
<p><code>do_parse!</code> sadece ihtiyacınız olan değerlere erişmesinize izin verir. Yakalanan veriler <code>&gt;&gt;</code> ile ayrılır - ilginizi çeken verileri <code>isim: ayrıştırıcı</code> formatında işaretleyebilirsiniz. Son olarak, parantezler arasında kodunuzu belirtirsiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
    struct Point {
        x: f64,
        y: f64
    }

    named!(pointf&lt;Point&gt;,
        do_parse!(
            first: float64 &gt;&gt;
            tag_s!(&quot;,&quot;) &gt;&gt;
            second: float64
            &gt;&gt;
            (Point{x: first, y: second})
        )
    );

    println!(&quot;got {:?}&quot;, nom_res!(pointf,&quot;20,52.2&quot;).unwrap());
// got Point { x: 20, y: 52.2 }
<span class="boring">}</span></code></pre></pre>
<p>İlgilenmediğimiz değerleri (bu örnekte olduğu gibi virgül) bir isme bağlamıyoruz ve iki noktalı sayıyı bir yapı oluşturmak için geçici isimlere atıyoruz. Parantezler içinde kalan kısım ise bir Rust kodu olmalı.</p>
<h2 id="aritmatik-İfadeleri-ayrıştırmak"><a class="header" href="#aritmatik-İfadeleri-ayrıştırmak">Aritmatik İfadeleri Ayrıştırmak</a></h2>
<p>Gerekli bilgiler sayesinde basit aritmatik ifadeleri ayrıştırabiliriz. İşte regexlerle yapamayacağınız şeylere güzel bir örnek.</p>
<p>Aşağıda yapmaya çalıştığımız şey ifadelerimizi ayıklayacak şeyi basitten karmaşığa doğru inşa etmektir. İfadeler eklenip çıkartılabilir <em>terimlerden (term)</em> oluşur. Terimler ise çarpılıp bölünebilir <em>faktörlerden</em> oluşur. Ve (şimdilik), faktörler sadece noktalı sayılardır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(factor&lt;f64&gt;,
        ws!(float64)
    );

    named!(term&lt;&amp;str,f64&gt;, do_parse!(
        init: factor &gt;&gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;*&quot;) | tag_s!(&quot;/&quot;)),
                factor
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;*&quot; {acc * v.1} else {acc / v.1}
            }
        )
        &gt;&gt; (res)
    ));

    named!(expr&lt;&amp;str,f64&gt;, do_parse!(
        init: term &gt;&gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;)),
                term
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;+&quot; {acc + v.1} else {acc - v.1}
            }
        )
        &gt;&gt; (res)
    ));

<span class="boring">}</span></code></pre></pre>
<p>İfadelerimiz daha net ifade edilmiş oldu - bir ifade bir terimden ve artılı eksili daha fazla terimden oluşur. Onları biriktirmiyoruz, fakat uygun operatör vasıtasıyla <em>işliyoruz. (fold)</em> (Bunun gibi durumlarda Rust, ifadenin türünü tam olarak anlayamadığından işin içinden çıkamaz ve bir ipucu ister). Bu sayede işlem önceliğini sağlamış oluruz - <code>*</code> her zaman <code>+</code> gibi şeyler.</p>
<p>Noktalı sayılar için test ifadelerine ihtiyacımız olacak, ve <a href="http://brendanzab.github.io/approx/approx/index.html">bunun için bir sandık var.</a>.</p>
<p>Cargo.toml dosyanıza <code>approx=0.1.1</code> satırını ekleyin ve işimize bakalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate approx;
...
    assert_relative_eq!(fold_sum(&quot;1 2 3&quot;).to_result().unwrap(), 6.0);
<span class="boring">}</span></code></pre></pre>
<p>Bir küçük bir test makrosu yazalım. <code>stringify!</code>, ifadeyi bir karakter dizisi ifadesine dönüştürür ve bunu <code>expr</code> içerisine argüman olarak iletebiliriz, sonra da sonucu Rust'ın bulacağı ifadenin sonucu ile kıyaslayalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    macro_rules! expr_eq {
        ($e:expr) =&gt; (assert_relative_eq!(
            expr(stringify!($e).to_result().unwrap(),
            $e)
        )
    }

    expr_eq!(2.3);
    expr_eq!(2.0 + 3.0 - 4.0);
    expr_eq!(2.0*3.0 - 4.0);
<span class="boring">}</span></code></pre></pre>
<p>Şükela - sadece birkaç satırla ifade işleyicisi tanımladık! Daha iyi olabilir. <code>factor</code> içindeki numaralara bir alternatif ekleyebiliriz - parantez içindeki ifadeler için:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    named!(factor&lt;&amp;str,f64&gt;,
        alt!(
            ws!(float64) |
            ws!(delimited!( tag_s!(&quot;(&quot;), expr, tag_s!(&quot;)&quot;) ))
        )
    );

    expr_eq!(2.2*(1.1 + 4.5)/3.4);
    expr_eq!((1.0 + 2.0)*(3.0 + 4.0*(5.0 + 6.0)));
<span class="boring">}</span></code></pre></pre>
<p>Şükelalık ifadenin artık terimler açısından <em>özyinemeli (recursively)</em> olarak çağrılmasıdır!</p>
<p><code>delimited!</code> makrosunun özel sırrı parantezlerin iç içe olabilmesidir - Nom parantezlerin kapandığından emin olacaktır.</p>
<p>Regexin yapabileceklerinin çok çok ötesindeki ve <code>strip</code> uygulanmış ikili dosyamız sadece 0.5Mb, ki  hâlen daha ekrana &quot;Merhaba Dünya&quot; yazdıran regex programımızın yarısı kadar ediyor bu.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-ve-Çektirdiği-Çile"><a class="header" href="#rust-ve-Çektirdiği-Çile">Rust ve Çektirdiği Çile</a></h2>
<p>Rust'ın öğrenmesi pek çok &quot;ana akım&quot; dillere kıyasla öğrenmesi zor dillerden olduğunu söylemek doğru olur. Bazı istisnası insanlar o kadar da zor bulmuyor, fakat &quot;istisna&quot; ne anlama gelir buna dikkat edin - onlar <em>istinaidir</em>. Çoğu insan başta zorlanır ama sonra başarır. Başlangıçta çektiğiniz çilelerle neticede elde edeceğiniz şeyler arasında bir bağlantı yoktur.</p>
<p>Hepimiz bir yerlerden geliyoruz ve bu Python gibi &quot;dinamik&quot; veya &quot;C++&quot; gibi &quot;statik&quot; ana akım dilleriyle muhatap olmuş olduğumuz anlamına gelir. Her koşulda, Rust programlama anlayışımızı yeniden inşa etmeye zorlayacak kadar farklıdır. Zeki ve tecrübeli insanlar bu işin içine girip kendi zekiliklerinin fayda etmediğini görünce bir hayal kırıklığına uğruyorlar; kendisine yeterince değer vermeyenler de düşündükleri kadar &quot;zeki&quot; olmadıklarını düşünüyorlar.</p>
<p>Dinamik programlama tecrübesi olanlar (buna Java'yı da dahil edebilirim) her şeyin bir referans ve referansların da varsayılan olarak değişebilir olduğunu düşünür. Çöp toplayıcıları da bellek açısından emniyetli programlama yapmamıza yardımcı <em>olur</em>. Daha fazla bellek kullanımı ve öngörülememezlik pahasına da olsa JVM'i daha hızlı hâle getirmek için çok şey yapıldı. Bazen buna değer diye düşünülür, hiç modası geçmeyen bir fikir programcı üretkenliğinin bilgisayar performansından daha önemli olduğudur.</p>
<p>Fakat dünyadaki pek çok bilgisayarın - mesela arabalardaki gaz kelebeğini kontrol etmek gibi gibi hayati önemde şeyler yapan minik bir bilgisayarın - en ucuz laptop kadar kaynağa sahip değildir ve olaylara <em>eşzamanlı (realtime)</em> olarak cevap vermesi gerekir. Aynı şekilde yazılım altyapılarının doğru, sağlam ve hızlı olması gerekir. (Eski bir mühendislik kuralı). Şimdiye dek bu tarz işler kendi yapısı gereği hiçbir emniyet bulundurmayan C ve C++ ile yapıldı - bu raddedeki <em>emniyetsizliğin</em> toplam maaliyeti dikkat edilmesi gereken genel şey oldu. Bir programı çalışır hâle getirmek kolaydır, ama esas olay buradan sonra başlar.</p>
<p>Sistem programlama dillerinde bir çöp toplayıcısı bulunamaz çünkü onlar her şeyin üzerine inşa edildiği bina temelidir. Kaynakların sizin ihtiyaç duyduğunuz ve uygun gördüğünüz şekilde kullanılmasını sağlarlar. </p>
<p>Eğer çöp toplayıcısı olmazsa bellek başka türde şekillerde yönetilir. Manuel bellek yönetiminde belleği alırsınız, kullanırsınız ve bunu geri verirsiniz - kulağa kolay gibi gelse de aslında oldukça zordur. Üretken ve facia yaratmaya elverişli bir C programcısı olmak sizin için bir hafta sürer - ancak ne yaptığını bilen, bütün muhtemel hataları kontrol eden iyi bir C programcısı olmak yıllar sürer. </p>
<p>Rust belleği modern C++ gibi yönetir, nesneler yok edildiği zaman arka kalan bellek tekrar kullanılabilir. <code>Box</code> ile heap üzerinde bellek tahsis edebilirsiniz, ancak bu fonksiyon bittiğinde <code>Box</code> &quot;kapsam sonuna&quot; ulaşmış olur. <code>new</code> diye bir şey var ancak <code>delete</code> diye bir şey yok. <code>File</code> oluşturabilirsiniz, (önemli bir kaynak olan) dosya iş bittiğinde kendiliğinden kapatılır. Buna Rust'ta <em>düşürme (dropping)</em> denir.</p>
<p>Kaynakları paylaşmanız gerekir, her şeyin kopyasını üretmek verimsizdir, işi ilginç kılar da budur. C++'da da referanslar vardır ve Rust referansları daha çok C işaretçilerine benzer - veriye ulaşmak için <code>*r</code> kullanmanız gerekir ve veri referansını iletmek için de <code>&amp;</code>  kullanırsınız.</p>
<p>Rust'ın <em>ödünç alma denetçisi (borrow checker)</em> esas veri yok edildikten sonra referansının var olma ihtimalini ortadan kaldırır. </p>
<h2 id="tip-Çıkarımı"><a class="header" href="#tip-Çıkarımı">Tip Çıkarımı</a></h2>
<p>&quot;Statik&quot; ve &quot;dinamik&quot; arasındaki fark her şey değildir. Her şeyde olduğu gibi bu da çok katmanlı bir konudur. C, statik tipli (her değişkenin derleme zamanında tipi vardır) ancak zayıf tipli (weakly typed) (mesela <code>void*</code> her şeye işaret edebilir) bir dildir; Python ise dinamik tipli (Tip değişkende tanımlanmaz değil veriyle beraber gelir) fakat güçlü tipli (strongly typed) bir dildir. Java ise statik/güçlümtraktır (akla uygun görünen fakat tehlikeli olabilen veri dönüştürme (?) mekanizmasıyla) ve Rust ise statik/güçlüdür; çalışma zamanında gizlice veri dönüştürmez.</p>
<p>Java her bir tipin ne olduğunun detaylıca yazdırdığı yaygın olarak bilinirken Rust tipleri <em>tahmin (infer)</em> etmeyi sever. Bu genelde zekicedir ancak fakat bazen hangi tiple çalıştığınızı merak edersiniz. Mesela <code>let n = 100</code> gibi bir ifade görürsünüz ve merak edersiniz - bu sayının değeri ne? Varsayılan olarak bu <code>i32</code>dir, dort bitlik işaretli sayı. Herkes C'nin belirsiz sayı tiplerinin (<code>int</code> ve <code>long</code> gibi) kötü bir fikir olduğundan emindir, açık olmak en iyisidir. Bazen tipi belirtebilirsiniz, mesela <code>let n: u32 = 100</code> gibi ya da sayıyla beraber tipi de belirtebilirsiniz; <code>let n = 100u32</code> gibi. Ama tip çıkarımı dediğimi şey bundan ibaret değil! Eğer <code>let n = 100</code> yazarsanız <code>rustc</code> bunun <em>bir çeşit</em> sayı olduğunu bilir. <code>n</code> değişkenini bir yere iletirseniz ve fonksiyon <code>u64</code> bekliyorsa <code>n</code>'in tipi <code>u64</code> olacaktır!</p>
<p>Bu noktadan sonra eğer <code>u32</code> bekleyen bir yerde <code>n</code> değişkenini kullanırsanız <code>rustc</code> buna izin vermeyecektir çünkü <code>n</code>'in tipi <code>u64</code> olarak işaretlenmiştir ve bunu dönüştürmenin gizli ve kolay bir yolu olma<em>ya</em>caktır. İşte bu güçlü tiplemedir - &quot;Interger overflow&quot;dan muzdarip olana dek hayatınızı kolaylaştıracak ufak tip dönüşümleri Rust'ta yoktur. Açıkça <code>n</code> değerini <code>n as u32</code> olarak iletmeniz gerekir - Rust'ta tipler böyle dönüştürülür. Neyse ki, <code>rustc</code> sorunları müdahale edilebilirken vermekte iyidir - derleyicinin tavsiyesiyle sorunu düzeltebilirsiniz. </p>
<p>Bu sayede Rust açık tip ifadeleri olmaksızın yazılabilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();
// v is deduced to have type Vec&lt;i32&gt;
v.push(10);
v.push(20);
v.push(&quot;hello&quot;) &lt;--- Bunu yapma işte, yapma
<span class="boring">}</span></code></pre></pre>
<p>Bir sayı vektörüne karakter dizisi iletememek bir sorun değil, özelliktir. Dinamik tipleme esnek olduğu kadar beladır da.</p>
<p>(Eğer bir vektör tipine hem sayı hem de karakter dizisi iletmeniz lazımsa, Rust'ın <code>enum</code> tipleri bu işi emniyetlice görür.)</p>
<p>Bazen ufak bir <em>ipucu</em> vermeniz gerekir. <code>collect</code> çok güzel bir döngüleyici metotudur, ama bazen ipucuna ihtiyaç duyar. Mesela <code>char</code> üzerinde çalışan bir döngüleyicim var. <code>collect</code> iki farklı biçimde çalışır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a vector of char ['h','e','l','l','o']
let v: Vec&lt;_&gt; = &quot;hello&quot;.chars().collect();
// a string &quot;doy&quot;
let m: String = &quot;dolly&quot;.chars().filter(|&amp;c| c != 'l').collect();
<span class="boring">}</span></code></pre></pre>
<p>Bazen değişken tipinden emin olamazsanız bunun da ufak bir yolu var, o da <code>rustc</code>'yi işleme alınan tipi bir hata mesajında yazdırmaktır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: () = var;
<span class="boring">}</span></code></pre></pre>
<p><code>rustc</code> aşırı spesifik bir tip seçebilir. Burada farklı referansları <code>&amp;Debug</code> vektörüne koyuyoruz ancak tipleri açıkça belirtmemiz gereklidir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

let answer = 42;
let message = &quot;hello&quot;;
let float = 2.7212;

let display: Vec&lt;&amp;Debug&gt; = vec![&amp;message, &amp;answer, &amp;float];

for d in display {
    println!(&quot;got {:?}&quot;, d);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="değişebilir-referanslar"><a class="header" href="#değişebilir-referanslar">Değişebilir Referanslar</a></h2>
<p>Kural basit: bir anda sadece değişken referans olabilir. Bunun sebebi değişimin <em>her yerde</em> gerçekleşmesinin önüne geçmek. Küçük programlar yazarken fark etmiyor olabilirsiniz ancak büyük kod yapılarında başınıza ciddi bela olabilir.</p>
<p>Bir diğer kural ise ortada değişemez referanslar varken değişebilir referans elde edemiyor oluşunuzdur. Aksi takdirde kimse bu değişemez referansların değişemeyeceğini garantezi edemezdi. C++ da değişemez referanslara sahiptir (mesela <code>const string&amp;</code>) gibi ancak başka birisinin <code>string&amp;</code> referansı alıp veriyi değiştiremeyeceğini garanti <em>edemez</em>.</p>
<p>Her referansın değişebilir olduğu dillerle çalışmaya alışıksanız bu size ters gelecektir. Emniyetsiz, &quot;rahat&quot; diller tamamen programcının kötü bir şey yapmayacağına ve kendi programını kesinlikle iyi bir şekilde anladığını düşünerek çalışır. Fakat bir kişiden daha fazla kişi tarafından geliştirilmiş büyük programlar bir kişinin programın ne olduğunu anlayıp anlamamasından çok daha ötededir.</p>
<p>İşin <em>gıcık eden</em> eden tarafı ödünç alma denetçisinin düşündüğümüz kadar zeki olmamasıdır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut m = HashMap::new();
m.insert(&quot;one&quot;, 1);
m.insert(&quot;two&quot;, 2);

if let Some(r) = m.get_mut(&quot;one&quot;) { // &lt;-- mutable borrow of m
    *r = 10;
} else {
    m.insert(&quot;one&quot;, 1); // can't borrow mutably again!
}
<span class="boring">}</span></code></pre></pre>
<p>Eğer <code>None</code> elde etmişsek HashMap'ten hiçbir şey ödünç alınmıyor, yani burada <em>gerçekten</em> hiçbir şey ödünç alma kurallarını çiğnemiyor.</p>
<p>Hâliyle iş çirkinleşiyor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut found = false;
if let Some(r) = m.get_mut(&quot;one&quot;) {
    *r = 10;
    found = true;
}
if !found {
    m.insert(&quot;one&quot;, 1);
}
<span class="boring">}</span></code></pre></pre>
<p>Rezalet olsa da işe yarıyor çünkü sadece &quot;if&quot; ifadesinde bir adet referasımız tutulmuş oluyor.</p>
<p>Daha iyisi <code>HashMap</code> içindeki <a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">entry</a> metotunu kullanmaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::hash_map::Entry;

match m.entry(&quot;one&quot;) {
    Entry::Occupied(e) =&gt; {
        *e.into_mut() = 10;
    },
    Entry::Vacant(e) =&gt; {
        e.insert(1);
    }
};
<span class="boring">}</span></code></pre></pre>
<p>Ödünç alma mekanizmasının bu sıralar <em>sözcüksel olmayan yaşam süreleri (non-lexical lifetimes)</em> hakkında daha yumuşak olacağı konuşuluyor. </p>
<p>Yine de ödünç alma mekanizması bazı önemli vakaları <em>anlıyor</em>. Mesela bir yapınız varsa alanları bağımsız olarak ödünç alınabilir. Birleşke mantığı işinize yarayacaktır, büyük yapılar (struct) kendi metotları olan daha ufak yapıları barındırmalıdır. Değişken metotları büyük yapılar içinde tanımlamak, tek bir alan değiştirilmiş olsa bile bütün yapının değiştirilemeyeceği durumlara yol açacaktır.</p>
<p>Değişebilir verilerin söz konusu olduğu durumlarda verilerin parçalarının bağımsız olarak işlendiği özel durumlar vardır. Örneğin değişebilir bir diliminiz varsa, <code>split_at_mut</code> size değişebilir iki referans verecektir. Bu gayet emniyetlidir çünkü Rust bu iki dilimin kazara aynı verileri sahiplenmeyeceğinden emin olacaktır.</p>
<h2 id="referanslar-ve-yaşam-süreleri"><a class="header" href="#referanslar-ve-yaşam-süreleri">Referanslar ve Yaşam Süreleri</a></h2>
<p>Rust, referasın veriden daha uzun süre yaşadığı durumlara izin vermez. Aksi taktirde ölü veriye işaret eden &quot;ölü referanslarımız&quot; bulurdu - <code>segfault</code> kaçınılmaz olurdu.</p>
<p><code>rustc</code> genelde fonksiyonlardaki yaşam süreleri hakkında mantıklı çıkarımlar yapabilir:</p>
<pre><pre class="playground"><code class="language-rust">fn pair(s: &amp;str, ch: char) -&gt; (&amp;str, &amp;str) {
    if let Some(idx) = s.find(ch) {
        (&amp;s[0..idx], &amp;s[idx+1..])
    } else {
        (s, &quot;&quot;)
    }
}
fn main() {
    let p = pair(&quot;hello:dolly&quot;, ':');
    println!(&quot;{:?}&quot;, p);
}
// (&quot;hello&quot;, &quot;dolly&quot;)</code></pre></pre>
<p>Gayet emniyetlidir çünkü burada herhangi bir sınırlayıcı yoktur. <code>rustc</code> iki karakter dizisinin de fonksiyona aktarılan karakter dizisinin referansları olduğuna karar verir.</p>
<p>Aslında fonksiyon tanımı şu şekildedir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pair&lt;'a&gt;(s: &amp;'a str, ch: char) -&gt; (&amp;'a str, &amp;'a str) {...}
<span class="boring">}</span></code></pre></pre>
<p>Bu noktasyon çıktıdaki karakter dizilerinin <em>en fazla</em> girdideki karakter dizileri kadar yaşayacağına karar verir. Yaşam sürelerinin aynı olduğu anlamına gelmez bu, onları istediğimiz an düşürebiliriz, sadece &quot;<code>s</code>&quot;ten fazla yaşamayacağını belirtiriz.</p>
<p>Yani, <code>rustc</code> <em>yaşam süresi saptaması (lifetime ellision/?)</em> işimizi biraz daha rahatlatır. </p>
<p>Şimdi eğer fonksiyon <em>iki</em> karakter dizisi alırsa, yaşam sürelerini açıkça belirtmemiz gerekir ki hangi çıktının hangi girdiyi referans aldığını bilmiş olalım.</p>
<p>Bir referans tutan bir yapı tanımladığımız sırada neyin ne kadar yaşam ömrü olduğunu belirtmeliyiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Container&lt;'a&gt; {
    s: &amp;'a str
}
<span class="boring">}</span></code></pre></pre>
<p>Burada da yapının referanstan daha uzun süre yaşamayamayacağını vurgulamış oluyoruz. Hem yapılar hem de fonksiyonlar için yaşam süresinin <code>&lt;&gt;</code> içerisinde tıpkı tip belirtilir gibi belirtilmesi gereklidir.</p>
<p>Kapamalar gayet akılcı ve güçlü bir özelliktir - Rust kapamalarının gücü buradan gelir. Eğer onları bir yerde saklamak isterseniz onlara bir yaşam süresi belirtmeniz gerekir. Çünkü kapamalar kendi özünde çevresinden referanslar alan ve çağrılabilen bir yapıdır. Mesela <code>m</code> ve <code>c</code> şeklinde değişemez referanslar alabilen <code>linear</code> kapamasına bakalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let m = 2.0;
let c = 0.5;

let linear = |x| m*x + c;
let sc = |x| m*x.cos()
...
<span class="boring">}</span></code></pre></pre>
<p><code>linear</code> ve <code>sc</code> kapamalarının ikisi de <code>Fn(x: f64) -&gt; f64</code> özelliğine sahiptir ancak ikisi de aynı yaratık <em>değildir</em> - ikisinin de farklı tipleri ve boyutları vardır! Eğer saklamak isterseniz tiplerini <code>Box&lt;Fn(x: f64)-&gt;f64 + 'a&gt;</code> olarak belirtilmelilerdir.</p>
<p>JavaScript veya Lua'da kapamaların nasıl da su gibi aktığına görmüşseniz size biraz sinir bozucu gelecektir. Ancak C++ da Rust ile aynı şeyi yapar ve sanal çağrılar için ufak bir bedel karşılığında farklı türden kapamaları saklamak için <code>std::function</code>'a ihtiyaç duyar.</p>
<h2 id="karakter-dizileri"><a class="header" href="#karakter-dizileri">Karakter Dizileri</a></h2>
<p>Rust'ta karakter dizilerinin başlangıçta sinir bozucu gelmesi olağandır. Onları üretmenin birden çok yolu vardır ve hepsi gereksiz detaylı gelir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;hello&quot;.to_string();
let s2 = String::from(&quot;dolly&quot;);
<span class="boring">}</span></code></pre></pre>
<p>&quot;hello&quot; hâli hazırda bir karakter dizisi değil midir? Yani, bir şekilde. <code>String</code> <em>sahipli</em> bir karakter dizisidir ve heap üzerinde yer tutar. Bir karakter dizisi kalıbı olan <code>&amp;str</code> (karakter dizisi dilimi) tipi ise (sabit olarak) çalıştırılabilir dosyanın içinde bekler ya da <code>String</code>'ten ödünç alınarak oluşturulur. Sistem programlama dillerinin bu ayrıma ihtiyacı vardır - ufak bir mikrokontrollerı düşünür, azıcık RAM ve biraz daha fazla RM'u bulunur. Karakter dizisi kalıpları daha az enerji harcayan ve ucuz olan ROM'da (&quot;read-only/salt okunur&quot;) depolanır. </p>
<p>Fakat bu C++'da çok daha kolay (diyebilirsiniz):</p>
<pre><code class="language-C">std::string s = &quot;hello&quot;;
</code></pre>
<p>Kısaca evet, fakat bir karakter dizisinin örtükçe nasıl oluşturulduğunu da gizlemektedir. Rust bellek tahsis etme konusunda açık olmayı tercih eder, hâliyle <code>to_string</code> gibi şeyler var. Öbür taraftan, C++ karakter dizilerini ödünç almak için <code>c_str</code> kullanmalısınız ve C'nin karakter dizileri çok kullanışsızdır.</p>
<p>Neyse ki, Rust'ta işler çok daha iyi işliyor - <code>String</code> ve <code>&amp;str</code> tiplerinin ikisinin de gerekli olduğunu <em>bir kere</em> kabul ederseniz. <code>String</code> metotları çoğunlukla karakter dizisini değiştirmek içindir, mesela <code>push</code> bir karakter ekler (alttan alta <code>Vec&lt;u8&gt;</code> gibi çalışır). Fakat <code>&amp;str</code> metotlarının tamamına da sahiptir. <code>Deref</code> mekanizması aracılığıyla bir <code>String</code> aynı zamanda <code>&amp;str</code> olarak iletilebilir - bu yüzden nadiren fonksiyon tanımlarında <code>&amp;String</code> görürsünüz.</p>
<p>Çeşitli özellikler (trait) aracılığıyla <code>&amp;str</code>'den <code>String</code> elde etmenin pek çok yolu var. Rust özelliklerin tiplerinin genellenerek çalışmasına izin verir. Pratik bir kural olarak, <code>Display</code> özelliğine sahip her şey <code>to_string</code>'e sahiptir; <code>42.to_string()</code> gibi.</p>
<p>Bazı operatörler beklediğiniz gibi davranmaz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s1 = &quot;hello&quot;.to_string();
    let s2 = s1.clone();
    assert!(s1 == s2);  // cool
    assert!(s1 == &quot;hello&quot;); // fine
    assert!(s1 == &amp;s2); // WTF?
<span class="boring">}</span></code></pre></pre>
<p>Hatırlayın ki <code>String</code> ve <code>&amp;String</code> birbirinden farklı tiplerdir ve <code>==</code> bu tarz komibasyonlarda tanımlı değildir. C++ programlamaya alışık bir kişi değerlerin yerine referansların konulduğunu görmeyi beklediğinden şaşırabilir. Ek olarak <code>&amp;s2</code> kendiğinden <code>&amp;str</code> olmayacaktır çünkü <em>deref zorlaması</em> bir  <code>&amp;str</code> değişkeni veya argümanı atadığınız zaman çalışacaktır. (<code>s2.as_str()</code> diye açıkça ifade etmek işinize yarayacaktır.)</p>
<p>Ancak bu harbiden bir &quot;has***tir artık&quot; denmeyi hakeder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s3 = s1 + s2;  // &lt;--- no can do
<span class="boring">}</span></code></pre></pre>
<p>İki <code>String</code> değerini birleştiremezsiniz, ancak bir <code>String</code> ile <code>&amp;str</code>'i birleştirebilirsiniz. Fakat <code>&amp;str</code> ile <code>String</code>'i birleştiremezsiniz. Bu yüzden pek çok insan <code>+</code> yerine <code>format!</code> makrosunu tercih eder, biraz daha tutarlıdır ancak o kadar da verimli değildir.</p>
<p>Bazı karakter dizisi işlemleri de mevcuttur ancak farklı çalışır. Mesela pek çok dilin <code>split</code> metotu vardır ki bu da bir karakter dizisini, karakter dizisi listesine dönüştürür. Rust'ta karakter dizisi metodu bir döngüleyici döner ve bunu &quot;sonra&quot; bir vektör içerisine toplayabilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parts: Vec&lt;_&gt; = s.split(',').collect();
<span class="boring">}</span></code></pre></pre>
<p>Eğer hızlıca bir vektör almak istiyorsanız biraz göze batabilir fakat yeni bir vektörü belelkte tahsis etmeden önce birkaç işlem yapabilirsiniz. Mesela parçalanmış bir metin içerisinden en uzun kelimeyi mi almak istiyorsunuz?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let max = s.split(',').map(|s| s.len()).max().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>(Eğer doş bir döngüleyici varsa maksimum değer de olmayacaktır ve bu durumu kontrol etmek için <code>unwrap</code> kullanıyoruz.)</p>
<p><code>collect</code> metotu bize parçaların orijinal karakter dizisinden ödünç alındığı bir <code>Vec&lt;&amp;str&gt;</code> döner - sadece referanslar için bellekte alan tahsis etmemiz gerekir. C++'da çalıştığı gibi bir metot yok fakat son zamana dek her alt diziye ayrıca alan tahsis edilmesi gerekiyordu. (C++ 17 ile beraber Rust'taki <code>&amp;str</code> gibi çalışan <code>std::string_view</code> geldi.)</p>
<h2 id="noktalı-virgüller-hakkında-bir-not"><a class="header" href="#noktalı-virgüller-hakkında-bir-not">Noktalı virgüller hakkında bir not</a></h2>
<p>Noktalı virgüller bu dilde de zorunludur, fakat C'de noktalı virgül konulmaması gereken yerlerde Rust'ta da konulmaz, mesela <code>{}</code> bloklarından sonra. Aynı zamanda  <code>enum</code> ve <code>struct</code> içinde de onlara ihtiyaç yoktur. (Bu C'den gelen bir acayiplik) Fakat, eğer blok bir değer dönmeliyse noktalı virgüllere ihtiyaç kalmaz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let msg = if ok {&quot;ok&quot;} else {&quot;error&quot;};
<span class="boring">}</span></code></pre></pre>
<p>Bütün bir <code>let</code> deyiminin ardından yine bir noktalı virgül koymak zorunda olduğumuza dikkat edin!</p>
<p>Eğer noktalı karakter dizisi kalıplarından sonra noktalı virgül koysaydık bize <code>()</code> dönerdi. (<code>Nothing</code> veya <code>void</code> gibi) Bu fonksiyondan değer dönerken karşılaşılan olağan bir hatadır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sqr(x: f64) -&gt; f64 {
    x * x;
}
<span class="boring">}</span></code></pre></pre>
<p><code>rustc</code> size bu durumda açıklayıcı bir hata mesajıyla geri dönüş yapacaktır.</p>
<blockquote>
<p>Rust, Haskell ve Ruby gibi expression-based bir dildir ve bu kavramı &quot;ifade odaklı&quot;  olarak düşünebilirsiniz. Bu tarz dillerde her ifadenin bir değeri vardır </p>
</blockquote>
<h2 id="c-ile-alakalı-konular"><a class="header" href="#c-ile-alakalı-konular">C++ ile Alakalı Konular</a></h2>
<h3 id="rustta-değer-semantikleri-farklıdır"><a class="header" href="#rustta-değer-semantikleri-farklıdır">Rust'ta Değer Semantikleri Farklıdır</a></h3>
<p>C++'da ilkel tipler gibi davranacak ve kendisini kopyalayacak tipler tanımlamak mümkündür. Ek olarak, bir değerin geçici bir bağımdan başka bir bağlama nasıl taşınacağını belirlemek adına taşıma oluşturucusu kullanılır.</p>
<p>Rust'ta ilkel tipler beklendiği gibi davranır fakat <code>Copy</code> özelliği sadece kopyalanabilir türler içeriyorsa (yapılar, demetler veya numaralandırma) kullanıcının tanımladığı tiplere eklenebilir. Diğer tiplere <code>Clone</code> eklenebilir ancak bu sefer de verilerin <code>clone</code> metotunu çağırmanız gerekir. Rust, herhangi bir bellekte alan tahsis etme işleminin açıktan olmasını ister ve atama operatörlerini ya da kopyalama oluşturucularını gizlemez.</p>
<p>Yani, kopyalama ile taşıma her zaman birkaç biti hareket etmesi olarak tanımlanır ve geçersiz kılınamaz.</p>
<p>Eğer <code>s1</code> <code>Copy</code> özelliğini içermeyen bir türse <code>s2 = s1</code> bir taşımaya sebep olur ve bu <code>s1</code>'i <em>tüketir</em>!  Eğer gerçek bir kopya üretmek istiyorsanız <code>clone</code> kullanın.</p>
<p>Ödünç alma çoğu zaman kopyalamadan daha iyidir ancak bu sefer de ödünç alma kurallarını takip etmelisiniz. Neyse ki, ödünç alma işlemi yeniden düzenlenebilir bir davranıştır. Mesela <code>String</code>, <code>&amp;str</code> olarak ödünç alınabilir ve <code>&amp;str</code>'nin değişmeyen metotlarını kullanabilir. <em>Karakter dizisi dilimleri</em> de C++'ın <code>const char*</code>dan farksız <code>c_str</code> anlayışındaki ödünç alma yöntemine kıyasla çok daha güçlüdür. <code>&amp;str</code> sahiplenilmiş birkaç baytın işaretçisinden (veya bir karakter dizisi kalıbından) ve <em>boyut bilgisinden</em> oluşur. Bu, bellek açısından oldukça verimli örüntüler kurmamıza yardımcı olur. Mesela bütün karakter dizilerinin bir karakter dizisinden ödünç alındığı bir <code>Vec&lt;&amp;str&gt;</code> oluşturulabilir - tek ihtiyacınız olan vektör için ek alan olacaktır:</p>
<p>Mesela, boşluklardan bölerken:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn split_whitespace(s: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
    s.split_whitespace().collect()
}
<span class="boring">}</span></code></pre></pre>
<p>Aynı şekilde, C++'daki <code>s.substr(0,2)</code> her zaman karakter dizisinin kopyasını oluşturur ancak dilim sadece ödünç alır: <code>&amp;[0..2]</code></p>
<p>Buna benzer ilişki <code>Vec&lt;T&gt;</code> ve <code>&amp;[T]</code> arasında da bulunur.</p>
<h3 id="paylaşılan-referanslar-1"><a class="header" href="#paylaşılan-referanslar-1">Paylaşılan Referanslar</a></h3>
<p>C++'da bulunduğu gibi Rust için de <em>akıllı işaretçiler (smart pointers)</em> bulunur - mesela <code>std::unique_ptr</code> muadili <code>Box</code>tur. Bellek ve tahsis edilmiş diğer kaynaklar <code>Box</code> kapsam dışına çıktığı zaman geri iade edildiğinden <code>delete</code> kullanmaya ihtiyaç yoktur. (Rust RAII'yi epeyce benimsemiştir.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut answer = Box::new(&quot;hello&quot;.to_string());
*answer = &quot;world&quot;.to_string();
answer.push('!');
println!(&quot;{} {}&quot;, answer, answer.len());
<span class="boring">}</span></code></pre></pre>
<p>İnsanlar başlangıçta <code>to_string</code>'i başlangıçta pek sevmez ancak işleri <em>açıktan</em> yapmayı sağlar.</p>
<p>Açık dereferans operatörü olan <code>*</code> önemli ancak metotlar üzerinde herhangi bir özel notasyon kullanmadığımıza dikkat edin. (Mesela burada <code>(*answer).push('!') yok</code>)</p>
<p>Ödünç almanın sadece orijinal içeriğin sahibi belli olduğu zaman işe yaradığı açıktır. Çoğu tasarımda bu mümkün değildir.</p>
<p>Bu C++'da <code>std::shared_ptr</code>'in kullanıldığı yerdir; kopyalama sadece veri üzerindeki referans sayısını attırır. Bunun da bir bedeli var, üstelik:</p>
<ul>
<li>veri sadece salt okunabilir olsa bile, sürekli referans sayımının arttırılması önbelleğin doğrulanamamasına sebep olabilir. </li>
<li><code>std::shared_ptr</code> süreçler arası emniyetlice paylaşılabilecek şekilde tasarlanmıştır ve kendi kilidini de beraberinde taşıması kaba maliyeti arttırmaktadır.</li>
</ul>
<p>Rust'ta <code>std::rc::Rc</code> da aynı zamanda referans sayımı yapan paylaşılan akıllı işaretçi gibi davranır. Fakat, bu sadece değişemez referanslar içindir! Eğer süreç anlamında emniyetli bir türünü istiyorsanız, <code>std::sync::Arc</code> (&quot;Atomik Rc&quot;) kullanabilirsiniz. Rust iki farklı tür sunduğu için biraz tuhaf görünebilir fakat süreçlerin işin içine girmediği işlemler için kaba maliyeti arttırmamış olursunuz.</p>
<p>Değişemez referanslar olmalarının sebebi bunun Rust'ın bellek modelinin esaslarıyla olmasıyla alakalıdır. Fakat yine de sıyrılmanın bir yolu vardır: <code>std::cell:RefCell</code>. Eğer paylaşılan referansınızı <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> olarak tanımlarsanız <code>borrow_mut</code> ile değişebilir referans edinebilirsiniz. Bu sefer Rust kurallarını <em>dinamik</em> olarak uygularsınız - mesela zaten bir referans varken ek olarak <code>borrow_mut</code> kullanırsanız bir paniğe sebep olacaktır.</p>
<p>Yine de bu hâlen daha <em>emniyetlidir</em>. Panikler bellekte yanlış bir yere dokunulduğu andan <em>önce</em> gerçekleşir! Tıpkı fırlatılan hatalar gibi, çağrı sırası teker teker boşaltılır. Bu derece yapılandırılmış bir süreç için talihsiz bir kelime seçimi diyebiliriz - bu panikleyerek kapanmak yerine sıralı bir temizliktir.</p>
<p><code>Rc&lt;RefCell&lt;T&gt;&gt;</code> tipi göze biraz biraz batıyor olabilir, ancak kullanılış şekli kesinlikle kötü değil. Burada, Rust (tekrardan) işlerin açıktan yürümesini tercih etmiş oluyor.</p>
<p>Ortak durumu eğer bellek açısından güvenli bir şekilde paylaşmak istiyorsanız <code>Arc&lt;T&gt;</code> tek <em>emniyetli</em> yoldur. Eğer değişebilir erişimlere ihtiyaçlarınız varsa <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> yerine <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> kullanırsınız. <code>Mutex</code> tanımlandığından biraz daha farklı çalışır, bu veri için bir kutu görevi görür. Veriyi <code>lock</code> ile alır ve düzenlersiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let answer = Arc::new(Mutex::new(10));

// in another thread
..
{
  let mut answer_ref = answer.lock().unwrap();
  *answer_ref = 42;
}
<span class="boring">}</span></code></pre></pre>
<p>Neden <code>unwrap</code>? Eğer kilidi elinde tutan süreç paniklerse <code>lock</code> hata verir. (Resmi dokümentasyon bu tarz durumlarda <code>unwrap</code> kullanmanın mantıklı olduğunu düşünür çünkü belli bir şeyler çok yanlış gitmiş. Panikler süreçlerin içerisinde yakalanabilir.)</p>
<p>Özel kilidi mümkün olduğu sürece kısa sürece tamamlayıp işi teslim etmek (Mutexlerde her zaman olduğu gibi) önemlidir. Onları sınırlı bir kapsam içerisinde tutmak yaygın bir tercihtir - değişebilir referans kapsam dışına çıktığı zaman kilit de sona ermiş olur.</p>
<p>C++'ın sadeliği ile bunu kıyaslayınca (&quot;dostum sadece <code>shared_ptr</code> kullan&quot;) göze biraz acayip görünüyor. Fakat bu şekilde paylaşılan veriler arasındaki herhangi bir <em>düzenleme</em> daha kolay fark ediliyor ve <code>Mutex</code> kilidi örüntüsü süreç emniyetine yönlendiriyor.</p>
<p>Her şeyde olduğu gibi, paylaşılan referansları kullanırken <a href="https://news.ycombinator.com/item?id=11698784">dikkatli olun.</a>.</p>
<h3 id="döngüleyiciler"><a class="header" href="#döngüleyiciler">Döngüleyiciler</a></h3>
<p>C++'da döngüleyiciler olağan bir yoldan yapılamaz; akıllı işaretçilere sahiptirler ve genellikle <code>c.begin()</code> ile başlar ve <code>c.end()</code> ile biterler. Döngüleyiciler üzerindeki operasyonlar yalnız başına şablon fonksiyonları olarak kullanılır, <code>std::find_if</code> gibi.</p>
<p>Rust döngüleyicileri ise <code>Iterator</code> özelliği ile tanımlanırlar; <code>next</code> bize bir <code>Option</code> döner ve <code>Option</code> artık bir <code>None</code> olduğu zaman işimiz biter.</p>
<p>Bilinen işlemler artık birer metot. Aşağıda <code>find_if</code>'in muadilini görebilirsiniz. Bize bir <code>Option</code> döner (çünkü hiç yoksa <code>None</code> cevabı alırız) ve <code>if let</code> deyimi aracılığıyla <code>None</code> olmayan durumda değere erişebiliriz: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [10, 2, 30, 5];
if let Some(res) = arr.find(|x| x == 2) {
    // res is 2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="emniyetsizlik-ve-bağlı-listeler"><a class="header" href="#emniyetsizlik-ve-bağlı-listeler">Emniyetsizlik ve Bağlı Listeler</a></h3>
<p>Rust'ın standart kütüphanesinde <code>unsafe</code> (emniyetsiz kod bloğu) kullanıldığı bir sır değil. Bu ödünç alma kontrolünün muhafazakar anlayışını ihlal etmez. &quot;emniyetsiz (unsafe)&quot; kelimenin özel bir anlamı olduğuna dikkat edin - Rust'ın derleme zamanında anlayamadığı işlemler. Rust'ın perspektifinden C++ her an ve her zaman emniyetsiz modda çalışır! Büyük uygulamalarda birkaç düzine satırlık emniyetsiz kod gerekiyorsa, ki bu da olabilir, bir hata olduğu zaman bu satırların bir insan tarafından dikkatlice incelenmesi yeterli olacaktır. Bilirsiniz, insanoğlu 100 bin satır üstü kodları okumakta pek başarılı değildir.</p>
<p>Bundan bahsediyorum çünkü ortada bir örüntü var, tecrübeli bir C++ programcısı bir ağaç yapısını ya da bağlı liste oluşturduğu zaman kendisini biraz yılgın hisseder. Pekâlâ, çift bağlı liste üretmek emniyetli Rust için mümkündür; <code>Rc</code> akışı yönlendirir ve <code>Weak</code> referanslar aradan çekilir. Ancak standart kütüphane daha fazla performans elde etmek için... işaretçileri kullanır.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
