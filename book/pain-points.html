<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust ve Çektirdiği Çile - Rust&#x27;a Yumuşak Bir Başlangıç</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust diline, standart sistemine ve ekosistemine bir giriş.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="1-basics.html"><strong aria-hidden="true">1.</strong> Merhaba Dünya</a></li><li class="chapter-item expanded "><a href="2-structs-enums-lifetimes.html"><strong aria-hidden="true">2.</strong> Yapılar, Numaralandırmalar ve Eşleştirmeler</a></li><li class="chapter-item expanded "><a href="3-filesystem.html"><strong aria-hidden="true">3.</strong> Dosya Sistemi ve Süreçler</a></li><li class="chapter-item expanded "><a href="4-modules.html"><strong aria-hidden="true">4.</strong> Modüller ve Kargo</a></li><li class="chapter-item expanded "><a href="5-stdlib-containers.html"><strong aria-hidden="true">5.</strong> Standart Kütüphane Konteynırları</a></li><li class="chapter-item expanded "><a href="6-error-handling.html"><strong aria-hidden="true">6.</strong> Hataları Yönetmek</a></li><li class="chapter-item expanded "><a href="7-shared-and-networking.html"><strong aria-hidden="true">7.</strong> Sistem Süreçleri, Ağlar ve Paylaşım</a></li><li class="chapter-item expanded "><a href="object-orientation.html"><strong aria-hidden="true">8.</strong> Nesne Yönelimli Programlama</a></li><li class="chapter-item expanded "><a href="nom-intro.html"><strong aria-hidden="true">9.</strong> Yazıları Nom ile Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="pain-points.html" class="active"><strong aria-hidden="true">10.</strong> Rust ve Çektirdiği Çile</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust&#x27;a Yumuşak Bir Başlangıç</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="rust-ve-Çektirdiği-Çile"><a class="header" href="#rust-ve-Çektirdiği-Çile">Rust ve Çektirdiği Çile</a></h2>
<p>Rust'ın öğrenmesi pek çok &quot;ana akım&quot; dillere kıyasla öğrenmesi zor dillerden olduğunu söylemek doğru olur. Bazı istisnası insanlar o kadar da zor bulmuyor, fakat &quot;istisna&quot; ne anlama gelir buna dikkat edin - onlar <em>istinaidir</em>. Çoğu insan başta zorlanır ama sonra başarır. Başlangıçta çektiğiniz çilelerle neticede elde edeceğiniz şeyler arasında bir bağlantı yoktur.</p>
<p>Hepimiz bir yerlerden geliyoruz ve bu Python gibi &quot;dinamik&quot; veya &quot;C++&quot; gibi &quot;statik&quot; ana akım dilleriyle muhatap olmuş olduğumuz anlamına gelir. Her koşulda, Rust programlama anlayışımızı yeniden inşa etmeye zorlayacak kadar farklıdır. Zeki ve tecrübeli insanlar bu işin içine girip kendi zekiliklerinin fayda etmediğini görünce bir hayal kırıklığına uğruyorlar; kendisine yeterince değer vermeyenler de düşündükleri kadar &quot;zeki&quot; olmadıklarını düşünüyorlar.</p>
<p>Dinamik programlama tecrübesi olanlar (buna Java'yı da dahil edebilirim) her şeyin bir referans ve referansların da varsayılan olarak değişebilir olduğunu düşünür. Çöp toplayıcıları da bellek açısından emniyetli programlama yapmamıza yardımcı <em>olur</em>. Daha fazla bellek kullanımı ve öngörülememezlik pahasına da olsa JVM'i daha hızlı hâle getirmek için çok şey yapıldı. Bazen buna değer diye düşünülür, hiç modası geçmeyen bir fikir programcı üretkenliğinin bilgisayar performansından daha önemli olduğudur.</p>
<p>Fakat dünyadaki pek çok bilgisayarın - mesela arabalardaki gaz kelebeğini kontrol etmek gibi gibi hayati önemde şeyler yapan minik bir bilgisayarın - en ucuz laptop kadar kaynağa sahip değildir ve olaylara <em>eşzamanlı (realtime)</em> olarak cevap vermesi gerekir. Aynı şekilde yazılım altyapılarının doğru, sağlam ve hızlı olması gerekir. (Eski bir mühendislik kuralı). Şimdiye dek bu tarz işler kendi yapısı gereği hiçbir emniyet bulundurmayan C ve C++ ile yapıldı - bu raddedeki <em>emniyetsizliğin</em> toplam maaliyeti dikkat edilmesi gereken genel şey oldu. Bir programı çalışır hâle getirmek kolaydır, ama esas olay buradan sonra başlar.</p>
<p>Sistem programlama dillerinde bir çöp toplayıcısı bulunamaz çünkü onlar her şeyin üzerine inşa edildiği bina temelidir. Kaynakların sizin ihtiyaç duyduğunuz ve uygun gördüğünüz şekilde kullanılmasını sağlarlar. </p>
<p>Eğer çöp toplayıcısı olmazsa bellek başka türde şekillerde yönetilir. Manuel bellek yönetiminde belleği alırsınız, kullanırsınız ve bunu geri verirsiniz - kulağa kolay gibi gelse de aslında oldukça zordur. Üretken ve facia yaratmaya elverişli bir C programcısı olmak sizin için bir hafta sürer - ancak ne yaptığını bilen, bütün muhtemel hataları kontrol eden iyi bir C programcısı olmak yıllar sürer. </p>
<p>Rust belleği modern C++ gibi yönetir, nesneler yok edildiği zaman arka kalan bellek tekrar kullanılabilir. <code>Box</code> ile heap üzerinde bellek tahsis edebilirsiniz, ancak bu fonksiyon bittiğinde <code>Box</code> &quot;kapsam sonuna&quot; ulaşmış olur. <code>new</code> diye bir şey var ancak <code>delete</code> diye bir şey yok. <code>File</code> oluşturabilirsiniz, (önemli bir kaynak olan) dosya iş bittiğinde kendiliğinden kapatılır. Buna Rust'ta <em>düşürme (dropping)</em> denir.</p>
<p>Kaynakları paylaşmanız gerekir, her şeyin kopyasını üretmek verimsizdir, işi ilginç kılar da budur. C++'da da referanslar vardır ve Rust referansları daha çok C işaretçilerine benzer - veriye ulaşmak için <code>*r</code> kullanmanız gerekir ve veri referansını iletmek için de <code>&amp;</code>  kullanırsınız.</p>
<p>Rust'ın <em>ödünç alma denetçisi (borrow checker)</em> esas veri yok edildikten sonra referansının var olma ihtimalini ortadan kaldırır. </p>
<h2 id="tip-Çıkarımı"><a class="header" href="#tip-Çıkarımı">Tip Çıkarımı</a></h2>
<p>&quot;Statik&quot; ve &quot;dinamik&quot; arasındaki fark her şey değildir. Her şeyde olduğu gibi bu da çok katmanlı bir konudur. C, statik tipli (her değişkenin derleme zamanında tipi vardır) ancak zayıf tipli (weakly typed) (mesela <code>void*</code> her şeye işaret edebilir) bir dildir; Python ise dinamik tipli (Tip değişkende tanımlanmaz değil veriyle beraber gelir) fakat güçlü tipli (strongly typed) bir dildir. Java ise statik/güçlümtraktır (akla uygun görünen fakat tehlikeli olabilen veri dönüştürme (?) mekanizmasıyla) ve Rust ise statik/güçlüdür; çalışma zamanında gizlice veri dönüştürmez.</p>
<p>Java her bir tipin ne olduğunun detaylıca yazdırdığı yaygın olarak bilinirken Rust tipleri <em>tahmin (infer)</em> etmeyi sever. Bu genelde zekicedir ancak fakat bazen hangi tiple çalıştığınızı merak edersiniz. Mesela <code>let n = 100</code> gibi bir ifade görürsünüz ve merak edersiniz - bu sayının değeri ne? Varsayılan olarak bu <code>i32</code>dir, dort bitlik işaretli sayı. Herkes C'nin belirsiz sayı tiplerinin (<code>int</code> ve <code>long</code> gibi) kötü bir fikir olduğundan emindir, açık olmak en iyisidir. Bazen tipi belirtebilirsiniz, mesela <code>let n: u32 = 100</code> gibi ya da sayıyla beraber tipi de belirtebilirsiniz; <code>let n = 100u32</code> gibi. Ama tip çıkarımı dediğimi şey bundan ibaret değil! Eğer <code>let n = 100</code> yazarsanız <code>rustc</code> bunun <em>bir çeşit</em> sayı olduğunu bilir. <code>n</code> değişkenini bir yere iletirseniz ve fonksiyon <code>u64</code> bekliyorsa <code>n</code>'in tipi <code>u64</code> olacaktır!</p>
<p>Bu noktadan sonra eğer <code>u32</code> bekleyen bir yerde <code>n</code> değişkenini kullanırsanız <code>rustc</code> buna izin vermeyecektir çünkü <code>n</code>'in tipi <code>u64</code> olarak işaretlenmiştir ve bunu dönüştürmenin gizli ve kolay bir yolu olma<em>ya</em>caktır. İşte bu güçlü tiplemedir - &quot;Interger overflow&quot;dan muzdarip olana dek hayatınızı kolaylaştıracak ufak tip dönüşümleri Rust'ta yoktur. Açıkça <code>n</code> değerini <code>n as u32</code> olarak iletmeniz gerekir - Rust'ta tipler böyle dönüştürülür. Neyse ki, <code>rustc</code> sorunları müdahale edilebilirken vermekte iyidir - derleyicinin tavsiyesiyle sorunu düzeltebilirsiniz. </p>
<p>Bu sayede Rust açık tip ifadeleri olmaksızın yazılabilir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();
// v is deduced to have type Vec&lt;i32&gt;
v.push(10);
v.push(20);
v.push(&quot;hello&quot;) &lt;--- Bunu yapma işte, yapma
<span class="boring">}</span></code></pre></pre>
<p>Bir sayı vektörüne karakter dizisi iletememek bir sorun değil, özelliktir. Dinamik tipleme esnek olduğu kadar beladır da.</p>
<p>(Eğer bir vektör tipine hem sayı hem de karakter dizisi iletmeniz lazımsa, Rust'ın <code>enum</code> tipleri bu işi emniyetlice görür.)</p>
<p>Bazen ufak bir <em>ipucu</em> vermeniz gerekir. <code>collect</code> çok güzel bir döngüleyici metotudur, ama bazen ipucuna ihtiyaç duyar. Mesela <code>char</code> üzerinde çalışan bir döngüleyicim var. <code>collect</code> iki farklı biçimde çalışır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a vector of char ['h','e','l','l','o']
let v: Vec&lt;_&gt; = &quot;hello&quot;.chars().collect();
// a string &quot;doy&quot;
let m: String = &quot;dolly&quot;.chars().filter(|&amp;c| c != 'l').collect();
<span class="boring">}</span></code></pre></pre>
<p>Bazen değişken tipinden emin olamazsanız bunun da ufak bir yolu var, o da <code>rustc</code>'yi işleme alınan tipi bir hata mesajında yazdırmaktır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: () = var;
<span class="boring">}</span></code></pre></pre>
<p><code>rustc</code> aşırı spesifik bir tip seçebilir. Burada farklı referansları <code>&amp;Debug</code> vektörüne koyuyoruz ancak tipleri açıkça belirtmemiz gereklidir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

let answer = 42;
let message = &quot;hello&quot;;
let float = 2.7212;

let display: Vec&lt;&amp;Debug&gt; = vec![&amp;message, &amp;answer, &amp;float];

for d in display {
    println!(&quot;got {:?}&quot;, d);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="değişebilir-referanslar"><a class="header" href="#değişebilir-referanslar">Değişebilir Referanslar</a></h2>
<p>Kural basit: bir anda sadece değişken referans olabilir. Bunun sebebi değişimin <em>her yerde</em> gerçekleşmesinin önüne geçmek. Küçük programlar yazarken fark etmiyor olabilirsiniz ancak büyük kod yapılarında başınıza ciddi bela olabilir.</p>
<p>Bir diğer kural ise ortada değişemez referanslar varken değişebilir referans elde edemiyor oluşunuzdur. Aksi takdirde kimse bu değişemez referansların değişemeyeceğini garantezi edemezdi. C++ da değişemez referanslara sahiptir (mesela <code>const string&amp;</code>) gibi ancak başka birisinin <code>string&amp;</code> referansı alıp veriyi değiştiremeyeceğini garanti <em>edemez</em>.</p>
<p>Her referansın değişebilir olduğu dillerle çalışmaya alışıksanız bu size ters gelecektir. Emniyetsiz, &quot;rahat&quot; diller tamamen programcının kötü bir şey yapmayacağına ve kendi programını kesinlikle iyi bir şekilde anladığını düşünerek çalışır. Fakat bir kişiden daha fazla kişi tarafından geliştirilmiş büyük programlar bir kişinin programın ne olduğunu anlayıp anlamamasından çok daha ötededir.</p>
<p>İşin <em>gıcık eden</em> eden tarafı ödünç alma denetçisinin düşündüğümüz kadar zeki olmamasıdır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut m = HashMap::new();
m.insert(&quot;one&quot;, 1);
m.insert(&quot;two&quot;, 2);

if let Some(r) = m.get_mut(&quot;one&quot;) { // &lt;-- mutable borrow of m
    *r = 10;
} else {
    m.insert(&quot;one&quot;, 1); // can't borrow mutably again!
}
<span class="boring">}</span></code></pre></pre>
<p>Eğer <code>None</code> elde etmişsek HashMap'ten hiçbir şey ödünç alınmıyor, yani burada <em>gerçekten</em> hiçbir şey ödünç alma kurallarını çiğnemiyor.</p>
<p>Hâliyle iş çirkinleşiyor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut found = false;
if let Some(r) = m.get_mut(&quot;one&quot;) {
    *r = 10;
    found = true;
}
if !found {
    m.insert(&quot;one&quot;, 1);
}
<span class="boring">}</span></code></pre></pre>
<p>Rezalet olsa da işe yarıyor çünkü sadece &quot;if&quot; ifadesinde bir adet referasımız tutulmuş oluyor.</p>
<p>Daha iyisi <code>HashMap</code> içindeki <a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">entry</a> metotunu kullanmaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::hash_map::Entry;

match m.entry(&quot;one&quot;) {
    Entry::Occupied(e) =&gt; {
        *e.into_mut() = 10;
    },
    Entry::Vacant(e) =&gt; {
        e.insert(1);
    }
};
<span class="boring">}</span></code></pre></pre>
<p>Ödünç alma mekanizmasının bu sıralar <em>sözcüksel olmayan yaşam süreleri (non-lexical lifetimes)</em> hakkında daha yumuşak olacağı konuşuluyor. </p>
<p>Yine de ödünç alma mekanizması bazı önemli vakaları <em>anlıyor</em>. Mesela bir yapınız varsa alanları bağımsız olarak ödünç alınabilir. Birleşke mantığı işinize yarayacaktır, büyük yapılar (struct) kendi metotları olan daha ufak yapıları barındırmalıdır. Değişken metotları büyük yapılar içinde tanımlamak, tek bir alan değiştirilmiş olsa bile bütün yapının değiştirilemeyeceği durumlara yol açacaktır.</p>
<p>Değişebilir verilerin söz konusu olduğu durumlarda verilerin parçalarının bağımsız olarak işlendiği özel durumlar vardır. Örneğin değişebilir bir diliminiz varsa, <code>split_at_mut</code> size değişebilir iki referans verecektir. Bu gayet emniyetlidir çünkü Rust bu iki dilimin kazara aynı verileri sahiplenmeyeceğinden emin olacaktır.</p>
<h2 id="referanslar-ve-yaşam-süreleri"><a class="header" href="#referanslar-ve-yaşam-süreleri">Referanslar ve Yaşam Süreleri</a></h2>
<p>Rust, referasın veriden daha uzun süre yaşadığı durumlara izin vermez. Aksi taktirde ölü veriye işaret eden &quot;ölü referanslarımız&quot; bulurdu - <code>segfault</code> kaçınılmaz olurdu.</p>
<p><code>rustc</code> genelde fonksiyonlardaki yaşam süreleri hakkında mantıklı çıkarımlar yapabilir:</p>
<pre><pre class="playground"><code class="language-rust">fn pair(s: &amp;str, ch: char) -&gt; (&amp;str, &amp;str) {
    if let Some(idx) = s.find(ch) {
        (&amp;s[0..idx], &amp;s[idx+1..])
    } else {
        (s, &quot;&quot;)
    }
}
fn main() {
    let p = pair(&quot;hello:dolly&quot;, ':');
    println!(&quot;{:?}&quot;, p);
}
// (&quot;hello&quot;, &quot;dolly&quot;)</code></pre></pre>
<p>Gayet emniyetlidir çünkü burada herhangi bir sınırlayıcı yoktur. <code>rustc</code> iki karakter dizisinin de fonksiyona aktarılan karakter dizisinin referansları olduğuna karar verir.</p>
<p>Aslında fonksiyon tanımı şu şekildedir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pair&lt;'a&gt;(s: &amp;'a str, ch: char) -&gt; (&amp;'a str, &amp;'a str) {...}
<span class="boring">}</span></code></pre></pre>
<p>Bu noktasyon çıktıdaki karakter dizilerinin <em>en fazla</em> girdideki karakter dizileri kadar yaşayacağına karar verir. Yaşam sürelerinin aynı olduğu anlamına gelmez bu, onları istediğimiz an düşürebiliriz, sadece &quot;<code>s</code>&quot;ten fazla yaşamayacağını belirtiriz.</p>
<p>Yani, <code>rustc</code> <em>yaşam süresi saptaması (lifetime ellision/?)</em> işimizi biraz daha rahatlatır. </p>
<p>Şimdi eğer fonksiyon <em>iki</em> karakter dizisi alırsa, yaşam sürelerini açıkça belirtmemiz gerekir ki hangi çıktının hangi girdiyi referans aldığını bilmiş olalım.</p>
<p>Bir referans tutan bir yapı tanımladığımız sırada neyin ne kadar yaşam ömrü olduğunu belirtmeliyiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Container&lt;'a&gt; {
    s: &amp;'a str
}
<span class="boring">}</span></code></pre></pre>
<p>Burada da yapının referanstan daha uzun süre yaşamayamayacağını vurgulamış oluyoruz. Hem yapılar hem de fonksiyonlar için yaşam süresinin <code>&lt;&gt;</code> içerisinde tıpkı tip belirtilir gibi belirtilmesi gereklidir.</p>
<p>Kapamalar gayet akılcı ve güçlü bir özelliktir - Rust kapamalarının gücü buradan gelir. Eğer onları bir yerde saklamak isterseniz onlara bir yaşam süresi belirtmeniz gerekir. Çünkü kapamalar kendi özünde çevresinden referanslar alan ve çağrılabilen bir yapıdır. Mesela <code>m</code> ve <code>c</code> şeklinde değişemez referanslar alabilen <code>linear</code> kapamasına bakalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let m = 2.0;
let c = 0.5;

let linear = |x| m*x + c;
let sc = |x| m*x.cos()
...
<span class="boring">}</span></code></pre></pre>
<p><code>linear</code> ve <code>sc</code> kapamalarının ikisi de <code>Fn(x: f64) -&gt; f64</code> özelliğine sahiptir ancak ikisi de aynı yaratık <em>değildir</em> - ikisinin de farklı tipleri ve boyutları vardır! Eğer saklamak isterseniz tiplerini <code>Box&lt;Fn(x: f64)-&gt;f64 + 'a&gt;</code> olarak belirtilmelilerdir.</p>
<p>JavaScript veya Lua'da kapamaların nasıl da su gibi aktığına görmüşseniz size biraz sinir bozucu gelecektir. Ancak C++ da Rust ile aynı şeyi yapar ve sanal çağrılar için ufak bir bedel karşılığında farklı türden kapamaları saklamak için <code>std::function</code>'a ihtiyaç duyar.</p>
<h2 id="karakter-dizileri"><a class="header" href="#karakter-dizileri">Karakter Dizileri</a></h2>
<p>Rust'ta karakter dizilerinin başlangıçta sinir bozucu gelmesi olağandır. Onları üretmenin birden çok yolu vardır ve hepsi gereksiz detaylı gelir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;hello&quot;.to_string();
let s2 = String::from(&quot;dolly&quot;);
<span class="boring">}</span></code></pre></pre>
<p>&quot;hello&quot; hâli hazırda bir karakter dizisi değil midir? Yani, bir şekilde. <code>String</code> <em>sahipli</em> bir karakter dizisidir ve heap üzerinde yer tutar. Bir karakter dizisi kalıbı olan <code>&amp;str</code> (karakter dizisi dilimi) tipi ise (sabit olarak) çalıştırılabilir dosyanın içinde bekler ya da <code>String</code>'ten ödünç alınarak oluşturulur. Sistem programlama dillerinin bu ayrıma ihtiyacı vardır - ufak bir mikrokontrollerı düşünür, azıcık RAM ve biraz daha fazla RM'u bulunur. Karakter dizisi kalıpları daha az enerji harcayan ve ucuz olan ROM'da (&quot;read-only/salt okunur&quot;) depolanır. </p>
<p>Fakat bu C++'da çok daha kolay (diyebilirsiniz):</p>
<pre><code class="language-C">std::string s = &quot;hello&quot;;
</code></pre>
<p>Kısaca evet, fakat bir karakter dizisinin örtükçe nasıl oluşturulduğunu da gizlemektedir. Rust bellek tahsis etme konusunda açık olmayı tercih eder, hâliyle <code>to_string</code> gibi şeyler var. Öbür taraftan, C++ karakter dizilerini ödünç almak için <code>c_str</code> kullanmalısınız ve C'nin karakter dizileri çok kullanışsızdır.</p>
<p>Neyse ki, Rust'ta işler çok daha iyi işliyor - <code>String</code> ve <code>&amp;str</code> tiplerinin ikisinin de gerekli olduğunu <em>bir kere</em> kabul ederseniz. <code>String</code> metotları çoğunlukla karakter dizisini değiştirmek içindir, mesela <code>push</code> bir karakter ekler (alttan alta <code>Vec&lt;u8&gt;</code> gibi çalışır). Fakat <code>&amp;str</code> metotlarının tamamına da sahiptir. <code>Deref</code> mekanizması aracılığıyla bir <code>String</code> aynı zamanda <code>&amp;str</code> olarak iletilebilir - bu yüzden nadiren fonksiyon tanımlarında <code>&amp;String</code> görürsünüz.</p>
<p>Çeşitli özellikler (trait) aracılığıyla <code>&amp;str</code>'den <code>String</code> elde etmenin pek çok yolu var. Rust özelliklerin tiplerinin genellenerek çalışmasına izin verir. Pratik bir kural olarak, <code>Display</code> özelliğine sahip her şey <code>to_string</code>'e sahiptir; <code>42.to_string()</code> gibi.</p>
<p>Bazı operatörler beklediğiniz gibi davranmaz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s1 = &quot;hello&quot;.to_string();
    let s2 = s1.clone();
    assert!(s1 == s2);  // cool
    assert!(s1 == &quot;hello&quot;); // fine
    assert!(s1 == &amp;s2); // WTF?
<span class="boring">}</span></code></pre></pre>
<p>Hatırlayın ki <code>String</code> ve <code>&amp;String</code> birbirinden farklı tiplerdir ve <code>==</code> bu tarz komibasyonlarda tanımlı değildir. C++ programlamaya alışık bir kişi değerlerin yerine referansların konulduğunu görmeyi beklediğinden şaşırabilir. Ek olarak <code>&amp;s2</code> kendiğinden <code>&amp;str</code> olmayacaktır çünkü <em>deref zorlaması</em> bir  <code>&amp;str</code> değişkeni veya argümanı atadığınız zaman çalışacaktır. (<code>s2.as_str()</code> diye açıkça ifade etmek işinize yarayacaktır.)</p>
<p>Ancak bu harbiden bir &quot;has***tir artık&quot; denmeyi hakeder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s3 = s1 + s2;  // &lt;--- no can do
<span class="boring">}</span></code></pre></pre>
<p>İki <code>String</code> değerini birleştiremezsiniz, ancak bir <code>String</code> ile <code>&amp;str</code>'i birleştirebilirsiniz. Fakat <code>&amp;str</code> ile <code>String</code>'i birleştiremezsiniz. Bu yüzden pek çok insan <code>+</code> yerine <code>format!</code> makrosunu tercih eder, biraz daha tutarlıdır ancak o kadar da verimli değildir.</p>
<p>Bazı karakter dizisi işlemleri de mevcuttur ancak farklı çalışır. Mesela pek çok dilin <code>split</code> metotu vardır ki bu da bir karakter dizisini, karakter dizisi listesine dönüştürür. Rust'ta karakter dizisi metodu bir döngüleyici döner ve bunu &quot;sonra&quot; bir vektör içerisine toplayabilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parts: Vec&lt;_&gt; = s.split(',').collect();
<span class="boring">}</span></code></pre></pre>
<p>Eğer hızlıca bir vektör almak istiyorsanız biraz göze batabilir fakat yeni bir vektörü belelkte tahsis etmeden önce birkaç işlem yapabilirsiniz. Mesela parçalanmış bir metin içerisinden en uzun kelimeyi mi almak istiyorsunuz?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let max = s.split(',').map(|s| s.len()).max().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>(Eğer doş bir döngüleyici varsa maksimum değer de olmayacaktır ve bu durumu kontrol etmek için <code>unwrap</code> kullanıyoruz.)</p>
<p><code>collect</code> metotu bize parçaların orijinal karakter dizisinden ödünç alındığı bir <code>Vec&lt;&amp;str&gt;</code> döner - sadece referanslar için bellekte alan tahsis etmemiz gerekir. C++'da çalıştığı gibi bir metot yok fakat son zamana dek her alt diziye ayrıca alan tahsis edilmesi gerekiyordu. (C++ 17 ile beraber Rust'taki <code>&amp;str</code> gibi çalışan <code>std::string_view</code> geldi.)</p>
<h2 id="noktalı-virgüller-hakkında-bir-not"><a class="header" href="#noktalı-virgüller-hakkında-bir-not">Noktalı virgüller hakkında bir not</a></h2>
<p>Noktalı virgüller bu dilde de zorunludur, fakat C'de noktalı virgül konulmaması gereken yerlerde Rust'ta da konulmaz, mesela <code>{}</code> bloklarından sonra. Aynı zamanda  <code>enum</code> ve <code>struct</code> içinde de onlara ihtiyaç yoktur. (Bu C'den gelen bir acayiplik) Fakat, eğer blok bir değer dönmeliyse noktalı virgüllere ihtiyaç kalmaz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let msg = if ok {&quot;ok&quot;} else {&quot;error&quot;};
<span class="boring">}</span></code></pre></pre>
<p>Bütün bir <code>let</code> deyiminin ardından yine bir noktalı virgül koymak zorunda olduğumuza dikkat edin!</p>
<p>Eğer noktalı karakter dizisi kalıplarından sonra noktalı virgül koysaydık bize <code>()</code> dönerdi. (<code>Nothing</code> veya <code>void</code> gibi) Bu fonksiyondan değer dönerken karşılaşılan olağan bir hatadır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sqr(x: f64) -&gt; f64 {
    x * x;
}
<span class="boring">}</span></code></pre></pre>
<p><code>rustc</code> size bu durumda açıklayıcı bir hata mesajıyla geri dönüş yapacaktır.</p>
<blockquote>
<p>Rust, Haskell ve Ruby gibi expression-based bir dildir ve bu kavramı &quot;ifade odaklı&quot;  olarak düşünebilirsiniz. Bu tarz dillerde her ifadenin bir değeri vardır </p>
</blockquote>
<h2 id="c-ile-alakalı-konular"><a class="header" href="#c-ile-alakalı-konular">C++ ile Alakalı Konular</a></h2>
<h3 id="rustta-değer-semantikleri-farklıdır"><a class="header" href="#rustta-değer-semantikleri-farklıdır">Rust'ta Değer Semantikleri Farklıdır</a></h3>
<p>C++'da ilkel tipler gibi davranacak ve kendisini kopyalayacak tipler tanımlamak mümkündür. Ek olarak, bir değerin geçici bir bağımdan başka bir bağlama nasıl taşınacağını belirlemek adına taşıma oluşturucusu kullanılır.</p>
<p>Rust'ta ilkel tipler beklendiği gibi davranır fakat <code>Copy</code> özelliği sadece kopyalanabilir türler içeriyorsa (yapılar, demetler veya numaralandırma) kullanıcının tanımladığı tiplere eklenebilir. Diğer tiplere <code>Clone</code> eklenebilir ancak bu sefer de verilerin <code>clone</code> metotunu çağırmanız gerekir. Rust, herhangi bir bellekte alan tahsis etme işleminin açıktan olmasını ister ve atama operatörlerini ya da kopyalama oluşturucularını gizlemez.</p>
<p>Yani, kopyalama ile taşıma her zaman birkaç biti hareket etmesi olarak tanımlanır ve geçersiz kılınamaz.</p>
<p>Eğer <code>s1</code> <code>Copy</code> özelliğini içermeyen bir türse <code>s2 = s1</code> bir taşımaya sebep olur ve bu <code>s1</code>'i <em>tüketir</em>!  Eğer gerçek bir kopya üretmek istiyorsanız <code>clone</code> kullanın.</p>
<p>Ödünç alma çoğu zaman kopyalamadan daha iyidir ancak bu sefer de ödünç alma kurallarını takip etmelisiniz. Neyse ki, ödünç alma işlemi yeniden düzenlenebilir bir davranıştır. Mesela <code>String</code>, <code>&amp;str</code> olarak ödünç alınabilir ve <code>&amp;str</code>'nin değişmeyen metotlarını kullanabilir. <em>Karakter dizisi dilimleri</em> de C++'ın <code>const char*</code>dan farksız <code>c_str</code> anlayışındaki ödünç alma yöntemine kıyasla çok daha güçlüdür. <code>&amp;str</code> sahiplenilmiş birkaç baytın işaretçisinden (veya bir karakter dizisi kalıbından) ve <em>boyut bilgisinden</em> oluşur. Bu, bellek açısından oldukça verimli örüntüler kurmamıza yardımcı olur. Mesela bütün karakter dizilerinin bir karakter dizisinden ödünç alındığı bir <code>Vec&lt;&amp;str&gt;</code> oluşturulabilir - tek ihtiyacınız olan vektör için ek alan olacaktır:</p>
<p>Mesela, boşluklardan bölerken:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn split_whitespace(s: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
    s.split_whitespace().collect()
}
<span class="boring">}</span></code></pre></pre>
<p>Aynı şekilde, C++'daki <code>s.substr(0,2)</code> her zaman karakter dizisinin kopyasını oluşturur ancak dilim sadece ödünç alır: <code>&amp;[0..2]</code></p>
<p>Buna benzer ilişki <code>Vec&lt;T&gt;</code> ve <code>&amp;[T]</code> arasında da bulunur.</p>
<h3 id="paylaşılan-referanslar"><a class="header" href="#paylaşılan-referanslar">Paylaşılan Referanslar</a></h3>
<p>C++'da bulunduğu gibi Rust için de <em>akıllı işaretçiler (smart pointers)</em> bulunur - mesela <code>std::unique_ptr</code> muadili <code>Box</code>tur. Bellek ve tahsis edilmiş diğer kaynaklar <code>Box</code> kapsam dışına çıktığı zaman geri iade edildiğinden <code>delete</code> kullanmaya ihtiyaç yoktur. (Rust RAII'yi epeyce benimsemiştir.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut answer = Box::new(&quot;hello&quot;.to_string());
*answer = &quot;world&quot;.to_string();
answer.push('!');
println!(&quot;{} {}&quot;, answer, answer.len());
<span class="boring">}</span></code></pre></pre>
<p>İnsanlar başlangıçta <code>to_string</code>'i başlangıçta pek sevmez ancak işleri <em>açıktan</em> yapmayı sağlar.</p>
<p>Açık dereferans operatörü olan <code>*</code> önemli ancak metotlar üzerinde herhangi bir özel notasyon kullanmadığımıza dikkat edin. (Mesela burada <code>(*answer).push('!') yok</code>)</p>
<p>Ödünç almanın sadece orijinal içeriğin sahibi belli olduğu zaman işe yaradığı açıktır. Çoğu tasarımda bu mümkün değildir.</p>
<p>Bu C++'da <code>std::shared_ptr</code>'in kullanıldığı yerdir; kopyalama sadece veri üzerindeki referans sayısını attırır. Bunun da bir bedeli var, üstelik:</p>
<ul>
<li>veri sadece salt okunabilir olsa bile, sürekli referans sayımının arttırılması önbelleğin doğrulanamamasına sebep olabilir. </li>
<li><code>std::shared_ptr</code> süreçler arası emniyetlice paylaşılabilecek şekilde tasarlanmıştır ve kendi kilidini de beraberinde taşıması kaba maliyeti arttırmaktadır.</li>
</ul>
<p>Rust'ta <code>std::rc::Rc</code> da aynı zamanda referans sayımı yapan paylaşılan akıllı işaretçi gibi davranır. Fakat, bu sadece değişemez referanslar içindir! Eğer süreç anlamında emniyetli bir türünü istiyorsanız, <code>std::sync::Arc</code> (&quot;Atomik Rc&quot;) kullanabilirsiniz. Rust iki farklı tür sunduğu için biraz tuhaf görünebilir fakat süreçlerin işin içine girmediği işlemler için kaba maliyeti arttırmamış olursunuz.</p>
<p>Değişemez referanslar olmalarının sebebi bunun Rust'ın bellek modelinin esaslarıyla olmasıyla alakalıdır. Fakat yine de sıyrılmanın bir yolu vardır: <code>std::cell:RefCell</code>. Eğer paylaşılan referansınızı <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> olarak tanımlarsanız <code>borrow_mut</code> ile değişebilir referans edinebilirsiniz. Bu sefer Rust kurallarını <em>dinamik</em> olarak uygularsınız - mesela zaten bir referans varken ek olarak <code>borrow_mut</code> kullanırsanız bir paniğe sebep olacaktır.</p>
<p>Yine de bu hâlen daha <em>emniyetlidir</em>. Panikler bellekte yanlış bir yere dokunulduğu andan <em>önce</em> gerçekleşir! Tıpkı fırlatılan hatalar gibi, çağrı sırası teker teker boşaltılır. Bu derece yapılandırılmış bir süreç için talihsiz bir kelime seçimi diyebiliriz - bu panikleyerek kapanmak yerine sıralı bir temizliktir.</p>
<p><code>Rc&lt;RefCell&lt;T&gt;&gt;</code> tipi göze biraz biraz batıyor olabilir, ancak kullanılış şekli kesinlikle kötü değil. Burada, Rust (tekrardan) işlerin açıktan yürümesini tercih etmiş oluyor.</p>
<p>Ortak durumu eğer bellek açısından güvenli bir şekilde paylaşmak istiyorsanız <code>Arc&lt;T&gt;</code> tek <em>emniyetli</em> yoldur. Eğer değişebilir erişimlere ihtiyaçlarınız varsa <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> yerine <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> kullanırsınız. <code>Mutex</code> tanımlandığından biraz daha farklı çalışır, bu veri için bir kutu görevi görür. Veriyi <code>lock</code> ile alır ve düzenlersiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let answer = Arc::new(Mutex::new(10));

// in another thread
..
{
  let mut answer_ref = answer.lock().unwrap();
  *answer_ref = 42;
}
<span class="boring">}</span></code></pre></pre>
<p>Neden <code>unwrap</code>? Eğer kilidi elinde tutan süreç paniklerse <code>lock</code> hata verir. (Resmi dokümentasyon bu tarz durumlarda <code>unwrap</code> kullanmanın mantıklı olduğunu düşünür çünkü belli bir şeyler çok yanlış gitmiş. Panikler süreçlerin içerisinde yakalanabilir.)</p>
<p>Özel kilidi mümkün olduğu sürece kısa sürece tamamlayıp işi teslim etmek (Mutexlerde her zaman olduğu gibi) önemlidir. Onları sınırlı bir kapsam içerisinde tutmak yaygın bir tercihtir - değişebilir referans kapsam dışına çıktığı zaman kilit de sona ermiş olur.</p>
<p>C++'ın sadeliği ile bunu kıyaslayınca (&quot;dostum sadece <code>shared_ptr</code> kullan&quot;) göze biraz acayip görünüyor. Fakat bu şekilde paylaşılan veriler arasındaki herhangi bir <em>düzenleme</em> daha kolay fark ediliyor ve <code>Mutex</code> kilidi örüntüsü süreç emniyetine yönlendiriyor.</p>
<p>Her şeyde olduğu gibi, paylaşılan referansları kullanırken <a href="https://news.ycombinator.com/item?id=11698784">dikkatli olun.</a>.</p>
<h3 id="döngüleyiciler"><a class="header" href="#döngüleyiciler">Döngüleyiciler</a></h3>
<p>C++'da döngüleyiciler olağan bir yoldan yapılamaz; akıllı işaretçilere sahiptirler ve genellikle <code>c.begin()</code> ile başlar ve <code>c.end()</code> ile biterler. Döngüleyiciler üzerindeki operasyonlar yalnız başına şablon fonksiyonları olarak kullanılır, <code>std::find_if</code> gibi.</p>
<p>Rust döngüleyicileri ise <code>Iterator</code> özelliği ile tanımlanırlar; <code>next</code> bize bir <code>Option</code> döner ve <code>Option</code> artık bir <code>None</code> olduğu zaman işimiz biter.</p>
<p>Bilinen işlemler artık birer metot. Aşağıda <code>find_if</code>'in muadilini görebilirsiniz. Bize bir <code>Option</code> döner (çünkü hiç yoksa <code>None</code> cevabı alırız) ve <code>if let</code> deyimi aracılığıyla <code>None</code> olmayan durumda değere erişebiliriz: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [10, 2, 30, 5];
if let Some(res) = arr.find(|x| x == 2) {
    // res is 2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="emniyetsizlik-ve-bağlı-listeler"><a class="header" href="#emniyetsizlik-ve-bağlı-listeler">Emniyetsizlik ve Bağlı Listeler</a></h3>
<p>Rust'ın standart kütüphanesinde <code>unsafe</code> (emniyetsiz kod bloğu) kullanıldığı bir sır değil. Bu ödünç alma kontrolünün muhafazakar anlayışını ihlal etmez. &quot;emniyetsiz (unsafe)&quot; kelimenin özel bir anlamı olduğuna dikkat edin - Rust'ın derleme zamanında anlayamadığı işlemler. Rust'ın perspektifinden C++ her an ve her zaman emniyetsiz modda çalışır! Büyük uygulamalarda birkaç düzine satırlık emniyetsiz kod gerekiyorsa, ki bu da olabilir, bir hata olduğu zaman bu satırların bir insan tarafından dikkatlice incelenmesi yeterli olacaktır. Bilirsiniz, insanoğlu 100 bin satır üstü kodları okumakta pek başarılı değildir.</p>
<p>Bundan bahsediyorum çünkü ortada bir örüntü var, tecrübeli bir C++ programcısı bir ağaç yapısını ya da bağlı liste oluşturduğu zaman kendisini biraz yılgın hisseder. Pekâlâ, çift bağlı liste üretmek emniyetli Rust için mümkündür; <code>Rc</code> akışı yönlendirir ve <code>Weak</code> referanslar aradan çekilir. Ancak standart kütüphane daha fazla performans elde etmek için... işaretçileri kullanır.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="nom-intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="nom-intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
